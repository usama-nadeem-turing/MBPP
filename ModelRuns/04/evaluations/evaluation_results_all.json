[
  {
    "mbpp_id": 11,
    "problem_statement": "Write a python function to remove first and last occurrence of a given character from the string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_Occ(s, c):\n    # Remove the first occurrence of the character 'c'\n    s = s.replace(c, '', 1)\n    \n    # Remove the last occurrence of the character 'c'\n    if len(s) > 0:\n        s = s[:-1]\n    \n    return s",
    "test_cases": [
      "assert remove_Occ(\"hello\",\"l\") == \"heo\"",
      "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"",
      "assert remove_Occ(\"PHP\",\"P\") == \"H\""
    ]
  },
  {
    "mbpp_id": 12,
    "problem_statement": "Write a function to sort a given matrix in ascending order according to the sum of its rows.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sort_matrix(matrix):\n    # Sort the list of lists based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix",
    "test_cases": [
      "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
      "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
      "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
    ]
  },
  {
    "mbpp_id": 13,
    "problem_statement": "Write a function to count the most common words in a dictionary.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from collections import Counter\n\ndef count_common(dictionary):\n    # Count the occurrences of each word in the dictionary\n    word_count = Counter(dictionary)\n    \n    # Find and sort the top N most common words\n    top_n_words = word_count.most_common(10)  # Change 10 to desired N\n    \n    # Format the result as a list of tuples with word and its count\n    formatted_result = [(word, count) for word, count in top_n_words]\n    \n    return formatted_result",
    "test_cases": [
      "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
      "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
      "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
    ]
  },
  {
    "mbpp_id": 14,
    "problem_statement": "Write a python function to find the volume of a triangular prism.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_Volume(base, height, length):\n    # Calculate the area of the base triangle and then multiply it by the length of the prism\n    return (base * height * length) / 2",
    "test_cases": [
      "assert find_Volume(10,8,6) == 240",
      "assert find_Volume(3,2,2) == 6",
      "assert find_Volume(1,2,1) == 1"
    ]
  },
  {
    "mbpp_id": 15,
    "problem_statement": "Write a function to split a string at lowercase letters.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef split_lowerstring(input_string):\n    # Split the input string using regular expression to match lowercase letters and numbers\n    return re.split('[a-z]', input_string)\n\n# Test cases\nprint(split_lowerstring(\"AbCd\"))  # Expected output: ['bC', 'd']\nprint(split_lowerstring(\"Python\"))  # Expected output: ['y', 't', 'h', 'o', 'n']\nprint(split_lowerstring(\"Programming\"))  # Expected output: ['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']",
    "test_cases": [
      "assert split_lowerstring(\"AbCd\")==['bC','d']",
      "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
      "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
    ]
  },
  {
    "mbpp_id": 16,
    "problem_statement": "Write a function to find sequences of lowercase letters joined with an underscore.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def text_lowercase_underscore(text):\n    words = text.split('_')\n    for word in words:\n        if all(char.islower() for char in word):\n            return 'Found a match!'\n    return 'Not matched!'\n\n# Test cases\nprint(text_lowercase_underscore(\"aab_cbbbc\"))  # Expected output: Found a match!\nprint(text_lowercase_underscore(\"aab_Abbbc\"))  # Expected output: Not matched!\nprint(text_lowercase_underscore(\"Aaab_abbbc\"))  # Expected output: Not matched!",
    "test_cases": [
      "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
      "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
      "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
    ]
  },
  {
    "mbpp_id": 17,
    "problem_statement": "Write a function to find the perimeter of a square.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def square_perimeter(side_length):\n    return side_length * 4",
    "test_cases": [
      "assert square_perimeter(10)==40",
      "assert square_perimeter(5)==20",
      "assert square_perimeter(4)==16"
    ]
  },
  {
    "mbpp_id": 18,
    "problem_statement": "Write a function to remove characters from the first string which are present in the second string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_dirty_chars(source_string, dirty_string):\n    result = \"\"\n    for char in source_string:\n        if char not in dirty_string:\n            result += char\n    return result",
    "test_cases": [
      "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
      "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
      "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
    ]
  },
  {
    "mbpp_id": 19,
    "problem_statement": "Write a function to find whether a given array of integers contains any duplicate element.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given list has any duplicates.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if there is at least one duplicate, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False",
    "test_cases": [
      "assert test_duplicate(([1,2,3,4,5]))==False",
      "assert test_duplicate(([1,2,3,4, 4]))==True",
      "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
    ]
  },
  {
    "mbpp_id": 20,
    "problem_statement": "Write a function to check if the given number is woodball or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_woodall(n):\n    # Check for divisors other than 1 and n itself\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True if n > 1 else False",
    "test_cases": [
      "assert is_woodall(383) == True",
      "assert is_woodall(254) == False",
      "assert is_woodall(200) == False"
    ]
  },
  {
    "mbpp_id": 21,
    "problem_statement": "Write a function to find m number of multiples of n.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def multiples_of_num(m, n):\n    return [i*n for i in range(1, m+1)]",
    "test_cases": [
      "assert multiples_of_num(4,3)== [3,6,9,12]",
      "assert multiples_of_num(2,5)== [5,10]",
      "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
    ]
  },
  {
    "mbpp_id": 22,
    "problem_statement": "Write a function to find the first duplicate element in a given array of integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - list index out of range",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_first_duplicate(arr):\n    n = len(arr)\n    for i in range(n):\n        while arr[i] != i:\n            j = arr[i]\n            if arr[i] == arr[j]:\n                return arr[i]\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n    return -1",
    "test_cases": [
      "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
      "assert find_first_duplicate([1, 2, 3, 4])==-1",
      "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
    ]
  },
  {
    "mbpp_id": 23,
    "problem_statement": "Write a python function to find the maximum sum of elements of list in a list of lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - 'int' object is not iterable",
      "Test 2: FAIL - 'int' object is not iterable",
      "Test 3: FAIL - 'int' object is not iterable"
    ],
    "generated_code": "def maximum_Sum(lst_of_lsts):\n    max_sum = float('-inf')\n    for lst in lst_of_lsts:\n        current_sum = sum(sum(sublist) for sublist in lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum",
    "test_cases": [
      "assert maximum_Sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
      "assert maximum_Sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
      "assert maximum_Sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
    ]
  },
  {
    "mbpp_id": 24,
    "problem_statement": "Write a function to convert the given binary number to its decimal equivalent.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - int() can't convert non-string with explicit base",
      "Test 2: FAIL - int() can't convert non-string with explicit base",
      "Test 3: FAIL - int() can't convert non-string with explicit base"
    ],
    "generated_code": "def binary_to_decimal(binary_number):\n    # Convert the binary string to an integer\n    decimal_value = int(binary_number, 2)\n    return decimal_value",
    "test_cases": [
      "assert binary_to_decimal(100) == 4",
      "assert binary_to_decimal(1011) == 11",
      "assert binary_to_decimal(1101101) == 109"
    ]
  },
  {
    "mbpp_id": 25,
    "problem_statement": "Write a python function to find the product of non-repeated elements in a given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from functools import reduce\nfrom operator import mul\n\ndef find_Product(arr, n):\n    # Filter out the non-repeated elements from the array\n    unique_elements = list(filter(lambda x: arr.count(x) == 1, arr))\n    \n    # Calculate the product of the unique elements\n    result = reduce(mul, unique_elements, 1)\n    \n    return result",
    "test_cases": [
      "assert find_Product([1,1,2,3],4) == 6",
      "assert find_Product([1,2,3,1,1],5) == 6",
      "assert find_Product([1,1,4,5,6],5) == 120"
    ]
  },
  {
    "mbpp_id": 26,
    "problem_statement": "Write a function to check if the given tuple list has all k elements.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def check_k_elements(tuples_list, k):\n    \"\"\"\n    This function checks if every tuple in the provided list contains exactly 'k' elements.\n    \n    Parameters:\n    tuples_list (list of tuples): The list of tuples to be checked.\n    k (int): The exact number of elements each tuple must contain.\n    \n    Returns:\n    bool: True if every tuple in the list contains exactly 'k' elements, otherwise False.\n    \"\"\"\n    for tup in tuples_list:\n        if len(tup) != k:\n            return False\n    return True\n\n# Test cases\nassert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True\nassert check_k_elements([(7, 7, 7), (7, 7)], 7) == True\nassert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
      "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
      "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
    ]
  },
  {
    "mbpp_id": 27,
    "problem_statement": "Write a python function to remove all digits from a list of strings.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove(nums):\n    # Using list comprehension and filtering out digits using isdigit method\n    result = [word for word in nums if not any(char.isdigit() for char in word)]\n    return result",
    "test_cases": [
      "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
      "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
      "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
    ]
  },
  {
    "mbpp_id": 28,
    "problem_statement": "Write a python function to find binomial co-efficient.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef binomial_Coeff(n, k):\n    # Calculate binomial coefficient using math.comb for efficiency\n    return math.comb(n, k)\n\n# Test cases\nprint(binomial_Coeff(5, 2))  # Expected output: 10\nprint(binomial_Coeff(4, 3))  # Expected output: 4\nprint(binomial_Coeff(3, 2))  # Expected output: 3",
    "test_cases": [
      "assert binomial_Coeff(5,2) == 10",
      "assert binomial_Coeff(4,3) == 4",
      "assert binomial_Coeff(3,2) == 3"
    ]
  },
  {
    "mbpp_id": 29,
    "problem_statement": "Write a python function to find the element occurring odd number of times.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_Odd_Occurrence(arr, n):\n    # Initialize count for each element in the array\n    count = [0] * (n + 1)\n    \n    # Count occurrences of each element\n    for i in range(n):\n        count[arr[i]] += 1\n    \n    # Find the element with an odd occurrence\n    for i in range(1, len(count)):\n        if count[i] % 2 != 0:\n            return i\n    \n    # If no such element is found, raise an error\n    raise ValueError(\"No element occurs odd number of times\")\n\n# Test cases\nprint(get_Odd_Occurrence([1,2,3,1,2,3,1], 7))  # Expected output: 1\nprint(get_Odd_Occurrence([1,2,3,2,3,1,3], 7))  # Expected output: 3\nprint(get_Odd_Occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2], 13))  # Expected output: 5",
    "test_cases": [
      "assert get_Odd_Occurrence([1,2,3,1,2,3,1],7) == 1",
      "assert get_Odd_Occurrence([1,2,3,2,3,1,3],7) == 3",
      "assert get_Odd_Occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
    ]
  },
  {
    "mbpp_id": 30,
    "problem_statement": "Write a python function to count all the substrings starting and ending with same characters.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'count_Substring_With_Equal_Ends' is not defined",
      "Test 2: FAIL - name 'count_Substring_With_Equal_Ends' is not defined",
      "Test 3: FAIL - name 'count_Substring_With_Equal_Ends' is not defined"
    ],
    "generated_code": "def countSubstringsWithEqualEnds(str):\n    count = 0\n    length = len(str)\n    \n    for i in range(length):\n        # Check if current character is equal to first character\n        if str[i] == str[0]:\n            j = i + 1\n            while j < length and str[j] == str[0]:\n                count += 1\n                j += 1\n        \n        # Check if current character is equal to last character\n        if str[i] == str[length - 1]:\n            k = i - 1\n            while k >= 0 and str[k] == str[length - 1]:\n                count += 1\n                k -= 1\n    \n    return count\n\n# Test Cases\nprint(countSubstringsWithEqualEnds(\"abc\"))  # Expected output: 3\nprint(countSubstringsWithEqualEnds(\"abcda\"))  # Expected output: 6\nprint(countSubstringsWithEqualEnds(\"ab\"))  # Expected output: 2",
    "test_cases": [
      "assert count_Substring_With_Equal_Ends(\"abc\") == 3",
      "assert count_Substring_With_Equal_Ends(\"abcda\") == 6",
      "assert count_Substring_With_Equal_Ends(\"ab\") == 2"
    ]
  },
  {
    "mbpp_id": 31,
    "problem_statement": "Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: index out of range"
    ],
    "generated_code": "from collections import Counter\nimport heapq\n\ndef func(nums):\n    # Create heaps for each list\n    h = []\n    for lst in nums:\n        for num in lst:\n            if len(h) < 5000:\n                heapq.heappush(h, num)\n            else:\n                heapq.heappushpop(h, num)\n\n    return [heapq.heappop(h) for _ in range(5000)]\n\n# Example usage\nprint(func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]]))",
    "test_cases": [
      "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
      "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
      "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
    ]
  },
  {
    "mbpp_id": 32,
    "problem_statement": "Write a python function to find the largest prime factor of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def max_Prime_Factors(n):\n    i = 2\n    while n > 1:\n        if n % i == 0:\n            return i\n        i += 1\n\nassert max_Prime_Factors(15) == 5\nassert max_Prime_Factors(6) == 3\nassert max_Prime_Factors(2) == 2",
    "test_cases": [
      "assert max_Prime_Factors(15) == 5",
      "assert max_Prime_Factors(6) == 3",
      "assert max_Prime_Factors(2) == 2"
    ]
  },
  {
    "mbpp_id": 33,
    "problem_statement": "Write a python function to convert a decimal number to binary number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'decimal_To_Binary' is not defined",
      "Test 2: FAIL - name 'decimal_To_Binary' is not defined",
      "Test 3: FAIL - name 'decimal_To_Binary' is not defined"
    ],
    "generated_code": "def decimal_to_binary(decimal_num):\n    return bin(decimal_num)[2:]",
    "test_cases": [
      "assert decimal_To_Binary(10) == 1010",
      "assert decimal_To_Binary(1) == 1",
      "assert decimal_To_Binary(20) == 10100"
    ]
  },
  {
    "mbpp_id": 34,
    "problem_statement": "Write a python function to find the missing number in a sorted array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_missing(arr, n):\n    low = 0\n    high = n - 1\n    \n    # If arr[low] is not equal to 'low', there must be a missing number between them.\n    while low <= high:\n        mid = (low + high) // 2\n        \n        if arr[mid] != mid + 1:\n            break\n        else:\n            low = mid + 1\n            \n    # If low exceeds n-1, then no missing numbers exist in the array.\n    if low == n:\n        return -1\n    \n    # Find the first element which is not present at its index.\n    for i in range(low, n+1):\n        if i != arr[i]:\n            return i\n    \n    return -1",
    "test_cases": [
      "assert find_missing([1,2,3,5],4) == 4",
      "assert find_missing([1,3,4,5],4) == 2",
      "assert find_missing([1,2,3,5,6,7],5) == 4"
    ]
  },
  {
    "mbpp_id": 35,
    "problem_statement": "Write a function to find the n-th rectangular number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_rect_num(n):\n    \"\"\"\n    Calculate the nth rectangular number.\n    \n    Args:\n    n : int - The position in the sequence of rectangular numbers.\n    \n    Returns:\n    int - The n-th rectangular number.\n    \"\"\"\n    return n * (n + 1)\n\n# Test the function with provided data points\nassert find_rect_num(4) == 20\nassert find_rect_num(5) == 30\nassert find_rect_num(6) == 42\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert find_rect_num(4) == 20",
      "assert find_rect_num(5) == 30",
      "assert find_rect_num(6) == 42"
    ]
  },
  {
    "mbpp_id": 36,
    "problem_statement": "Write a python function to find the nth digit in the proper fraction of two given numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: invalid literal for int() with base 10: '-'"
    ],
    "generated_code": "def find_Nth_Digit(a, b, n):\n    def is_proper_fraction(num):\n        for i in range(10):\n            if str(i) * (num // len(str(i)) + 1) == num:\n                return True\n        return False\n    \n    count = 0\n    start_num = a\n    end_num = b\n    while True:\n        count += sum(int(digit) for digit in str(end_num))\n        if start_num < end_num and is_proper_fraction(start_num):\n            break\n        elif not is_proper_fraction(start_num) and is_proper_fraction(end_num):\n            start_num -= 1\n        else:\n            start_num, end_num = start_num - 1, end_num - 1\n    \n    remainder = end_num % 10\n    if n <= count + remainder:\n        return str(start_num)[n - 1]\n    else:\n        return str(end_num)[n - 1 - (count + remainder)]\n\n# Test cases\nprint(find_Nth_Digit(1,2,1))  # Output: 5\nprint(find_Nth_Digit(3,5,1))  # Output: 6\nprint(find_Nth_Digit(5,6,5))  # Output: 3",
    "test_cases": [
      "assert find_Nth_Digit(1,2,1) == 5",
      "assert find_Nth_Digit(3,5,1) == 6",
      "assert find_Nth_Digit(5,6,5) == 3"
    ]
  },
  {
    "mbpp_id": 37,
    "problem_statement": "Write a function to sort a given mixed list of integers and strings.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - '<' not supported between instances of 'str' and 'int'",
      "Test 2: FAIL - '<' not supported between instances of 'str' and 'int'",
      "Test 3: FAIL - '<' not supported between instances of 'str' and 'int'"
    ],
    "generated_code": "def sort_mixed_list(lst):\n    return sorted(lst)",
    "test_cases": [
      "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
      "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
      "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
    ]
  },
  {
    "mbpp_id": 38,
    "problem_statement": "Write a function to find the division of first even and odd number of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - unsupported operand type(s) for /: 'list' and 'list'",
      "Test 2: FAIL - unsupported operand type(s) for /: 'list' and 'list'",
      "Test 3: FAIL - unsupported operand type(s) for /: 'list' and 'list'"
    ],
    "generated_code": "def div_even_odd(nums):\n    return nums[::2] / nums[1::2]",
    "test_cases": [
      "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
      "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
      "assert div_even_odd([1,5,7,9,10])==10"
    ]
  },
  {
    "mbpp_id": 39,
    "problem_statement": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - string index out of range",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from collections import Counter\n\ndef rearange_string(s):\n    char_count = Counter(s)\n    result = \"\"\n    for i in range(0, len(s), 2):\n        if char_count[s[i]] > 0:\n            result += s[i]\n            char_count[s[i]] -= 1\n        if char_count[s[i+1]] > 0 and i < len(s) - 2:\n            result += s[i + 1]\n            char_count[s[i + 1]] -= 1\n    return result",
    "test_cases": [
      "assert rearange_string(\"aab\")==('aba')",
      "assert rearange_string(\"aabb\")==('abab')",
      "assert rearange_string(\"abccdd\")==('cdabcd')"
    ]
  },
  {
    "mbpp_id": 40,
    "problem_statement": "Write a function to find frequency of the elements in a given list of lists using collections module.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import defaultdict\nfrom typing import List\n\ndef freq_element(lst: List[List[int]]) -> dict:\n    freq_dict = defaultdict(int)\n    for sublist in lst:\n        for num in sublist:\n            freq_dict[num] += 1\n    return freq_dict",
    "test_cases": [
      "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
      "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
      "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
    ]
  },
  {
    "mbpp_id": 41,
    "problem_statement": "Write a function to filter even numbers using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def filter_evennumbers(numbers):\n    \"\"\"\n    This function takes a list of integers and returns a new list containing only the even numbers from the input list.\n    \n    :param numbers: List[int] - A list of integers.\n    :return: List[int] - A list containing only the even numbers from the input list.\n    \"\"\"\n    return list(filter(lambda x: x % 2 == 0, numbers))\n\n# Test cases to verify the correctness of the function\nassert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 4, 6, 8, 10], \"Test case 1 failed\"\nassert filter_evennumbers([10,20,45,67,84,93]) == [10,20,84], \"Test case 2 failed\"\nassert filter_evennumbers([5,7,9,8,6,4,3]) == [8,6,4], \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
      "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
      "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
    ]
  },
  {
    "mbpp_id": 42,
    "problem_statement": "Write a python function to find the sum of repeated elements in a given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from collections import Counter\n\ndef find_Sum(arr, n):\n    # Count frequency of each element in the array\n    count = Counter(arr)\n    \n    # Calculate the sum based on the frequencies and counts of elements\n    total_sum = 0\n    for num, freq in count.items():\n        if freq > 1:\n            total_sum += num * ((freq - 1) * freq // 2)\n        else:\n            total_sum += num\n    \n    return total_sum",
    "test_cases": [
      "assert find_Sum([1,2,3,1,1,4,5,6],8) == 3",
      "assert find_Sum([1,2,3,1,1],5) == 3",
      "assert find_Sum([1,1,2],3) == 2"
    ]
  },
  {
    "mbpp_id": 43,
    "problem_statement": "Write a function to find sequences of lowercase letters joined with an underscore using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef text_match(text):\n    # Define the pattern for matching lowercase letters followed by an underscore\n    pattern = '[a-z]+_[a-z]+'\n    \n    # Search for the pattern in the given text\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "test_cases": [
      "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
      "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
      "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
    ]
  },
  {
    "mbpp_id": 44,
    "problem_statement": "Write a function that matches a word at the beginning of a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef text_match_string(text):\n    # Check if the entire string starts with \"python\"\n    pattern = r'^python'\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "test_cases": [
      "assert text_match_string(\" python\")==('Not matched!')",
      "assert text_match_string(\"python\")==('Found a match!')",
      "assert text_match_string(\"  lang\")==('Not matched!')"
    ]
  },
  {
    "mbpp_id": 45,
    "problem_statement": "Write a function to find the gcd of the given array elements.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_gcd(arr):\n    def gcd(x, y): \n        while(y): \n            x, y = y, x % y \n        return x \n    \n    result = arr[0] \n    for i in range(1, len(arr)): \n        result = gcd(result, arr[i])\n        \n    return result\n\n# Test Cases\nprint(get_gcd([2, 4, 6, 8, 16]))  # Output should be 2\nprint(get_gcd([1, 2, 3]))         # Output should be 1\nprint(get_gcd([2, 4, 6, 8]))      # Output should be 2",
    "test_cases": [
      "assert get_gcd([2, 4, 6, 8, 16]) == 2",
      "assert get_gcd([1, 2, 3]) == 1",
      "assert get_gcd([2, 4, 6, 8]) == 2 "
    ]
  },
  {
    "mbpp_id": 46,
    "problem_statement": "Write a python function to determine whether all the numbers are different from each other are not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'test_distinct' is not defined",
      "Test 2: FAIL - name 'test_distinct' is not defined",
      "Test 3: FAIL - name 'test_distinct' is not defined"
    ],
    "generated_code": "def is_distinct(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return False\n        seen.add(num)\n    return True",
    "test_cases": [
      "assert test_distinct([1,5,7,9]) == True",
      "assert test_distinct([2,4,5,5,7,9]) == False",
      "assert test_distinct([1,2,3]) == True"
    ]
  },
  {
    "mbpp_id": 47,
    "problem_statement": "Write a python function to find the last digit when factorial of a divides factorial of b.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def compute_Last_Digit(a, b):\n    # Compute the factorial of both numbers\n    factorial_a = compute_factorial(a)\n    factorial_b = compute_factorial(b)\n\n    # Find the remainder of the factorials divided by 10\n    mod_a = factorial_a % 10\n    mod_b = factorial_b % 10\n\n    # The last digit is the minimum of the two remainders\n    last_digit = min(mod_a, mod_b)\n\n    return last_digit\n\n# Helper function to compute factorial for small values up to 19\ndef compute_factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * compute_factorial(n-1)",
    "test_cases": [
      "assert compute_Last_Digit(2,4) == 2",
      "assert compute_Last_Digit(6,8) == 6",
      "assert compute_Last_Digit(1,2) == 2"
    ]
  },
  {
    "mbpp_id": 48,
    "problem_statement": "Write a python function to set all odd bits of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def odd_bit_set_number(num):\n    \"\"\"\n    This function takes an integer 'num' and returns a new integer with all its odd bits set.\n    \n    Parameters:\n    num (int): The input integer whose odd bits are to be set.\n    \n    Returns:\n    int: An integer where all the odd bits of 'num' have been set.\n    \"\"\"\n    result = 0\n    shift = 0\n    while num > 0:\n        if num % 2 != 0:\n            result |= 1 << shift\n        num >>= 1\n        shift += 1\n    return result\n\n# Test cases\nprint(odd_bit_set_number(10))  # Expected output: 15\nprint(odd_bit_set_number(20))  # Expected output: 21\nprint(odd_bit_set_number(30))  # Expected output: 31",
    "test_cases": [
      "assert odd_bit_set_number(10) == 15",
      "assert odd_bit_set_number(20) == 21",
      "assert odd_bit_set_number(30) == 31"
    ]
  },
  {
    "mbpp_id": 49,
    "problem_statement": "Write a function to extract every first or specified element from a given two-dimensional list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def specified_element(matrix, index):\n    result = []\n    for row in matrix:\n        if index < len(row):\n            result.append(row[index])\n    return result",
    "test_cases": [
      "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
      "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
      "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
    ]
  },
  {
    "mbpp_id": 50,
    "problem_statement": "Write a function to find the list with minimum length using lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n\n# Test cases\nprint(min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])) # Expected output: (1, [0])\nprint(min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])) # Expected output: (1, [1])\nprint(min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])) # Expected output: (2, [1,2])",
    "test_cases": [
      "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
      "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
      "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
    ]
  },
  {
    "mbpp_id": 51,
    "problem_statement": "Write a function to print check if the triangle is equilateral or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_equilateral(a, b, c):\n    # Check if all sides of the triangle are equal\n    return a == b and b == c",
    "test_cases": [
      "assert check_equilateral(6,8,12)==False ",
      "assert check_equilateral(6,6,12)==False",
      "assert check_equilateral(6,6,6)==True"
    ]
  },
  {
    "mbpp_id": 52,
    "problem_statement": "Write a function to caluclate area of a parallelogram.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def parallelogram_area(base, height):\n    return base * height",
    "test_cases": [
      "assert parallelogram_area(10,20)==200",
      "assert parallelogram_area(15,20)==300",
      "assert parallelogram_area(8,9)==72"
    ]
  },
  {
    "mbpp_id": 53,
    "problem_statement": "Write a python function to check whether the first and last characters of a given string are equal or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'check_Eequality' is not defined. Did you mean: 'check_Equality'?"
    ],
    "generated_code": "def check_Equality(string):\n    if len(string) < 2:\n        return \"Invalid Input\"\n    \n    first_char = string[0]\n    last_char = string[-1]\n    \n    if first_char == last_char:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"\n\n# Test Cases\nprint(check_Eequality(\"abcda\"))  # Should print \"Equal\"\nprint(check_Eequality(\"ab\"))     # Should print \"Not Equal\"\nprint(check_Eequality(\"mad\"))    # Should print \"Not Equal\"",
    "test_cases": [
      "assert check_Equality(\"abcda\") == \"Equal\"",
      "assert check_Equality(\"ab\") == \"Not Equal\"",
      "assert check_Equality(\"mad\") == \"Not Equal\""
    ]
  },
  {
    "mbpp_id": 54,
    "problem_statement": "Write a function to sort the given array by using counting sort.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def counting_sort(arr):\n    # Find the maximum value in the array for the range of counts needed\n    max_val = max(arr)\n    \n    # Initialize count array with zeros\n    count_arr = [0] * (max_val + 1)\n    \n    # Populate count array\n    for num in arr:\n        count_arr[num] += 1\n    \n    # Modify count array to hold the actual position of each element\n    for i in range(1, len(count_arr)):\n        count_arr[i] += count_arr[i - 1]\n    \n    # Output array to store sorted elements\n    output_arr = [0] * len(arr)\n    \n    # Build the output array using the count array\n    for num in reversed(arr):\n        output_arr[count_arr[num] - 1] = num\n        count_arr[num] -= 1\n    \n    return output_arr\n\n# Test the function\nprint(counting_sort([1,23,4,5,6,7,8]))  # Should print: [1, 4, 5, 6, 7, 8, 23]\nprint(counting_sort([12, 9, 28, 33, 69, 45]))  # Should print: [9, 12, 28, 33, 45, 69]\nprint(counting_sort([8, 4, 14, 3, 2, 1]))  # Should print: [1, 2, 3, 4, 8, 14]",
    "test_cases": [
      "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
      "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
      "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
    ]
  },
  {
    "mbpp_id": 55,
    "problem_statement": "Write a function to find t-nth term of geometric series.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def tn_gp(t,n,r):\n    return t * r ** (n - 1)",
    "test_cases": [
      "assert tn_gp(1,5,2)==16",
      "assert tn_gp(1,5,4)==256",
      "assert tn_gp(2,6,3)==486"
    ]
  },
  {
    "mbpp_id": 56,
    "problem_statement": "Write a python function to check if a given number is one less than twice its reverse.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'doubled_reversed_number' is not defined. Did you mean: 'double_reversed_number'?"
    ],
    "generated_code": "def check(number):\n    \"\"\"\n    Check if the input number is one less than twice its reverse.\n    \n    Args:\n        number (int): The number to be checked.\n        \n    Returns:\n        bool: True if the number satisfies the condition, otherwise False.\n    \"\"\"\n    original_number = number\n    reversed_number = int(str(original_number)[::-1])\n    double_reversed_number = 2 * reversed_number\n    \n    # Adjust for modulo 10 as reversal might not work on numbers larger than 9 digits\n    while original_number >= 10 and (original_number % 10 == 0 or doubled_reversed_number % 10 != 0):\n        original_number //= 10\n        \n    return number == doubled_reversed_number - 1\n\n# Test cases\nprint(check(70))   # Expected output: False\nprint(check(23))   # Expected output: False\nprint(check(73))   # Expected output: True",
    "test_cases": [
      "assert check(70) == False",
      "assert check(23) == False",
      "assert check(73) == True"
    ]
  },
  {
    "mbpp_id": 57,
    "problem_statement": "Write a python function to find the largest number that can be formed with the given digits.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_Max_Num(digits, length):\n    # Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Join the sorted digits into a single string\n    num_str = ''.join(map(str, sorted_digits))\n    \n    # Return the constructed number as an integer\n    return int(num_str)\n\n# Example usage and test cases\nprint(find_Max_Num([1, 2, 3], 3))  # Expected output: 321\nprint(find_Max_Num([4, 5, 6, 1], 4))  # Expected output: 6541\nprint(find_Max_Num([1, 2, 3, 9], 4))  # Expected output: 9321",
    "test_cases": [
      "assert find_Max_Num([1,2,3],3) == 321",
      "assert find_Max_Num([4,5,6,1],4) == 6541",
      "assert find_Max_Num([1,2,3,9],4) == 9321"
    ]
  },
  {
    "mbpp_id": 58,
    "problem_statement": "Write a python function to check whether the given two integers have opposite sign or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def opposite_Signs(num1, num2):\n    \"\"\"\n    Checks if the product of the two provided integers is negative.\n    \n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n    \n    Returns:\n    bool: True if the product is negative, False otherwise.\n    \"\"\"\n    # Check if the product of the numbers is less than zero\n    return num1 * num2 < 0\n\n# Test cases\nassert opposite_Signs(1,-2) == True\nassert opposite_Signs(3,2) == False\nassert opposite_Signs(-10,-10) == False",
    "test_cases": [
      "assert opposite_Signs(1,-2) == True",
      "assert opposite_Signs(3,2) == False",
      "assert opposite_Signs(-10,-10) == False"
    ]
  },
  {
    "mbpp_id": 59,
    "problem_statement": "Write a function to find the nth octagonal number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_octagonal(n):\n    # The formula to calculate the n-th octagonal number is:\n    # O_n = n(3n - 2)\n    return n * (3 * n - 2)\n\n# Test cases\nprint(is_octagonal(5))  # Expected output: 65\nprint(is_octagonal(10)) # Expected output: 280\nprint(is_octagonal(15)) # Expected output: 645",
    "test_cases": [
      "assert is_octagonal(5) == 65",
      "assert is_octagonal(10) == 280",
      "assert is_octagonal(15) == 645"
    ]
  },
  {
    "mbpp_id": 60,
    "problem_statement": "Write a function to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\n\ndef max_len_sub(arr: List[int], k: int) -> int:\n    \"\"\"\n    Finds the maximum length of a subsequence where each pair of consecutive elements in the subsequence\n    has an absolute difference less than or equal to 'k'.\n    \n    :param arr: List of integers representing the array.\n    :param k: Integer threshold defining the maximum allowable difference between consecutive elements.\n    :return: Length of the longest such subsequence.\n    \"\"\"\n    max_length = 1  # Initialize max_length as 1 since at least one element is a subsequence itself\n    current_length = 1\n    \n    for i in range(1, len(arr)):\n        if abs(arr[i] - arr[i-1]) <= k:\n            current_length += 1  # Increment current_length if condition is met\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1  # Reset current_length when condition is not met\n            \n    return max_length\n\n# Example checks (not exhaustive but sufficient for testing)\nprint(max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8))  # Expected output: 5\nprint(max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7))  # Expected output: 4\nprint(max_len_sub([9, 11, 13, 15, 18], 5))  # Expected output: 1",
    "test_cases": [
      "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
      "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
      "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
    ]
  },
  {
    "mbpp_id": 61,
    "problem_statement": "Write a python function to count number of substrings with the sum of digits equal to their length.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'count_Substrings' is not defined",
      "Test 2: FAIL - name 'count_Substrings' is not defined",
      "Test 3: FAIL - name 'count_Substrings' is not defined"
    ],
    "generated_code": "def count_substrings(s, n):\n    \"\"\"\n    Counts the number of non-empty contiguous substrings where the sum of its digits equals the substring's length.\n    \n    Parameters:\n    s (str): The input string consisting of digits.\n    n (int): The target length for the substrings.\n    \n    Returns:\n    int: The count of substrings meeting the criteria.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        if i > 0 and int(s[i]) == n:\n            continue\n        for j in range(i + 1, len(s) + 1):\n            if sum(int(digit) for digit in s[i:j]) == n:\n                count += 1\n    return count\n\n# Test cases\nprint(count_substrings('112112', 6))  # Expected output: 6\nprint(count_substrings('111', 3))     # Expected output: 6\nprint(count_substrings('1101112', 7)) # Expected output: 12",
    "test_cases": [
      "assert count_Substrings('112112',6) == 6",
      "assert count_Substrings('111',3) == 6",
      "assert count_Substrings('1101112',7) == 12"
    ]
  },
  {
    "mbpp_id": 62,
    "problem_statement": "Write a python function to find smallest number in a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def smallest_num(nums):\n    # Return the minimum value from the given list of numbers.\n    return min(nums)",
    "test_cases": [
      "assert smallest_num([10, 20, 1, 45, 99]) == 1",
      "assert smallest_num([1, 2, 3]) == 1",
      "assert smallest_num([45, 46, 50, 60]) == 45"
    ]
  },
  {
    "mbpp_id": 63,
    "problem_statement": "Write a function to find the maximum difference between available pairs in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_difference(tup_list):\n    max_diff = -float(\"inf\")\n    for i in range(len(tup_list)):\n        for j in range(i + 1, len(tup_list)):\n            diff = tup_list[j][1] - tup_list[i][0]\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff\n\n# Test cases\nprint(max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]))  # Output: 7\nprint(max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]))  # Output: 15\nprint(max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]))  # Output: 23",
    "test_cases": [
      "assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7",
      "assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15",
      "assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"
    ]
  },
  {
    "mbpp_id": 64,
    "problem_statement": "Write a function to sort a list of tuples using lambda.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def subject_marks(subject_list):\n    return sorted(subject_list, key=lambda x: x[1])",
    "test_cases": [
      "assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]",
      "assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])",
      "assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"
    ]
  },
  {
    "mbpp_id": 65,
    "problem_statement": "Write a function of recursion list sum.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - can only concatenate list (not \"int\") to list",
      "Test 2: FAIL - can only concatenate list (not \"int\") to list",
      "Test 3: FAIL - can only concatenate list (not \"int\") to list"
    ],
    "generated_code": "def recursive_list_sum(lst):\n    # Base case: if the list is empty, return 0\n    if not lst:\n        return 0\n    else:\n        # Recursive case: add the first element to the sum of the rest of the list\n        return lst[0] + recursive_list_sum(lst[1:])",
    "test_cases": [
      "assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21",
      "assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106",
      "assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210"
    ]
  },
  {
    "mbpp_id": 66,
    "problem_statement": "Write a python function to count positive numbers in a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def pos_count(numbers):\n    \"\"\"\n    Counts and returns the number of positive integers in the given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of positive integers in the list\n    \"\"\"\n    return sum(1 for x in numbers if x > 0)",
    "test_cases": [
      "assert pos_count([1,-2,3,-4]) == 2",
      "assert pos_count([3,4,5,-1]) == 3",
      "assert pos_count([1,2,3,4]) == 4"
    ]
  },
  {
    "mbpp_id": 67,
    "problem_statement": "Write a function to find the number of ways to partition a set of bell numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def bell_number(n):\n    # Initialize a list with size n+1 and fill it with zeros\n    bell = [0] * (n + 1)\n    \n    # Base case initialization for first two bell numbers\n    bell[0], bell[1] = 1, 1\n    \n    # Fill in the rest of the bell numbers using the recurrence relation\n    for i in range(2, n + 1):\n        j = i - 1\n        while j >= 0:\n            bell[i] += bell[j]\n            j -= 1\n    \n    return bell[n]\n\n# Test cases\nprint(bell_number(2))   # Expected output: 2\nprint(bell_number(10))  # Expected output: 115975\nprint(bell_number(56))  # Expected output: 6775685320645824322581483068371419745979053216268760300",
    "test_cases": [
      "assert bell_number(2)==2",
      "assert bell_number(10)==115975",
      "assert bell_number(56)==6775685320645824322581483068371419745979053216268760300"
    ]
  },
  {
    "mbpp_id": 68,
    "problem_statement": "Write a python function to check whether the given array is monotonic or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_Monotonic(arr):\n    if len(arr) <= 2:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            decreasing = False\n        elif arr[i] < arr[i-1]:\n            increasing = False\n            \n    return increasing or decreasing",
    "test_cases": [
      "assert is_Monotonic([6, 5, 4, 4]) == True",
      "assert is_Monotonic([1, 2, 2, 3]) == True",
      "assert is_Monotonic([1, 3, 2]) == False"
    ]
  },
  {
    "mbpp_id": 69,
    "problem_statement": "Write a function to check whether a list contains the given sublist or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_sublist(lst, sublst):\n    return sublst in lst",
    "test_cases": [
      "assert is_sublist([2,4,3,5,7],[3,7])==False",
      "assert is_sublist([2,4,3,5,7],[4,3])==True",
      "assert is_sublist([2,4,3,5,7],[1,6])==False"
    ]
  },
  {
    "mbpp_id": 70,
    "problem_statement": "Write a function to find whether all the given tuples have equal length or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_equal(tuples_list, expected_length):\n    \"\"\"\n    This function checks if all tuples in the list have the same length as the specified expected length.\n    \n    :param tuples_list: List of tuples to be checked.\n    :param expected_length: The length to compare against each tuple.\n    :return: A string indicating whether all tuples have the same length as the expected one ('All tuples have same length' if true, otherwise 'All tuples do not have same length').\n    \"\"\"\n    # Check if every tuple has the exact expected length\n    for t in tuples_list:\n        if len(t) != expected_length:\n            return 'All tuples do not have same length'\n    return 'All tuples have same length'\n\n# Test cases to verify the correctness of the function\nprint(get_equal([(11, 22, 33), (44, 55, 66)], 3))  # Expected output: \"All tuples have same length\"\nprint(get_equal([(1, 2, 3), (4, 5, 6, 7)], 3))     # Expected output: \"All tuples do not have same length\"\nprint(get_equal([(1, 2), (3, 4)], 2))              # Expected output: \"All tuples have same length\"",
    "test_cases": [
      "assert get_equal([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'",
      "assert get_equal([(1, 2, 3), (4, 5, 6, 7)], 3) == 'All tuples do not have same length'",
      "assert get_equal([(1, 2), (3, 4)], 2) == 'All tuples have same length'"
    ]
  },
  {
    "mbpp_id": 71,
    "problem_statement": "Write a function to sort a list of elements using comb sort.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "TIMEOUT"
    ],
    "generated_code": "def comb_sort(arr):\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        # Update the gap value for a next comb\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True  # If gap is 1, we don't need to sort anymore\n\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n            sorted = False  # might need to do another pass\n\n# Test cases\nprint(comb_sort([5, 15, 37, 25, 79]))  # Expected output: [5, 15, 25, 37, 79]\nprint(comb_sort([41, 32, 15, 19, 22]))  # Expected output: [15, 19, 22, 32, 41]\nprint(comb_sort([99, 15, 13, 47]))      # Expected output: [13, 15, 47, 99]",
    "test_cases": [
      "assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]",
      "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]",
      "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]"
    ]
  },
  {
    "mbpp_id": 72,
    "problem_statement": "Write a python function to check whether the given number can be represented as difference of two squares or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def dif_Square(n):\n    # If n is a perfect square, then it can always be written as difference of two squares.\n    if int(n**0.5)**2 == n:\n        return True\n    \n    # Check if there exist integers m and k such that n = m^2 - k^2\n    # This simplifies to checking if sqrt(n + 1/4) is an integer.\n    import math\n    root = math.sqrt((n+0.25)*4)\n    \n    return int(root)**2 == n*4 - 0.25",
    "test_cases": [
      "assert dif_Square(5) == True",
      "assert dif_Square(10) == False",
      "assert dif_Square(15) == True"
    ]
  },
  {
    "mbpp_id": 73,
    "problem_statement": "Write a function to split the given string with multiple delimiters by using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef multiple_split(string):\n    # Define the regex pattern for splitting by one or more whitespace characters\n    pattern = r'\\s+'\n    \n    # Use re.split() to split the string based on the defined pattern\n    result = re.split(pattern, string)\n    \n    return result",
    "test_cases": [
      "assert multiple_split('Forces of the \\ndarkness*are coming into the play.') == ['Forces of the ', 'darkness', 'are coming into the play.']",
      "assert multiple_split('Mi Box runs on the \\n Latest android*which has google assistance and chromecast.') == ['Mi Box runs on the ', ' Latest android', 'which has google assistance and chromecast.']",
      "assert multiple_split('Certain services\\nare subjected to change*over the seperate subscriptions.') == ['Certain services', 'are subjected to change', 'over the seperate subscriptions.']"
    ]
  },
  {
    "mbpp_id": 74,
    "problem_statement": "Write a function to check whether it follows the sequence given in the patterns array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_samepatterns(patterns, strings):\n    \"\"\"\n    Check if all strings match the pattern in 'patterns' exactly.\n    \n    Args:\n    patterns (list of str): The list containing patterns for matching.\n    strings (list of str): The list containing the strings to be checked against the patterns.\n    \n    Returns:\n    bool: True if every string matches one and only one pattern exactly, False otherwise.\n    \"\"\"\n    # Create an index dictionary where keys are patterns and values are lists of indices where the pattern occurs in each string.\n    pattern_indices = {}\n    for i, pattern in enumerate(patterns):\n        if pattern not in pattern_indices:\n            pattern_indices[pattern] = []\n        pattern_indices[pattern].append(i)\n    \n    matched_indices = set()\n    \n    for s in strings:\n        match_found = False\n        for p in patterns:\n            idxs_to_match = pattern_indices.get(p, [])\n            for idx in idxs_to_match:\n                if idx in matched_indices:\n                    return False  # Found multiple occurrences of same pattern in different strings.\n                else:\n                    matched_indices.add(idx)\n                    if len(idxs_to_match) == 0:\n                        match_found = True\n                        break\n        if not match_found:\n            return False\n    \n    return True",
    "test_cases": [
      "assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True ",
      "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False ",
      "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False "
    ]
  },
  {
    "mbpp_id": 75,
    "problem_statement": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_tuples(lst, divisor):\n    # Filter out tuples where any element is not divisible by the divisor\n    result = [tup for tup in lst if all(num % divisor == 0 for num in tup)]\n    # Return the first matching tuple found or an empty string if none match\n    return str(result[0]) if result else \"\"\n\n# Test cases to verify the correctness of the solution\nassert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '(6, 24, 12)'\nassert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == '(5, 25, 30)'\nassert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == '(8, 16, 4)'\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'",
      "assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == '[(5, 25, 30)]'",
      "assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == '[(8, 16, 4)]'"
    ]
  },
  {
    "mbpp_id": 76,
    "problem_statement": "Write a python function to count the number of squares in a rectangle.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_Squares(length, width):\n    \"\"\"\n    Calculate the total number of squares within a larger square grid.\n    \n    Parameters:\n    length (int): The side length of the outermost square.\n    width (int): The width of the inner square grids.\n    \n    Returns:\n    int: Total number of squares within the given dimensions.\n    \"\"\"\n    # Initialize the counter for squares\n    total_squares = 0\n    \n    # Loop through all possible lengths and widths of inner squares\n    for i in range(length+1):\n        for j in range(width+1):\n            if i < length - j and j < length - i:\n                total_squares += 1\n                \n    return total_squares",
    "test_cases": [
      "assert count_Squares(4,3) == 20",
      "assert count_Squares(2,2) == 5",
      "assert count_Squares(1,1) == 1"
    ]
  },
  {
    "mbpp_id": 77,
    "problem_statement": "Write a python function to find the difference between sum of even and odd digits.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def is_Diff(num):\n    # Initialize sum for even and odd digits\n    even_sum = 0\n    odd_sum = 0\n    \n    # Loop through each digit in the number\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_sum += digit\n        else:\n            odd_sum += digit\n        num //= 10\n    \n    # Return the difference between sums of even and odd digits\n    return even_sum - odd_sum\n\n# Test cases\nprint(is_Diff(12345))  # Output: False\nprint(is_Diff(1212112))  # Output: True\nprint(is_Diff(1212))  # Output: False",
    "test_cases": [
      "assert is_Diff (12345) == False",
      "assert is_Diff(1212112) == True",
      "assert is_Diff(1212) == False"
    ]
  },
  {
    "mbpp_id": 78,
    "problem_statement": "Write a python function to find number of integers with odd number of set bits.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_With_Odd_SetBits(n):\n    count = 0\n    while n:\n        if (n & 1) == 1:\n            count += 1\n        n >>= 1\n    return count",
    "test_cases": [
      "assert count_With_Odd_SetBits(5) == 3",
      "assert count_With_Odd_SetBits(10) == 5",
      "assert count_With_Odd_SetBits(15) == 8"
    ]
  },
  {
    "mbpp_id": 79,
    "problem_statement": "Write a python function to check whether the length of the word is odd or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def word_len(word):\n    # Check if the length of the word is odd\n    if len(word) % 2 != 0:\n        return True\n    else:\n        return False",
    "test_cases": [
      "assert word_len(\"Hadoop\") == False",
      "assert word_len(\"great\") == True",
      "assert word_len(\"structure\") == True"
    ]
  },
  {
    "mbpp_id": 80,
    "problem_statement": "Write a function to find the nth tetrahedral number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) / 6",
    "test_cases": [
      "assert tetrahedral_number(5) == 35.0",
      "assert tetrahedral_number(6) == 56.0",
      "assert tetrahedral_number(7) == 84.0"
    ]
  },
  {
    "mbpp_id": 81,
    "problem_statement": "Write a function to zip the two given tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - tuple index out of range",
      "Test 2: FAIL - tuple index out of range",
      "Test 3: FAIL - tuple index out of range"
    ],
    "generated_code": "def zip_tuples(tup1, tup2):\n    # Initialize an empty list to store the zipped tuples\n    zipped = []\n    # Iterate over each tuple and pair its elements together\n    for i in range(len(tup1)):\n        zipped.append((tup1[i], tup2[i]))\n    return zipped",
    "test_cases": [
      "assert zip_tuples((7, 8, 4, 5, 9, 10),(1, 5, 6) ) == [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]",
      "assert zip_tuples((8, 9, 5, 6, 10, 11),(2, 6, 7) ) == [(8, 2), (9, 6), (5, 7), (6, 2), (10, 6), (11, 7)]",
      "assert zip_tuples((9, 10, 6, 7, 11, 12),(3, 7, 8) ) == [(9, 3), (10, 7), (6, 8), (7, 3), (11, 7), (12, 8)]"
    ]
  },
  {
    "mbpp_id": 82,
    "problem_statement": "Write a function to find the volume of a sphere.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "import math\n\ndef volume_sphere(radius):\n    \"\"\"\n    Calculates the volume of a sphere given its radius.\n    \n    Args:\n        radius (float): The radius of the sphere.\n        \n    Returns:\n        float: The volume of the sphere.\n    \"\"\"\n    return (4/3) * math.pi * radius**3\n\n# Test cases\nassert round(volume_sphere(10), 5) == 4188.8\nassert round(volume_sphere(25), 5) == 65449.8\nassert round(volume_sphere(20), 5) == 33510.3",
    "test_cases": [
      "assert volume_sphere(10)==4188.790204786391",
      "assert volume_sphere(25)==65449.84694978735",
      "assert volume_sphere(20)==33510.32163829113"
    ]
  },
  {
    "mbpp_id": 83,
    "problem_statement": "Write a python function to find the character made by adding all the characters of the given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_Char(s):\n    # Initialize result variable\n    res = \"\"\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Add each character to the result\n        res += char\n    \n    # Return the final result\n    return res",
    "test_cases": [
      "assert get_Char(\"abc\") == \"f\"",
      "assert get_Char(\"gfg\") == \"t\"",
      "assert get_Char(\"ab\") == \"c\""
    ]
  },
  {
    "mbpp_id": 84,
    "problem_statement": "Write a function to find the n-th number in newman conway sequence.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sequence(n):\n    # Initialize an array to store the values of the sequence\n    seq = [0] * (n + 1)\n    if n > 0:\n        seq[1], seq[2] = 1, 2\n        for i in range(3, n + 1):\n            # Calculate the nth number using the recursive relation\n            seq[i] = seq[i - seq[i-1]] + seq[i - seq[i-2]]\n    return seq[n]",
    "test_cases": [
      "assert sequence(10) == 6",
      "assert sequence(2) == 1",
      "assert sequence(3) == 2"
    ]
  },
  {
    "mbpp_id": 85,
    "problem_statement": "Write a function to find the surface area of a sphere.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n    \n    Parameters:\n    - radius: The radius of the sphere\n    \n    Returns:\n    - float: The calculated surface area of the sphere\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n\n# Test cases\nprint(surfacearea_sphere(10))  # Expected output: 1256.6370614359173\nprint(surfacearea_sphere(15))  # Expected output: 2827.4333882308138\nprint(surfacearea_sphere(20))  # Expected output: 5026.548245743669",
    "test_cases": [
      "assert surfacearea_sphere(10)==1256.6370614359173",
      "assert surfacearea_sphere(15)==2827.4333882308138",
      "assert surfacearea_sphere(20)==5026.548245743669"
    ]
  },
  {
    "mbpp_id": 86,
    "problem_statement": "Write a function to find nth centered hexagonal number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def centered_hexagonal_number(n):\n    # The formula for calculating the nth centered hexagonal number is:\n    # n * (2n^2 - n + 1)\n    result = n * (2*n**2 - n + 1)\n    return result",
    "test_cases": [
      "assert centered_hexagonal_number(10) == 271",
      "assert centered_hexagonal_number(2) == 7",
      "assert centered_hexagonal_number(9) == 217"
    ]
  },
  {
    "mbpp_id": 87,
    "problem_statement": "Write a function to merge three dictionaries into a single expression.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}",
    "test_cases": [
      "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}",
      "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}",
      "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"
    ]
  },
  {
    "mbpp_id": 88,
    "problem_statement": "Write a function to get the frequency of the elements in a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def freq_count(lst):\n    # Create an empty dictionary to store frequencies\n    count_dict = {}\n    \n    # Iterate through each element in the list\n    for elem in lst:\n        if elem in count_dict:\n            # If the element is already in the dictionary, increment its count\n            count_dict[elem] += 1\n        else:\n            # Otherwise, add the element to the dictionary with a count of 1\n            count_dict[elem] = 1\n    \n    return count_dict",
    "test_cases": [
      "assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1}) ",
      "assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3}) ",
      "assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2}) "
    ]
  },
  {
    "mbpp_id": 89,
    "problem_statement": "Write a function to find the closest smaller number than n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - invalid literal for int() with base 10: ''",
      "Test 2: FAIL - invalid literal for int() with base 10: ''",
      "Test 3: FAIL - invalid literal for int() with base 10: ''"
    ],
    "generated_code": "def closest_num(n):\n    # Convert the integer to a string for easier manipulation of digits\n    str_n = str(n)\n    \n    # Initialize variables to store the previous digit and its index\n    prev_digit = ''\n    prev_index = -1\n    \n    # Loop through each character in the string representation of n from right to left\n    for i in range(len(str_n) - 1, -1, -1):\n        if int(prev_digit) < int(str_n[i]):\n            # If the current digit is greater than the next digit, set it as the previous digit\n            prev_digit = str_n[i]\n            prev_index = len(str_n) - 1 - i\n        \n        # If we found a smaller digit, break out of the loop\n        if prev_index > 0:\n            break\n    \n    # Return the closest smaller number by converting the string back to an integer\n    return int(''.join([str_n[:prev_index], '9', str_n[prev_index+1:]]))",
    "test_cases": [
      "assert closest_num(11) == 10",
      "assert closest_num(7) == 6",
      "assert closest_num(12) == 11"
    ]
  },
  {
    "mbpp_id": 90,
    "problem_statement": "Write a python function to find the length of the longest word.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def len_log(words):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update the maximum length if the current word is longer than the previous maximum\n        max_length = max(max_length, len(word))\n    \n    # Return the maximum length found\n    return max_length",
    "test_cases": [
      "assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7",
      "assert len_log([\"a\",\"ab\",\"abc\"]) == 3",
      "assert len_log([\"small\",\"big\",\"tall\"]) == 5"
    ]
  },
  {
    "mbpp_id": 91,
    "problem_statement": "Write a function to check if a substring is present in a given list of string values.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_substring(lst, sub_str):\n    return any(sub_str in item for item in lst)",
    "test_cases": [
      "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True",
      "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False",
      "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True"
    ]
  },
  {
    "mbpp_id": 92,
    "problem_statement": "Write a function to check whether the given number is undulating or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_undulating(num_str):\n    \"\"\"\n    Check if the given number represented as a string is an undulating number.\n    \n    An undulating number is defined as a number in which each pair of adjacent digits\n    differs by at least one. The function returns True if the input string represents \n    an undulating number, otherwise it returns False.\n    \n    :param num_str: A string representation of a positive integer\n    :return: Boolean value indicating whether the number is undulating\n    \"\"\"\n    for i in range(1, len(num_str) - 1):\n        if abs(int(num_str[i]) - int(num_str[i + 1])) < 1:\n            return False\n    return True\n\n# Test cases\nprint(is_undulating(\"1212121\"))  # Expected output: True\nprint(is_undulating(\"1991\"))     # Expected output: False\nprint(is_undulating(\"121\"))      # Expected output: True",
    "test_cases": [
      "assert is_undulating(\"1212121\") == True",
      "assert is_undulating(\"1991\") == False",
      "assert is_undulating(\"121\") == True"
    ]
  },
  {
    "mbpp_id": 93,
    "problem_statement": "Write a function to calculate the value of 'a' to the power 'b'.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def power(a, b):\n    result = 1\n    for _ in range(b):\n        result *= a\n    return result",
    "test_cases": [
      "assert power(3,4) == 81",
      "assert power(2,3) == 8",
      "assert power(5,5) == 3125"
    ]
  },
  {
    "mbpp_id": 94,
    "problem_statement": "Write a function to extract the index minimum value record from the given tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest first element and return its second element.\n    min_tuple = min(tuples_list, key=lambda x: x[0])\n    return min_tuple[1]",
    "test_cases": [
      "assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'",
      "assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'",
      "assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'"
    ]
  },
  {
    "mbpp_id": 95,
    "problem_statement": "Write a python function to find the minimum length of sublist.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def Find_Min_Length(lst):\n    # Initialize min_length with maximum possible integer value\n    min_length = float('inf')\n    \n    for sublist in lst:\n        # Calculate the length of each sublist and update min_length if necessary\n        current_length = len(sublist)\n        if current_length < min_length:\n            min_length = current_length\n    \n    return min_length",
    "test_cases": [
      "assert Find_Min_Length([[1],[1,2]]) == 1",
      "assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2",
      "assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3"
    ]
  },
  {
    "mbpp_id": 96,
    "problem_statement": "Write a python function to find the number of divisors of a given integer.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count",
    "test_cases": [
      "assert divisor(15) == 4 ",
      "assert divisor(12) == 6",
      "assert divisor(9) == 3"
    ]
  },
  {
    "mbpp_id": 97,
    "problem_statement": "Write a function to find frequency count of list of lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def frequency_lists(lst):\n    result = {}\n    for sublist in lst:\n        for item in set(sublist):  # Convert sublist to a set and then back to list to remove duplicates\n            if item in result:\n                result[item] += 1\n            else:\n                result[item] = 1\n    return result",
    "test_cases": [
      "assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}",
      "assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}",
      "assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}"
    ]
  },
  {
    "mbpp_id": 98,
    "problem_statement": "Write a function to multiply all the numbers in a list and divide with the length of the list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def multiply_num(numbers):\n    # Multiply all elements in the list\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    # Divide the product by the length of the list\n    result = product / len(numbers)\n    \n    return result",
    "test_cases": [
      "assert multiply_num((8, 2, 3, -1, 7))==-67.2",
      "assert multiply_num((-10,-20,-30))==-2000.0",
      "assert multiply_num((19,15,18))==1710.0"
    ]
  },
  {
    "mbpp_id": 99,
    "problem_statement": "Write a function to convert the given decimal number to its binary equivalent.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def decimal_to_binary(decimal_number):\n    \"\"\"\n    Convert a given decimal number to its binary equivalent.\n    \n    Parameters:\n    - decimal_number (int): The decimal number to be converted\n    \n    Returns:\n    - str: The binary representation of the input decimal number\n    \"\"\"\n    return bin(decimal_number)[2:] if decimal_number else \"0\"\n\n# Test Cases\nprint(decimal_to_binary(8))  # Expected output: '1000'\nprint(decimal_to_binary(18)) # Expected output: '10010'\nprint(decimal_to_binary(7))  # Expected output: '111'",
    "test_cases": [
      "assert decimal_to_binary(8) == '1000'",
      "assert decimal_to_binary(18) == '10010'",
      "assert decimal_to_binary(7) == '111' "
    ]
  },
  {
    "mbpp_id": 100,
    "problem_statement": "Write a function to find the next smallest palindrome of a specified number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "TIMEOUT"
    ],
    "generated_code": "def next_smallest_palindrome(n):\n    \"\"\"\n    This function takes an integer n and returns the smallest palindrome larger than n.\n    \n    :param n: Integer, the input number to check for the next smallest palindrome.\n    :return: Integer, the next smallest palindrome greater than n.\n    \"\"\"\n    while True:\n        if str(int(str(n) + str(n)[::-1])) == str(n):\n            return int(str(n) + str(n)[::-1])\n        n += 1",
    "test_cases": [
      "assert next_smallest_palindrome(99)==101",
      "assert next_smallest_palindrome(1221)==1331",
      "assert next_smallest_palindrome(120)==121"
    ]
  },
  {
    "mbpp_id": 101,
    "problem_statement": "Write a function to find the kth element in the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def kth_element(arr, n, k):\n    # Sort the array in ascending order\n    arr.sort()\n    # Return the kth element from the sorted array\n    return arr[k-1]\n\n# Example usage:\nprint(kth_element([12,3,5,7,19], 5, 2))  # Output: 3\nprint(kth_element([17,24,8,23], 4, 3))   # Output: 8\nprint(kth_element([16,21,25,36,4], 5, 4)) # Output: 36",
    "test_cases": [
      "assert kth_element([12,3,5,7,19], 5, 2) == 3",
      "assert kth_element([17,24,8,23], 4, 3) == 8",
      "assert kth_element([16,21,25,36,4], 5, 4) == 36"
    ]
  },
  {
    "mbpp_id": 102,
    "problem_statement": "Write a function to convert snake case string to camel case string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def snake_to_camel(snake_str):\n    # Split the string at underscores and capitalize each word except for the first one\n    words = snake_str.split('_')\n    # Join the words together with no space in between\n    return ''.join(words)\n\n# Example usage:\nprint(snake_to_camel('python_program'))  # Output: 'PythonProgram'\nprint(snake_to_camel('python_language'))  # Output: 'PythonLanguage'\nprint(snake_to_camel('programming_language'))  # Output: 'ProgrammingLanguage'",
    "test_cases": [
      "assert snake_to_camel('python_program')=='PythonProgram'",
      "assert snake_to_camel('python_language')==('PythonLanguage')",
      "assert snake_to_camel('programming_language')==('ProgrammingLanguage')"
    ]
  },
  {
    "mbpp_id": 103,
    "problem_statement": "Write a function to find eulerian number a(n, m).",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def eulerian_num(n, m):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    \n    # Base case for Euler's partition formula\n    if n == 0 and m > 0:\n        return 0\n    \n    # Recursive call to compute the Euler number\n    return (m * (eulerian_num(n - 1, m)) + pow(m, n)) // (n + 1)",
    "test_cases": [
      "assert eulerian_num(3, 1) == 4",
      "assert eulerian_num(4, 1) == 11",
      "assert eulerian_num(5, 3) == 26"
    ]
  },
  {
    "mbpp_id": 104,
    "problem_statement": "Write a function to sort each sublist of strings in a given list of lists using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sort_sublists(lst_of_lists):\n    return [sorted(sublist) for sublist in lst_of_lists]\n\n# Test cases\nprint(sort_sublists(([[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]])))\nprint(sort_sublists(([[\" red \", \"green\" ], [\"blue \", \" black\" ], [\" orange\", \"brown\"]])))\nprint(sort_sublists(([[\"zilver\", \"gold\"], [\"magnesium\", \"aluminium\"], [\"steel\", \"bronze\"]])))",
    "test_cases": [
      "assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]",
      "assert sort_sublists(([\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]",
      "assert sort_sublists(([\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]"
    ]
  },
  {
    "mbpp_id": 105,
    "problem_statement": "Write a python function to count true booleans in the given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count(booleans):\n    # Initialize counter for True values\n    true_count = 0\n    \n    # Iterate through each boolean value in the list\n    for bool_val in booleans:\n        if bool_val:\n            true_count += 1\n            \n    return true_count\n\n# Test case 1\nassert count([True, False, True]) == 2\n# Test case 2\nassert count([False, False]) == 0\n# Test case 3\nassert count([True, True, True]) == 3\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert count([True,False,True]) == 2",
      "assert count([False,False]) == 0",
      "assert count([True,True,True]) == 3"
    ]
  },
  {
    "mbpp_id": 106,
    "problem_statement": "Write a function to add the given list to the given tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - can only concatenate list (not \"tuple\") to list",
      "Test 2: FAIL - can only concatenate list (not \"tuple\") to list",
      "Test 3: FAIL - can only concatenate list (not \"tuple\") to list"
    ],
    "generated_code": "def add_lists(list_input, tuple_input):\n    # Concatenate the lists and tuples into one sorted tuple\n    result_tuple = tuple(sorted(list_input + tuple_input))\n    return result_tuple",
    "test_cases": [
      "assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)",
      "assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)",
      "assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)"
    ]
  },
  {
    "mbpp_id": 107,
    "problem_statement": "Write a python function to count hexadecimal numbers for a given range.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - maximum recursion depth exceeded in comparison",
      "Test 2: FAIL - maximum recursion depth exceeded in comparison",
      "Test 3: FAIL - maximum recursion depth exceeded in comparison"
    ],
    "generated_code": "def count_Hexadecimal(start, end):\n    hex_digits = '0123456789abcdef'\n    \n    def helper(n, current_count=0):\n        if n == 0:\n            return current_count\n        next_count = 0\n        for digit in hex_digits:\n            new_n = int(str(digit), 16)\n            if start <= new_n <= end:\n                next_count += helper(n // 16 + 1, current_count + 1)\n        return next_count\n    \n    result = helper(end - start + 1)\n    return result % 10000",
    "test_cases": [
      "assert count_Hexadecimal(10,15) == 6",
      "assert count_Hexadecimal(2,4) == 0",
      "assert count_Hexadecimal(15,16) == 1"
    ]
  },
  {
    "mbpp_id": 108,
    "problem_statement": "Write a function to merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - SyntaxError: invalid syntax"
    ],
    "generated_code": "```python\nimport heapq\n\ndef merge_sorted_list(sorted_lists):\n    \"\"\"\n    Merges multiple sorted lists into a single sorted list.\n    \n    Parameters:\n    - sorted_lists: A list of sorted lists\n    \n    Returns:\n    A generator yielding elements from each sorted list in sorted order.\n    \"\"\"\n    for lst in sorted_lists:\n        if not lst: continue\n        yield from heapq.merge([], *sorted_lists)\n\n# Check function with provided data points\ndef check_solution():\n    assert list(merge_sorted_list([[25, 24, 15, 4, 5, 29, 110],\n                                   [19, 20, 11, 56, 25, 233, 154],\n                                   [24, 26, 54, 48]])) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 48, 54, 56, 110, 154, 233]\n    assert list(merge_sorted_list([[1, 3, 5, 6, 8, 9],\n                                  [2, 5, 7, 11],\n                                  [1, 4, 7, 8, 12]])) == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\n    assert list(merge_sorted_list([[18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],\n                                   [25, 35, 22, 85, 14, 65, 75, 25, 58],\n                                   [12, 74, 9, 50, 61, 41]])) == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22,",
    "test_cases": [
      "assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]",
      "assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]",
      "assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]"
    ]
  },
  {
    "mbpp_id": 109,
    "problem_statement": "Write a python function to find the count of rotations of a binary string with odd value.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def odd_Equivalent(s, k):\n    # Convert the binary string to an integer for easier manipulation\n    num = int(s, 2)\n    \n    # Perform bitwise right shift operation k times\n    for _ in range(k):\n        num >>= 1\n    \n    # Check if the result is odd\n    return bool(num & 1)\n\n# Test cases\nprint(odd_Equivalent(\"011001\", 6))  # Expected output: True (returns 3 as it's equivalent after rotation)\nprint(odd_Equivalent(\"11011\", 5))   # Expected output: False (does not meet requirement after rotation)\nprint(odd_Equivalent(\"1010\", 4))    # Expected output: True (returns 2 as it's equivalent after rotation)",
    "test_cases": [
      "assert odd_Equivalent(\"011001\",6) == 3",
      "assert odd_Equivalent(\"11011\",5) == 4",
      "assert odd_Equivalent(\"1010\",4) == 2"
    ]
  },
  {
    "mbpp_id": 110,
    "problem_statement": "Write a function to extract the ranges that are missing from the given list with the given start range and end range values.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def extract_missing(list_of_ranges, start_range, end_range):\n    result = []\n    for i in range(start_range, end_range + 1):\n        if i not in [r[0] for r in list_of_ranges]:\n            result.append((i, i))\n    return result",
    "test_cases": [
      "assert extract_missing([(6, 9), (15, 34), (48, 70)], 2, 100) == [(2, 6), (9, 100), (9, 15), (34, 100), (34, 48), (70, 100)]",
      "assert extract_missing([(7, 2), (15, 19), (38, 50)], 5, 60) == [(5, 7), (2, 60), (2, 15), (19, 60), (19, 38), (50, 60)]",
      "assert extract_missing([(7, 2), (15, 19), (38, 50)], 1, 52) == [(1, 7), (2, 52), (2, 15), (19, 52), (19, 38), (50, 52)]"
    ]
  },
  {
    "mbpp_id": 111,
    "problem_statement": "Write a function to find common elements in given nested lists. * list item * list item * list item * list item",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def common_in_nested_lists(lists):\n    # Flatten the list of lists into a single list and remove duplicates\n    flat_list = list(set([item for sublist in lists for item in sublist]))\n    # Find the intersection between all sublists using set comprehension\n    return [num for num in flat_list if all(num in sublist for sublist in lists)]",
    "test_cases": [
      "assert common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]])==[18, 12]",
      "assert common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]])==[5,23]",
      "assert common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]])==[4]"
    ]
  },
  {
    "mbpp_id": 112,
    "problem_statement": "Write a python function to find the perimeter of a cylinder.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'perimeter' is not defined",
      "Test 2: FAIL - name 'perimeter' is not defined",
      "Test 3: FAIL - name 'perimeter' is not defined"
    ],
    "generated_code": "import math\n\ndef calculate_cylinder_perimeter(radius, height):\n    \"\"\"\n    Calculate and return the circumference of a cylindrical surface.\n    \n    Parameters:\n    radius (float): The radius of the base circle.\n    height (float): The height of the cylinder.\n    \n    Returns:\n    float: The total length of the cylinder's surface.\n    \"\"\"\n    # Calculating the circumference of the base circle\n    base_circle_circumference = 2 * math.pi * radius\n    \n    # Total perimeter of the cylinder's surface\n    total_perimeter = base_circle_circumference + 2 * math.pi * height\n    \n    return total_perimeter",
    "test_cases": [
      "assert perimeter(2,4) == 12",
      "assert perimeter(1,2) == 6",
      "assert perimeter(3,1) == 8"
    ]
  },
  {
    "mbpp_id": 113,
    "problem_statement": "Write a function to check if a string represents an integer or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False",
    "test_cases": [
      "assert check_integer(\"python\")==False",
      "assert check_integer(\"1\")==True",
      "assert check_integer(\"12345\")==True"
    ]
  },
  {
    "mbpp_id": 114,
    "problem_statement": "Write a function to assign frequency to each tuple in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def assign_freq(lst):\n    from collections import Counter\n    freq_map = Counter()\n    for tup in lst:\n        freq_map[tup] += 1\n    result = []\n    for i, (tup, _) in enumerate(freq_map.most_common()):\n        if isinstance(tup, tuple) and len(tup) > 1:\n            freq = tup.count(i)\n            result.append((tup + (freq,)))\n        else:\n            result.append((tup,))\n    return result",
    "test_cases": [
      "assert assign_freq([(6, 5, 8), (2, 7), (6, 5, 8), (6, 5, 8), (9, ), (2, 7)] ) == '[(6, 5, 8, 3), (2, 7, 2), (9, 1)]'",
      "assert assign_freq([(4, 2, 4), (7, 1), (4, 8), (4, 2, 4), (9, 2), (7, 1)] ) == '[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]'",
      "assert assign_freq([(11, 13, 10), (17, 21), (4, 2, 3), (17, 21), (9, 2), (4, 2, 3)] ) == '[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]'"
    ]
  },
  {
    "mbpp_id": 115,
    "problem_statement": "Write a function to check whether all dictionaries in a list are empty or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'empty_dit' is not defined",
      "Test 2: FAIL - name 'empty_dit' is not defined",
      "Test 3: FAIL - name 'empty_dit' is not defined"
    ],
    "generated_code": "def empty_dictionaries(dicts_list):\n    return all(not d for d in dicts_list)",
    "test_cases": [
      "assert empty_dit([{},{},{}])==True",
      "assert empty_dit([{1,2},{},{}])==False",
      "assert empty_dit({})==True"
    ]
  },
  {
    "mbpp_id": 116,
    "problem_statement": "Write a function to convert a given tuple of positive integers into an integer.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def tuple_to_int(tup):\n    # Convert each element in the tuple to string and join them together with no separator\n    return int(''.join(map(str, tup)))\n\n# Test cases\nprint(tuple_to_int((1,2,3)))  # Expected output: 123\nprint(tuple_to_int((4,5,6)))  # Expected output: 456\nprint(tuple_to_int((5,6,7)))  # Expected output: 567",
    "test_cases": [
      "assert tuple_to_int((1,2,3))==123",
      "assert tuple_to_int((4,5,6))==456",
      "assert tuple_to_int((5,6,7))==567"
    ]
  },
  {
    "mbpp_id": 117,
    "problem_statement": "Write a function to convert all possible convertible elements in the list to float.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def list_to_float(lst):\n    return [(float(x[0]), y) if isinstance(y, str) else (x, float(y)) for x, y in lst]",
    "test_cases": [
      "assert list_to_float( [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] ) == '[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]'",
      "assert list_to_float( [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] ) == '[(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]'",
      "assert list_to_float( [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] ) == '[(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]'"
    ]
  },
  {
    "mbpp_id": 118,
    "problem_statement": "[link text](https:// [link text](https:// [link text](https://)))write a function to convert a string to a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def string_to_list(s):\n    return s.split()",
    "test_cases": [
      "assert string_to_list(\"python programming\")==['python','programming']",
      "assert string_to_list(\"lists tuples strings\")==['lists','tuples','strings']",
      "assert string_to_list(\"write a program\")==['write','a','program']"
    ]
  },
  {
    "mbpp_id": 119,
    "problem_statement": "Write a python function to find the element that appears only once in a sorted array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - list index out of range"
    ],
    "generated_code": "def search(arr, n):\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            right = mid\n            \n    return arr[left]",
    "test_cases": [
      "assert search([1,1,2,2,3],5) == 3",
      "assert search([1,1,3,3,4,4,5,5,7,7,8],11) == 8",
      "assert search([1,2,2,3,3,4,4],7) == 1"
    ]
  },
  {
    "mbpp_id": 120,
    "problem_statement": "Write a function to find the maximum product from the pairs of tuples within a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: too many values to unpack (expected 2)"
    ],
    "generated_code": "def max_product_tuple(lst):\n    # Sort each tuple in descending order\n    sorted_list = [tuple(sorted(tup, reverse=True)) for tup in lst]\n    \n    # Calculate and return the maximum product of pairs\n    return max(tuple(a * b for a, b in zip(*sorted_list))) if sorted_list else 0\n\n# Test cases\nprint(max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)])) # Expected output: 36\nprint(max_product_tuple([(10,20), (15,2), (5,10)])) # Expected output: 200\nprint(max_product_tuple([(11,44), (10,15), (20,5), (12, 9)])) # Expected output: 484",
    "test_cases": [
      "assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36",
      "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200",
      "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484"
    ]
  },
  {
    "mbpp_id": 121,
    "problem_statement": "Write a function to find the triplet with sum of the given array",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - check_triplet() takes 3 positional arguments but 4 were given",
      "Test 2: FAIL - check_triplet() takes 3 positional arguments but 4 were given",
      "Test 3: FAIL - check_triplet() takes 3 positional arguments but 4 were given"
    ],
    "generated_code": "def check_triplet(arr, target_sum, sum_value):\n    n = len(arr)\n    arr.sort()\n    \n    for i in range(n-2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            \n            if current_sum == sum_value:\n                return True\n            elif current_sum < sum_value:\n                left += 1\n            else:\n                right -= 1\n                \n    return False\n\n# Test cases\nprint(check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6)) # Expected output: True\nprint(check_triplet([1, 4, 5, 6, 7, 8, 5, 9], 8, 6)) # Expected output: False\nprint(check_triplet([10, 4, 2, 3, 5], 5, 15)) # Expected output: True",
    "test_cases": [
      "assert check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6, 0) == True",
      "assert check_triplet([1, 4, 5, 6, 7, 8, 5, 9], 8, 6, 0) == False",
      "assert check_triplet([10, 4, 2, 3, 5], 5, 15, 0) == True"
    ]
  },
  {
    "mbpp_id": 122,
    "problem_statement": "Write a function to find n’th smart number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "TIMEOUT"
    ],
    "generated_code": "def smartNumber(n):\n    result = 0\n    current_number = 0\n    while True:\n        next_number = current_number + 2 * (current_number // 3)\n        if len(str(next_number)) == n and str(current_number)[-n:] == str(next_number)[:len(str(current_number))]:\n            result = next_number\n            break\n        else:\n            current_number += 1\n    return result",
    "test_cases": [
      "assert smartNumber(1) == 30",
      "assert smartNumber(50) == 273",
      "assert smartNumber(1000) == 2664"
    ]
  },
  {
    "mbpp_id": 123,
    "problem_statement": "Write a function to sum all amicable numbers from 1 to a specified number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def amicable_numbers_sum(n):\n    def get_divisors(num):\n        divisors = set()\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                divisors.add(num // i)\n        return divisors\n    \n    def is_amicable_pair(a, b):\n        divisor_sum_a = sum(get_divisors(a))\n        divisor_sum_b = sum(get_divisors(b))\n        return divisor_sum_a == b and divisor_sum_b == a\n    \n    total_sum = 0\n    for i in range(1, n+1):\n        pair = get_divisors(i)\n        j = next(iter(pair), None)\n        if i != j and is_amicable_pair(i, j):\n            total_sum += i + j\n            \n    return total_sum",
    "test_cases": [
      "assert amicable_numbers_sum(999)==504",
      "assert amicable_numbers_sum(9999)==31626",
      "assert amicable_numbers_sum(99)==0"
    ]
  },
  {
    "mbpp_id": 124,
    "problem_statement": "Write a function to get the angle of a complex number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import cmath\n\ndef angle_complex(a, b):\n    \"\"\"\n    Calculate the phase angle in radians of a complex number given as a pair of its real and imaginary parts.\n    \n    Parameters:\n    a (float): The real part of the complex number.\n    b (float): The imaginary part of the complex number.\n    \n    Returns:\n    float: The phase angle in radians.\n    \"\"\"\n    return cmath.phase(complex(a, b))\n\n# Test cases\nprint(angle_complex(0,1j)) # Expected output: 1.5707963267948966\nprint(angle_complex(2,1j)) # Expected output: 0.4636476090008061\nprint(angle_complex(0,2j)) # Expected output: 1.5707963267948966",
    "test_cases": [
      "assert angle_complex(0,1j)==1.5707963267948966 ",
      "assert angle_complex(2,1j)==0.4636476090008061",
      "assert angle_complex(0,2j)==1.5707963267948966"
    ]
  },
  {
    "mbpp_id": 125,
    "problem_statement": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_length(s, k):\n    # Count initial zeros and ones\n    zero_count = s.count('0')\n    one_count = len(s) - zero_count\n    \n    max_diff = abs(zero_count - one_count)\n    \n    for i in range(k-1):\n        s = s[1:] + '1' if s[i] == '0' else s[:-1] + '0'\n        \n        zero_count = s.count('0')\n        one_count = len(s) - zero_count\n        \n        max_diff = max(max_diff, abs(zero_count - one_count))\n    \n    return max_diff\n\n# Example usage:\nprint(find_length(\"11000010001\", 11))  # Output: 6\nprint(find_length(\"10111\", 5))         # Output: 1\nprint(find_length(\"11011101100101\", 14)) # Output: 2",
    "test_cases": [
      "assert find_length(\"11000010001\", 11) == 6",
      "assert find_length(\"10111\", 5) == 1",
      "assert find_length(\"11011101100101\", 14) == 2 "
    ]
  },
  {
    "mbpp_id": 126,
    "problem_statement": "Write a python function to find the sum of common divisors of two given numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - 'int' object is not iterable",
      "Test 2: FAIL - 'int' object is not iterable",
      "Test 3: FAIL - 'int' object is not iterable"
    ],
    "generated_code": "import math\n\ndef sum_of_common_divisors(num1, num2):\n    # Find the minimum of the two numbers to optimize the loop limit\n    max_val = min(num1, num2)\n    \n    # Initialize the sum of common divisors\n    sum_divisors = 0\n    \n    # Iterate from 1 to max_val to find all divisors of both numbers\n    for i in range(1, max_val + 1):\n        if num1 % i == 0 and num2 % i == 0:\n            sum_divisors += i\n            \n    return sum_divisors\n\n# Test the function with provided data points\nassert sum_of_common_divisors(10, 15) == 6\nassert sum_of_common_divisors(100, 150) == 93\nassert sum_of_common_divisors(4, 6) == 3\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert sum(10,15) == 6",
      "assert sum(100,150) == 93",
      "assert sum(4,6) == 3"
    ]
  },
  {
    "mbpp_id": 127,
    "problem_statement": "Write a function to multiply two integers without using the * operator in python.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def multiply_int(x, y):\n    result = 0\n    while y > 0:\n        if y % 2 == 1:\n            result += x\n        x += x\n        y //= 2\n    return result",
    "test_cases": [
      "assert multiply_int(10,20)==200",
      "assert multiply_int(5,10)==50",
      "assert multiply_int(4,8)==32"
    ]
  },
  {
    "mbpp_id": 128,
    "problem_statement": "Write a function to shortlist words that are longer than n from a given list of words.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def long_words(n, lst):\n    return [word for word in lst if len(word) > n]",
    "test_cases": [
      "assert long_words(3,\"python is a programming language\")==['python','programming','language']",
      "assert long_words(2,\"writing a program\")==['writing','program']",
      "assert long_words(5,\"sorting list\")==['sorting']"
    ]
  },
  {
    "mbpp_id": 129,
    "problem_statement": "Write a function to calculate magic square.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'magic_square_test' is not defined",
      "Test 2: FAIL - name 'magic_square_test' is not defined",
      "Test 3: FAIL - name 'magic_square_test' is not defined"
    ],
    "generated_code": "def is_magic_square(square):\n    \"\"\"\n    Check if the given square matrix is a magic square.\n    \n    A magic square is an n x n matrix of distinct positive integers such that the sums of the integers\n    in each row, each column, and both main diagonals are all equal.\n    \n    Parameters:\n    - square (list): The input square matrix.\n    \n    Returns:\n    - bool: True if the input is a magic square, False otherwise.\n    \"\"\"\n    # Calculate the sum of the first row to use as the target sum for rows/columns/diagonals\n    total_sum = sum(sum(row) for row in square)\n    \n    # Create sets from rows and columns to find duplicates\n    cols_set = set([sum(col) for col in zip(*square)])\n    \n    # Create sets from diagonals to find duplicates\n    diag1 = sum(square[i][i] for i in range(len(square)))\n    diag2 = sum(square[i][-i-1] for i in range(len(square)))\n    \n    # Verify conditions for a magic square\n    return len(set(square)) == len(square) and total_sum % len(square) == 0 \\\n           and total_sum // len(square) == sum(cols_set) and total_sum // len(square) == diag1 == diag2\n\n# Test cases provided at the end of the snippet",
    "test_cases": [
      "assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True",
      "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True",
      "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False"
    ]
  },
  {
    "mbpp_id": 130,
    "problem_statement": "Write a function to find the item with maximum frequency in a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import Counter\n\ndef max_occurrences(lst):\n    \"\"\"\n    Finds and returns the item with the highest occurrence count from a given list.\n    \n    Args:\n    lst (list): The input list of items.\n    \n    Returns:\n    tuple: A tuple containing the item with the maximum occurrences and its count.\n    \"\"\"\n    return Counter(lst).most_common(1)[0]\n\n# Test cases\nassert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2]) == (2, 5)\nassert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18]) == (8, 2)\nassert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10]) == (20, 3)\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==(2, 5)",
      "assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18])==(8, 2)",
      "assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==(20, 3)"
    ]
  },
  {
    "mbpp_id": 131,
    "problem_statement": "Write a python function to reverse only the vowels of a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def reverse_vowels(s):\n    # Convert the input string into a list for easy manipulation\n    s_list = list(s)\n    \n    # Define a set of vowels for quick lookup\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    \n    # Initialize two pointers, one at the beginning and one at the end of the list\n    left, right = 0, len(s) - 1\n    \n    # Loop until the two pointers meet in the middle\n    while left < right:\n        # If both characters at the current pointers are not vowels, move them closer to the center\n        if s_list[left] not in vowels or s_list[right] not in vowels:\n            left += 1\n            right -= 1\n        \n        # If both characters are vowels, swap their positions\n        elif s_list[left] in vowels and s_list[right] in vowels:\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n            \n    # Join the modified list back into a string and return it\n    return ''.join(s_list)\n\n# Test cases to verify the correctness of the solution\nprint(reverse_vowels(\"Python\"))   # Expected output: \"Python\"\nprint(reverse_vowels(\"USA\"))      # Expected output: \"ASU\"\nprint(reverse_vowels(\"ab\"))       # Expected output: \"ab\"",
    "test_cases": [
      "assert reverse_vowels(\"Python\") == \"Python\"",
      "assert reverse_vowels(\"USA\") == \"ASU\"",
      "assert reverse_vowels(\"ab\") == \"ab\""
    ]
  },
  {
    "mbpp_id": 132,
    "problem_statement": "Write a function to convert tuple to a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def tup_string(tup):\n    return ''.join(tup)",
    "test_cases": [
      "assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")",
      "assert tup_string(('p','y','t','h','o','n'))==(\"python\")",
      "assert tup_string(('p','r','o','g','r','a','m'))==(\"program\")"
    ]
  },
  {
    "mbpp_id": 133,
    "problem_statement": "Write a function to calculate the sum of the negative numbers of a given list of numbers using lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'reduce' is not defined",
      "Test 2: FAIL - name 'reduce' is not defined",
      "Test 3: FAIL - name 'reduce' is not defined"
    ],
    "generated_code": "def sum_negativenum(nums):\n    return reduce(lambda x,y: x+y if y<0 else x, nums, 0)",
    "test_cases": [
      "assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32",
      "assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52",
      "assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894"
    ]
  },
  {
    "mbpp_id": 134,
    "problem_statement": "Write a python function to check whether the last element of given array is even or odd after performing an operation p times.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_last(arr, p, q):\n    # Check if the last element is even or odd based on the operation q and the number of iterations p\n    if arr[-1] % 2 == 0:\n        result = \"EVEN\"\n    else:\n        result = \"ODD\"\n\n    # Perform operation p times on the last element to determine the final outcome\n    for _ in range(p):\n        if result == \"EVEN\":\n            if arr[-1] - q < 0:\n                result = \"ODD\"\n            else:\n                result = \"EVEN\"\n        elif result == \"ODD\":\n            if arr[-1] + q > 0:\n                result = \"EVEN\"\n            else:\n                result = \"ODD\"\n\n    return result",
    "test_cases": [
      "assert check_last([5,7,10],3,1) == \"ODD\"",
      "assert check_last([2,3],2,3) == \"EVEN\"",
      "assert check_last([1,2,3],3,1) == \"ODD\""
    ]
  },
  {
    "mbpp_id": 135,
    "problem_statement": "Write a function to find the nth hexagonal number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'sqrt' is not defined"
    ],
    "generated_code": "def is_hexagonal(num):\n    # Check if a number can be expressed in the form of n(n+1)/2 where n >= 0\n    for i in range(-num + 1, num + 1):\n        if i * (i + 1) // 2 == num:\n            return True\n    return False\n\ndef hexagonal_num(n):\n    \"\"\"\n    Returns the nth hexagonal number.\n    \n    Parameters:\n    - n (int): The position of the hexagonal number to find\n    \n    Returns:\n    int: The nth hexagonal number\n    \"\"\"\n    x = ((2*n*sqrt(2)-n-1)**0.5)//1\n    if is_hexagonal(x*(x+1)//2):\n        return x*(x+1)//2\n    else:\n        return None\n\n# Test cases\nassert hexagonal_num(10) == 190\nassert hexagonal_num(5) == 45\nassert hexagonal_num(7) == 91",
    "test_cases": [
      "assert hexagonal_num(10) == 190",
      "assert hexagonal_num(5) == 45",
      "assert hexagonal_num(7) == 91"
    ]
  },
  {
    "mbpp_id": 136,
    "problem_statement": "Write a function to calculate electricity bill.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def cal_electbill(units):\n    # Define the cost structure for electricity consumption\n    rates = {\n        'units': [100, 150, 200], \n        'rates': [6, 8, 9]\n    }\n    \n    # Calculate the electricity bill based on units consumed\n    rate_per_unit = sum([rate * (units - prev_units) / ((prev_units + units) / 2)\n                         for prev_units, rate in zip(rates['units'], rates['rates'])])\n    \n    return round(rate_per_unit * units + 100) if units > 100 else round((100 / 60) * 60 + 100)",
    "test_cases": [
      "assert cal_electbill(75)==246.25",
      "assert cal_electbill(265)==1442.75",
      "assert cal_electbill(100)==327.5"
    ]
  },
  {
    "mbpp_id": 137,
    "problem_statement": "Write a function to find the ration of zeroes in an array of integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import numpy as np\n\ndef zero_count(arr):\n    # Count the number of zeros and calculate the ratio\n    return np.count_nonzero(arr) / len(arr)\n\n# Test cases\nprint(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]))  # Expected output: 0.15\nprint(zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]))   # Expected output: 0.00\nprint(zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17]))           # Expected output: 0.00",
    "test_cases": [
      "assert zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.15",
      "assert zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.00",
      "assert zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.00"
    ]
  },
  {
    "mbpp_id": 138,
    "problem_statement": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_Sum_Of_Powers_Of_Two(num):\n    \"\"\"\n    Check if the given number can be expressed as a sum of non-zero powers of 2.\n    \n    Parameters:\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num can be expressed as such a sum, False otherwise.\n    \"\"\"\n    while num > 0:\n        # If last bit is set in num and it's the first set bit encountered,\n        # then num cannot be expressed as a sum of non-zero powers of 2.\n        if num & 1 == 1 and (num - 1) % 2 != 0:\n            return False\n        num >>= 1\n    return True",
    "test_cases": [
      "assert is_Sum_Of_Powers_Of_Two(10) == True",
      "assert is_Sum_Of_Powers_Of_Two(7) == False",
      "assert is_Sum_Of_Powers_Of_Two(14) == True"
    ]
  },
  {
    "mbpp_id": 139,
    "problem_statement": "Write a function to find the circumference of a circle.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef circle_circumference(radius):\n    return 2 * math.pi * radius",
    "test_cases": [
      "assert circle_circumference(10)==62.830000000000005",
      "assert circle_circumference(5)==31.415000000000003",
      "assert circle_circumference(4)==25.132"
    ]
  },
  {
    "mbpp_id": 140,
    "problem_statement": "Write a function to extract elements that occur singly in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def extract_singly(tuple_list):\n    result = []\n    for t in tuple_list:\n        for item in t:\n            if t.count(item) == 1:\n                result.append(item)\n    return result\n\n# Test cases\nprint(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) # Output: [3, 4, 5, 7, 1]\nprint(extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)])) # Output: [1, 2, 3, 4, 7, 8]\nprint(extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)])) # Output: [7, 8, 9, 10, 11, 12]",
    "test_cases": [
      "assert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]",
      "assert extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)]) == [1, 2, 3, 4, 7, 8]",
      "assert extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)]) == [7, 8, 9, 10, 11, 12]"
    ]
  },
  {
    "mbpp_id": 141,
    "problem_statement": "Write a function to sort a list of elements using pancake sort.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def pancake_sort(arr):\n    n = len(arr)\n    for i in range(n - 1)[::-1]: \n        if arr[i] > arr[n - i - 1]: \n            # Move element to its correct position\n            for j in range(i + 1, n): \n                if arr[j] == max(arr[i:n]): \n                    break \n            arr = flip(arr, j)  \n            arr = flip(arr, i)  \n\n    return arr\n\ndef flip(arr, index):\n    start = 0\n    end = index\n    while start < end:\n        arr[start], arr[end] = arr[end], arr[start]\n        start += 1\n        end -= 1\n    return arr\n\n# Test cases\nprint(pancake_sort([15, 79, 25, 38, 69]))  # Expected output: [15, 25, 38, 69, 79]\nprint(pancake_sort([98, 12, 54, 36, 85]))  # Expected output: [12, 36, 54, 85, 98]\nprint(pancake_sort([41, 42, 32, 12, 23]))  # Expected output: [12, 23, 32, 41, 42]",
    "test_cases": [
      "assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]",
      "assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]",
      "assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]"
    ]
  },
  {
    "mbpp_id": 142,
    "problem_statement": "Write a function to count the same pair in three given lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_samepair(lst1, lst2, lst3):\n    return len(set(zip(lst1, lst2)).intersection(set(zip(lst1, lst3))))\n\n# Test cases\nprint(count_samepair([1,2,3,4,5,6,7,8], [2,2,3,1,2,6,7,9], [2,1,3,1,2,6,7,9])) # Output: 3\nprint(count_samepair([1,2,3,4,5,6,7,8], [2,2,3,1,2,6,7,8], [2,1,3,1,2,6,7,8])) # Output: 4\nprint(count_samepair([1,2,3,4,2,6,7,8], [2,2,3,1,2,6,7,8], [2,1,3,1,2,6,7,8])) # Output: 5",
    "test_cases": [
      "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3",
      "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4",
      "assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5"
    ]
  },
  {
    "mbpp_id": 143,
    "problem_statement": "Write a function to find number of lists present in the given tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_lists(tup):\n    # Initialize count to zero\n    count = 0\n    \n    # Iterate through each item in the tuple\n    for item in tup:\n        # If the item is itself a list, increment count by one\n        if isinstance(item, list):\n            count += 1\n            \n    # Return the final count of lists found\n    return count",
    "test_cases": [
      "assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2",
      "assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3",
      "assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1"
    ]
  },
  {
    "mbpp_id": 144,
    "problem_statement": "Write a python function to find the sum of absolute differences in all pairs of the given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_Pairs(nums, n):\n    result = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            result += abs(nums[i] - nums[j])\n    return result",
    "test_cases": [
      "assert sum_Pairs([1,8,9,15,16],5) == 74",
      "assert sum_Pairs([1,2,3,4],4) == 10",
      "assert sum_Pairs([1,2,3,4,5,7,9,11,14],9) == 188"
    ]
  },
  {
    "mbpp_id": 145,
    "problem_statement": "Write a python function to find the maximum difference between any two elements in a given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "def max_Abs_Diff(nums, k):\n    \"\"\"\n    Find the maximum absolute difference between any two elements in an array after performing at most 'k' operations.\n    \n    :param nums: List[int] - A list of integers representing the input array.\n    :param k: int - The number of allowed operations.\n    :return: int - The maximum possible absolute difference after performing up to 'k' operations.\n    \"\"\"\n    min_num = min(nums)\n    max_num = max(nums)\n    diff = max_num - min_num\n    \n    # If 'k' is non-positive, no operation can change the minimum value,\n    # so we can just use the original minimum as our answer.\n    if k <= 0:\n        return diff\n    \n    # Otherwise, we try subtracting and adding 'k' from both ends of the array,\n    # taking the maximum result obtained.\n    return max(diff + k * (max_num - nums[0]), diff - k * (nums[-1] - min_num))\n\n# Check function with provided data points\nassert max_Abs_Diff([7, 4, 10, 6, 2], 6) == 5, \"Test case 1 failed\"\nassert max_Abs_Diff([6, 7], 1) == 0, \"Test case 2 failed\"\nassert max_Abs_Diff([9, 3, 2, 5, 1], 5) == 8, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert max_Abs_Diff((2,1,5,3),4) == 4",
      "assert max_Abs_Diff((9,3,2,5,1),5) == 8",
      "assert max_Abs_Diff((3,2,1),3) == 2"
    ]
  },
  {
    "mbpp_id": 146,
    "problem_statement": "Write a function to find the ascii value of total characters in a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def ascii_value_string(s):\n    # Calculate the sum of ASCII values of all characters in the string\n    return sum(ord(char) for char in s)",
    "test_cases": [
      "assert ascii_value_string(\"python\")==112",
      "assert ascii_value_string(\"Program\")==80",
      "assert ascii_value_string(\"Language\")==76"
    ]
  },
  {
    "mbpp_id": 147,
    "problem_statement": "Write a function to find the maximum total path sum in the given triangle.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_path_sum(triangle, start_row, end_col):\n    \"\"\"\n    Finds the maximum total path sum from top to bottom of a given triangle.\n    \n    Parameters:\n    triangle (List[List[int]]): The triangle represented as a list of lists of integers.\n    start_row (int): The starting row index for considering the paths.\n    end_col (int): The ending column index for considering the paths.\n    \n    Returns:\n    int: The maximum total path sum.\n    \"\"\"\n    def max_path(remaining_triangle, current_index):\n        if remaining_triangle[current_index][end_col] == -1:\n            return -float('inf')\n        \n        if current_index >= len(remaining_triangle) - 1 and end_col != 0:\n            return 0\n        \n        if remaining_triangle[current_index][end_col] is not None:\n            return remaining_triangle[current_index][end_col]\n        \n        # Choose left path\n        left_choice = max_path(remaining_triangle, current_index + 1)\n        if current_index < len(remaining_triangle) - 1:\n            left_choice += remaining_triangle[current_index + 1][end_col]\n            \n        # Choose right path\n        right_choice = max_path(remaining_triangle, current_index + 1)\n        if current_index < len(remaining_triangle) - 1:\n            right_choice += remaining_triangle[current_index + 1][end_col - 1]\n        \n        remaining_triangle[current_index][end_col] = max(left_choice, right_choice)\n        return max(left_choice, right_choice)\n    \n    max_value = float('-inf')\n    for i in range(start_row, min(len(triangle), end_col)):\n        value = max_path(triangle, i)\n        max_value = max(max_value, value)\n    return max_value\n\n# Example usage:\nprint(max_path_sum([ [1, 0, 0], [4, 8, 0], [1, 5, 3] ], 2, 2))  # Should print 14",
    "test_cases": [
      "assert max_path_sum([[1, 0, 0], [4, 8, 0], [1, 5, 3]], 2, 2) == 14",
      "assert max_path_sum([[13, 0, 0], [7, 4, 0], [2, 4, 6]], 2, 2) == 24 ",
      "assert max_path_sum([[2, 0, 0], [11, 18, 0], [21, 25, 33]], 2, 2) == 53"
    ]
  },
  {
    "mbpp_id": 148,
    "problem_statement": "Write a function to divide a number into two parts such that the sum of digits is maximum.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "def sum_digits_twoparts(num):\n    \"\"\"\n    Divide the given number into two parts and return the sum of their digits.\n    \n    Args:\n    num (int): The input number.\n    \n    Returns:\n    int: Sum of the digits of the two parts after dividing the number.\n    \"\"\"\n    # Convert the number to a string for easy digit manipulation\n    str_num = str(num)\n    n = len(str_num)\n    \n    # Initialize variables to store the result and possible split points\n    max_sum = -1\n    split_point = -1\n    \n    # Iterate over all possible split points from 1 to n-1\n    for i in range(1, n):\n        part1 = int(str_num[:i])\n        part2 = int(str_num[i:])\n        \n        # Calculate the current sum of digits\n        current_sum = sum(int(digit) for digit in str(part1)) + sum(int(digit) for digit in str(part2))\n        \n        # Update the maximum sum found so far\n        if current_sum > max_sum:\n            max_sum = current_sum\n            split_point = i\n            \n    # Return the maximum sum of digits found\n    return max_sum\n\n# Check function with provided data points\nassert sum_digits_twoparts(35) == 17, \"Test case 1 failed\"\nassert sum_digits_twoparts(7) == 7, \"Test case 2 failed\"\nassert sum_digits_twoparts(100) == 19, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert sum_digits_twoparts(35)==17",
      "assert sum_digits_twoparts(7)==7",
      "assert sum_digits_twoparts(100)==19"
    ]
  },
  {
    "mbpp_id": 149,
    "problem_statement": "Write a function to find the longest subsequence such that the difference between adjacents is one for the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: pop from empty list"
    ],
    "generated_code": "from collections import defaultdict\nimport bisect\n\ndef longest_subseq_with_diff_one(nums, k):\n    # Initialize prefix sums and index dictionary\n    prefix_sum = [0]\n    index_dict = defaultdict(list)\n    for i in range(len(nums)):\n        prefix_sum.append(prefix_sum[-1] + nums[i])\n        index_dict[nums[i]].append(i)\n    \n    max_len = -float('inf')\n    left_index = -1\n    \n    for num in set(nums):  # Use set to avoid duplicate comparisons\n        if num > k:\n            break\n        \n        for idx in index_dict[num]:\n            right_index = bisect.bisect_right(index_dict[k - num], idx)\n            \n            if right_index != len(index_dict[k - num]):\n                diff = idx - index_dict[k - num][right_index]\n                max_len = max(max_len, diff)\n                \n                while True:\n                    current_index = index_dict[k - num].pop(0)\n                    if current_index == idx:\n                        break\n                    \n                    right_index = bisect.bisect_right(index_dict[k - num], current_index)\n                    \n                    if right_index < len(index_dict[k - num]) and idx < index_dict[k - num][right_index]:\n                        new_diff = idx - index_dict[k - num][right_index]\n                        \n                        if max_len < new_diff:\n                            max_len = new_diff\n                            \n                        else:\n                            break\n            \n            if left_index == -1:\n                left_index = bisect.bisect_left(index_dict[num], idx)\n        \n        if left_index != -1:\n            max_len = max(max_len, idx - left_index)\n    \n    return max_len\n\n# Example usage:\nprint(longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7))  # Output: 6\nprint(longest_subseq_with_diff_one([10, 9, 4, 5, 4, 8, 6], 7))  # Output: 3\nprint(longest_subseq_with_diff_one([1, 2, 3, 2, 3, 7, 2, 1], 8))  # Output: 7",
    "test_cases": [
      "assert longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7) == 6",
      "assert longest_subseq_with_diff_one([10, 9, 4, 5, 4, 8, 6], 7) == 3",
      "assert longest_subseq_with_diff_one([1, 2, 3, 2, 3, 7, 2, 1], 8) == 7"
    ]
  },
  {
    "mbpp_id": 150,
    "problem_statement": "Write a python function to find whether the given number is present in the infinite sequence or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'does_Contain_B' is not defined",
      "Test 2: FAIL - name 'does_Contain_B' is not defined",
      "Test 3: FAIL - name 'does_Contain_B' is not defined"
    ],
    "generated_code": "def does_contain_b(start, end, target):\n    \"\"\"\n    This function checks if the target value exists within the range defined by start and end.\n    \n    Parameters:\n    - start (int): The starting point of the range.\n    - end (int): The ending point of the range.\n    - target (int): The number to check for its presence within the range.\n    \n    Returns:\n    - bool: True if the target is found within the range, False otherwise.\n    \"\"\"\n    # Ensure the start is less than or equal to end for proper calculation\n    if start > end:\n        start, end = end, start\n    \n    # Check if the absolute difference between target and end is divisible by 2\n    return abs(target - end) % 2 == 0 and target >= start and target <= end",
    "test_cases": [
      "assert does_Contain_B(1,7,3) == True",
      "assert does_Contain_B(1,-3,5) == False",
      "assert does_Contain_B(3,2,5) == False"
    ]
  },
  {
    "mbpp_id": 151,
    "problem_statement": "Write a python function to check whether the given number is co-prime or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef is_coprime(a, b):\n    \"\"\"\n    Function to determine if two numbers are coprimes.\n    \n    Parameters:\n    - a: First integer\n    - b: Second integer\n    \n    Returns:\n    A boolean value indicating if 'a' and 'b' are coprimes.\n    \"\"\"\n    return math.gcd(a, b) == 1",
    "test_cases": [
      "assert is_coprime(17,13) == True",
      "assert is_coprime(15,21) == False",
      "assert is_coprime(25,45) == False"
    ]
  },
  {
    "mbpp_id": 152,
    "problem_statement": "Write a function to sort the given array by using merge sort.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    # Recursively split and merge\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n    \n    return merge(left_sorted, right_sorted)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result",
    "test_cases": [
      "assert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]",
      "assert merge_sort([7, 25, 45, 78, 11, 33, 19]) == [7, 11, 19, 25, 33, 45, 78]",
      "assert merge_sort([3, 1, 4, 9, 8]) == [1, 3, 4, 8, 9]"
    ]
  },
  {
    "mbpp_id": 153,
    "problem_statement": "Write a function to find the vertex of a parabola.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def parabola_vertex(a, b, c):\n    x = -b / (2 * a)\n    y = (-4*a*b + b**2 - 8*a*c) / (4*a**2)\n    return (x, y)\n\n# Test cases\nprint(parabola_vertex(5,3,2)) # Expected output: (-0.3, 1.55)\nprint(parabola_vertex(9,8,4)) # Expected output: (-0.4444444444444444, 2.2222222222222223)\nprint(parabola_vertex(2,4,6)) # Expected output: (-1.0, 4.0)",
    "test_cases": [
      "assert parabola_vertex(5,3,2)==(-0.3, 1.55)",
      "assert parabola_vertex(9,8,4)==(-0.4444444444444444, 2.2222222222222223)",
      "assert parabola_vertex(2,4,6)==(-1.0, 4.0)"
    ]
  },
  {
    "mbpp_id": 154,
    "problem_statement": "Write a function to extract every specified element from a given two dimensional list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def specified_element(matrix, index):\n    # Extract elements at the specified index from each sublist of the matrix\n    return [row[index] for row in matrix]\n\n# Test cases\nprint(specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 0))  # Output: [1, 4, 7]\nprint(specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 2))  # Output: [3, 6, 9]\nprint(specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 3))  # Output: [2, 2, 5]",
    "test_cases": [
      "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
      "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
      "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],3)==[2,2,5]"
    ]
  },
  {
    "mbpp_id": 155,
    "problem_statement": "Write a python function to toggle all even bits of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def even_bit_toggle_number(n):\n    # Convert n to binary string and reverse it for easier manipulation\n    binary_str = bin(n)[2:]\n    toggled_binary = ''.join('1' if bit == '0' else '0' for bit in reversed(binary_str))\n    # Reverse the result back to get correct order before converting back to int\n    toggled_int = int(toggled_binary[::-1], 2)\n    return toggled_int",
    "test_cases": [
      "assert even_bit_toggle_number(10) == 0",
      "assert even_bit_toggle_number(20) == 30",
      "assert even_bit_toggle_number(30) == 20"
    ]
  },
  {
    "mbpp_id": 156,
    "problem_statement": "Write a function to convert a tuple of string values to a tuple of integer values.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: int() argument must be a string, a bytes-like object or a real number, not 'tuple'"
    ],
    "generated_code": "def tuple_int_str(test_tuple):\n    return tuple(map(int, test_tuple))\n\n# Test Cases\nprint(tuple_int_str( (('333', '33'), ('1416', '55')))) # Should output ((333, 33), (1416, 55))\nprint(tuple_int_str( (('999', '99'), ('1000', '500')))) # Should output ((999, 99), (1000, 500))\nprint(tuple_int_str( (('666', '66'), ('1500', '555')))) # Should output ((666, 66), (1500, 555))",
    "test_cases": [
      "assert tuple_int_str((('333', '33'), ('1416', '55')))==((333, 33), (1416, 55))",
      "assert tuple_int_str((('999', '99'), ('1000', '500')))==((999, 99), (1000, 500))",
      "assert tuple_int_str((('666', '66'), ('1500', '555')))==((666, 66), (1500, 555))"
    ]
  },
  {
    "mbpp_id": 157,
    "problem_statement": "Write a function to reflect the run-length encoding from a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def encode_list(lst):\n    result = []\n    i = 0\n    while i < len(lst):\n        count = 1\n        current_value = lst[i]\n        while i + 1 < len(lst) and lst[i] == lst[i+1]:\n            i += 1\n            count += 1\n        if count > 1:\n            result.append([count, current_value])\n        else:\n            result.append([1, current_value])\n        i += 1\n    return result",
    "test_cases": [
      "assert encode_list([1,1,2,3,4,4.3,5,1])==[[2, 1], [1, 2], [1, 3], [1, 4], [1, 4.3], [1, 5], [1, 1]]",
      "assert encode_list('automatically')==[[1, 'a'], [1, 'u'], [1, 't'], [1, 'o'], [1, 'm'], [1, 'a'], [1, 't'], [1, 'i'], [1, 'c'], [1, 'a'], [2, 'l'], [1, 'y']]",
      "assert encode_list('python')==[[1, 'p'], [1, 'y'], [1, 't'], [1, 'h'], [1, 'o'], [1, 'n']]"
    ]
  },
  {
    "mbpp_id": 158,
    "problem_statement": "Write a python function to find k number of operations required to make all elements equal.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_Ops(nums, k, target):\n    if sum(nums) % k != 0:\n        return -1\n    \n    total = sum(nums)\n    average = total // k\n    result = 0\n    \n    for num in nums:\n        difference = abs(num - average)\n        if difference > average:\n            need_to_adjust = max(average - difference + k * (num - average), average + difference - k * (total - num))\n            result += need_to_adjust // k\n    \n    return result",
    "test_cases": [
      "assert min_Ops([2,2,2,2],4,3) == 0",
      "assert min_Ops([4,2,6,8],4,3) == -1",
      "assert min_Ops([21,33,9,45,63],5,6) == 24"
    ]
  },
  {
    "mbpp_id": 159,
    "problem_statement": "Write a function to print the season for the given month and day.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def month_season(month, day):\n    if month == 'December' or month == 'January' or month == 'February':\n        return 'winter'\n    elif month == 'March' or month == 'April' or month == 'May':\n        return 'spring'\n    elif month == 'June' or month == 'July' or month == 'August':\n        return 'summer'\n    else:\n        return 'fall'",
    "test_cases": [
      "assert month_season('January',4)==('winter')",
      "assert month_season('October',28)==('autumn')",
      "assert month_season('June',6)==('spring')"
    ]
  },
  {
    "mbpp_id": 160,
    "problem_statement": "Write a function to find x and y that satisfies ax + by = n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - SyntaxError: f-string: expecting '}'"
    ],
    "generated_code": "from sympy import symbols, Eq, solve\n\ndef solution(a, b, n):\n    x, y = symbols('x y')\n    equation = Eq(a * x + b * y, n)\n    solutions = solve(equation, (x, y))\n    if len(solutions) == 0:\n        return 'No solution'\n    elif len(solutions) > 1:\n        raise ValueError(\"The system of equations has multiple solutions.\")\n    \n    result = []\n    for sol in solutions[0]:\n        if sol.is_integer():\n            result.append(str(sol))\n        else:\n            result.append(f\"x = {sol}, y = {int(sol)}\")\n            \n    return f\"{'x = '.join(result), \", \"}, {'y = '.join(result)}\"",
    "test_cases": [
      "assert solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)",
      "assert solution(4, 2, 7) == 'No solution'",
      "assert solution(1, 13, 17) == ('x = ', 4, ', y = ', 1)"
    ]
  },
  {
    "mbpp_id": 161,
    "problem_statement": "Write a function to remove all elements from a given list present in another list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_elements(source_list, elements_to_remove):\n    # Remove elements from source_list that are also in elements_to_remove\n    return [element for element in source_list if element not in elements_to_remove]\n\n# Test cases to verify the correctness of the solution\nassert remove_elements([1,2,3,4,5,6,7,8,9,10], [2,4,6,8]) == [1, 3, 5, 7, 9, 10]\nassert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]\nassert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5,7]) == [1, 2, 3, 4, 6, 8, 9, 10]",
    "test_cases": [
      "assert remove_elements([1,2,3,4,5,6,7,8,9,10],[2,4,6,8])==[1, 3, 5, 7, 9, 10]",
      "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[1, 3, 5, 7])==[2, 4, 6, 8, 9, 10]",
      "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[5,7])==[1, 2, 3, 4, 6, 8, 9, 10]"
    ]
  },
  {
    "mbpp_id": 162,
    "problem_statement": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_series(n):\n    \"\"\"\n    Calculate the sum of the series n + (n-2) + (n-4) + ... until n - x <= 0.\n    \n    Parameters:\n    n (int): The starting number of the series.\n    \n    Returns:\n    int: The sum of the series.\n    \"\"\"\n    if n < 1:\n        return 0\n    total_sum = 0\n    while True:\n        total_sum += n\n        n -= 2\n        if n <= 0:\n            break\n    return total_sum",
    "test_cases": [
      "assert sum_series(6)==12",
      "assert sum_series(10)==30",
      "assert sum_series(9)==25"
    ]
  },
  {
    "mbpp_id": 163,
    "problem_statement": "Write a function to calculate the area of a regular polygon.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef area_polygon(sides, length):\n    \"\"\"\n    Calculate the area of a regular polygon with 'sides' sides of length 'length'.\n    \n    :param sides: The number of sides of the polygon.\n    :param length: The length of each side.\n    :return: The area of the polygon rounded to 10 decimal places.\n    \"\"\"\n    return round((sides * length**2) / (4 * math.tan(math.pi/sides)), 10)\n\n# Test cases\nprint(area_polygon(4, 20)) # Expected output: 400.000000000\nprint(area_polygon(10, 15)) # Expected output: 1731.196989661\nprint(area_polygon(9, 7))   # Expected output: 302.909385495",
    "test_cases": [
      "assert area_polygon(4,20)==400.00000000000006",
      "assert area_polygon(10,15)==1731.1969896610804",
      "assert area_polygon(9,7)==302.90938549487214"
    ]
  },
  {
    "mbpp_id": 164,
    "problem_statement": "Write a python function to check whether the sum of divisors are same or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def areEquivalent(n, k):\n    # Calculate sum of divisors for n and k\n    sum_n = sum([i for i in range(1, int(n**0.5)+1) if n % i == 0])\n    sum_k = sum([i for i in range(1, int(k**0.5)+1) if k % i == 0])\n    \n    # Check if sums are equal\n    return sum_n == sum_k\n\n# Test cases\nprint(areEquivalent(36, 57))  # Expected output: False\nprint(areEquivalent(2, 4))    # Expected output: False\nprint(areEquivalent(23, 47))  # Expected output: True",
    "test_cases": [
      "assert areEquivalent(36,57) == False",
      "assert areEquivalent(2,4) == False",
      "assert areEquivalent(23,47) == True"
    ]
  },
  {
    "mbpp_id": 165,
    "problem_statement": "Write a python function to count characters at same position in a given string (lower and uppercase characters) as in english alphabet.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "def count_char_position(s):\n    \"\"\"\n    Counts the number of occurrences where lowercase letters match their corresponding positions in the English alphabet.\n    \n    Parameters:\n    s (str): The input string containing lower and uppercase characters.\n    \n    Returns:\n    int: The total count of matching character positions.\n    \"\"\"\n    char_count = {'a': 0, 'b': 0, 'c': 0, 'd': 0, 'e': 0, 'f': 0, 'g': 0, 'h': 0, 'i': 0, 'j': 0, 'k': 0,\n                  'l': 0, 'm': 0, 'n': 0, 'o': 0, 'p': 0, 'q': 0, 'r': 0, 's': 0, 't': 0, 'u': 0, 'v': 0,\n                  'w': 0, 'x': 0, 'y': 0, 'z': 0}\n    \n    for c in s.lower():\n        if c.isalpha() and c in char_count.keys():\n            char_count[c] += 1\n    \n    # Sum up all counts of lowercase letters with odd positions (A -> Z)\n    return sum(char_count.values()) - sum(val // 2 for val in char_count.values())\n\n# Check function with provided data points\nassert count_char_position(\"xbcefg\") == 2, \"Test case 1 failed\"\nassert count_char_position(\"ABcED\") == 3, \"Test case 2 failed\"\nassert count_char_position(\"AbgdeF\") == 5, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert count_char_position(\"xbcefg\") == 2",
      "assert count_char_position(\"ABcED\") == 3",
      "assert count_char_position(\"AbgdeF\") == 5"
    ]
  },
  {
    "mbpp_id": 166,
    "problem_statement": "Write a python function to count the pairs with xor as an even number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_even_Pair(nums, target):\n    odd_count = sum(1 for num in nums if num % 2 != 0)\n    return (odd_count * (odd_count - 1)) // 2\n\n# Test cases\nprint(find_even_Pair([5,4,7,2,1], 5))  # Output: 4\nprint(find_even_Pair([7,2,8,1,0,5,11], 7))  # Output: 9\nprint(find_even_Pair([1,2,3], 3))  # Output: 1",
    "test_cases": [
      "assert find_even_Pair([5,4,7,2,1],5) == 4",
      "assert find_even_Pair([7,2,8,1,0,5,11],7) == 9",
      "assert find_even_Pair([1,2,3],3) == 1"
    ]
  },
  {
    "mbpp_id": 167,
    "problem_statement": "Write a python function to find smallest power of 2 greater than or equal to n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'next_Power_OF_2' is not defined. Did you mean: 'next_Power_Of_2'?"
    ],
    "generated_code": "def next_Power_Of_2(n):\n    \"\"\"\n    Finds the smallest power of 2 which is greater than or equal to n.\n    \n    Args:\n        n (int): The input number\n    \n    Returns:\n        int: The smallest power of 2 greater than or equal to n\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        # Find the highest set bit position and then calculate 2^bit_position-1\n        highest_set_bit = max(0, len(bin(n)) - 3)\n        return 2 ** highest_set_bit\n\n# Test cases\nassert next_Power_Of_2(0) == 1\nassert next_Power_OF_2(5) == 8\nassert next_Power_OF_2(17) == 32",
    "test_cases": [
      "assert next_Power_Of_2(0) == 1",
      "assert next_Power_Of_2(5) == 8",
      "assert next_Power_Of_2(17) == 32"
    ]
  },
  {
    "mbpp_id": 168,
    "problem_statement": "Write a python function to find the frequency of a number in a given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def frequency(arr, num):\n    count = 0\n    for element in arr:\n        if element == num:\n            count += 1\n    return count",
    "test_cases": [
      "assert frequency([1,2,3],4) == 0",
      "assert frequency([1,2,2,3,3,3,4],3) == 3",
      "assert frequency([0,1,2,3,1,2],1) == 2"
    ]
  },
  {
    "mbpp_id": 169,
    "problem_statement": "Write a function to calculate the nth pell number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_pell(n):\n    # Base case for first two Pell numbers\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Pell numbers\n    p1 = 0\n    p2 = 1\n    \n    # Calculate Pn using recursion\n    for i in range(2, n + 1):\n        next_value = p1 + p2 * 2\n        p1 = p2\n        p2 = next_value\n    \n    return p2",
    "test_cases": [
      "assert get_pell(4) == 12",
      "assert get_pell(7) == 169",
      "assert get_pell(8) == 408"
    ]
  },
  {
    "mbpp_id": 170,
    "problem_statement": "Write a function to find sum of the numbers in a list between the indices of a specified range.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_range_list(nums, start_index, end_index):\n    return sum(nums[start_index:end_index+1])",
    "test_cases": [
      "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],8,10)==29",
      "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],5,7)==16",
      "assert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],7,10)==38"
    ]
  },
  {
    "mbpp_id": 171,
    "problem_statement": "Write a function to find the perimeter of a pentagon.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def perimeter_pentagon(side_length):\n    # Calculate and return the perimeter of a pentagon with given side length\n    return 5 * side_length",
    "test_cases": [
      "assert perimeter_pentagon(5)==25",
      "assert perimeter_pentagon(10)==50",
      "assert perimeter_pentagon(15)==75"
    ]
  },
  {
    "mbpp_id": 172,
    "problem_statement": "Write a function to find the occurence of characters 'std' in the given string 1. list item 1. list item 1. list item 2. list item 2. list item 2. list item",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_occurance(s):\n    # Initialize the counter for occurrences\n    occurrence = 0\n    \n    # Loop through each character in the string\n    for char in s:\n        # Check if the current character is one of the required ones ('s', 't', 'd')\n        if char == \"s\" or char == \"t\" or char == \"d\":\n            occurrence += 1\n            \n    # Return the total number of occurrences found\n    return occurrence",
    "test_cases": [
      "assert count_occurance(\"letstdlenstdporstd\") == 3",
      "assert count_occurance(\"truststdsolensporsd\") == 1",
      "assert count_occurance(\"makestdsostdworthit\") == 2"
    ]
  },
  {
    "mbpp_id": 173,
    "problem_statement": "Write a function to remove everything except alphanumeric characters from a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef remove_splchar(s):\n    # Use regex to replace non-alphanumeric characters with an empty string\n    return re.sub(r'[^a-zA-Z0-9]', '', s)\n\n# Test cases\nprint(remove_splchar('python  @#&^%$*program123'))  # Expected output: 'pythonprogram123'\nprint(remove_splchar('python %^$@!^&*()  programming24%$^^()    language'))  # Expected output: 'pythonprogramming24language'\nprint(remove_splchar('python   ^%&^()(+_)(_^&67)                  program'))  # Expected output: 'python67program'",
    "test_cases": [
      "assert remove_splchar('python  @#&^%$*program123')==('pythonprogram123')",
      "assert remove_splchar('python %^$@!^&*()  programming24%$^^()    language')==('pythonprogramming24language')",
      "assert remove_splchar('python   ^%&^()(+_)(_^&67)                  program')==('python67program')"
    ]
  },
  {
    "mbpp_id": 174,
    "problem_statement": "Write a function to group a sequence of key-value pairs into a dictionary of lists.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def group_keyvalue(kv_pairs):\n    # Initialize an empty dictionary to store groups\n    result = {}\n    \n    # Iterate through each key-value pair in the input list\n    for k, v in kv_pairs:\n        if k not in result:\n            # If the key is not already in the dictionary, initialize it with an empty list\n            result[k] = []\n        # Append the value to the corresponding list under the key\n        result[k].append(v)\n    \n    return result",
    "test_cases": [
      "assert group_keyvalue([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)])=={'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}",
      "assert group_keyvalue([('python', 1), ('python', 2), ('python', 3), ('python', 4), ('python', 5)])=={'python': [1,2,3,4,5]}",
      "assert group_keyvalue([('yellow',100), ('blue', 200), ('yellow', 300), ('blue', 400), ('red', 100)])=={'yellow': [100, 300], 'blue': [200, 400], 'red': [100]}"
    ]
  },
  {
    "mbpp_id": 175,
    "problem_statement": "Write a function to verify validity of a string of parentheses.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_valid_parenthese(parentheses):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    \n    for char in parentheses:\n        if char not in mapping:\n            stack.append(char)\n        elif not stack or mapping[char] != stack.pop():\n            return False\n    \n    return len(stack) == 0",
    "test_cases": [
      "assert is_valid_parenthese(\"(){}[]\")==True",
      "assert is_valid_parenthese(\"()[{)}\")==False",
      "assert is_valid_parenthese(\"()\")==True"
    ]
  },
  {
    "mbpp_id": 176,
    "problem_statement": "Write a function to find the perimeter of a triangle.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def perimeter_triangle(a, b, c):\n    # Calculate the perimeter of the triangle\n    return a + b + c",
    "test_cases": [
      "assert perimeter_triangle(10,20,30)==60",
      "assert perimeter_triangle(3,4,5)==12",
      "assert perimeter_triangle(25,35,45)==105"
    ]
  },
  {
    "mbpp_id": 177,
    "problem_statement": "Write a python function to find two distinct numbers such that their lcm lies within the given range.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def gcd(a, b):\n    \"\"\"\n    Euclidean algorithm to compute greatest common divisor.\n    \"\"\"\n    while(b):\n        a, b = b, a % b\n    return a\n\ndef lcm(x, y):\n    \"\"\"\n    Calculate lowest common multiple of x and y.\n    \"\"\"\n    return x * y // gcd(x, y)\n\ndef answer(gcd_range_min, gcd_range_max):\n    for i in range(1, 10):  # Assuming we'll start checking from 1 as per usual practice in such problems\n        if gcd(i, 1) >= gcd_range_min:\n            if lcm(i, 1) <= gcd_range_max:\n                return (i, 1)\n    \n    for i in range(2, 10):\n        if gcd(i, 1) >= gcd_range_min:\n            if lcm(i, 1) <= gcd_range_max:\n                return (i, 1)\n    \n    return None",
    "test_cases": [
      "assert answer(3,8) == (3,6)",
      "assert answer(2,6) == (2,4)",
      "assert answer(1,3) == (1,2)"
    ]
  },
  {
    "mbpp_id": 178,
    "problem_statement": "Write a function to search some literals strings in a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef string_literals(string_list, target_string):\n    # Initialize an empty list to store matches\n    matches = []\n    \n    # Iterate through each literal string in the list\n    for literal in string_list:\n        # Search for the literal pattern within the target string\n        if re.search(literal, target_string):\n            # If found, add 'Matched!' to the list of matches and break out of the loop\n            matches.append(\"Matched!\")\n            break\n    \n    # Check if no matches were found and append 'Not Matched!' to the list\n    if not matches:\n        matches.append(\"Not Matched!\")\n    \n    # Join all matches into a single string separated by newlines\n    return '\\n'.join(matches)\n\n# Test cases\nprint(string_literals(['language'], 'python language'))  # Should print \"Matched!\"\nprint(string_literals(['program'], 'python language'))   # Should print \"Not Matched!\"\nprint(string_literals(['python'], 'programming language'))  # Should print \"Not Matched!\"",
    "test_cases": [
      "assert string_literals(['language'],'python language')==('Matched!')",
      "assert string_literals(['program'],'python language')==('Not Matched!')",
      "assert string_literals(['python'],'programming language')==('Not Matched!')"
    ]
  },
  {
    "mbpp_id": 179,
    "problem_statement": "Write a function to find if the given number is a keith number or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "TIMEOUT"
    ],
    "generated_code": "def is_num_keith(num):\n    # Check for edge case where num <= 0\n    if num <= 0:\n        return False\n    \n    original_num = num\n    total_sum = 0\n    \n    while num > 0:\n        digit = num % 10\n        total_sum += digit ** 2\n        num //= 10\n    \n    while original_num != 1 and original_num != total_sum:\n        original_num = total_sum\n        total_sum = sum(int(digit) ** 2 for digit in str(total_sum))\n    \n    return original_num == 1\n\n# Test cases\nprint(is_num_keith(14))  # Expected output: True\nprint(is_num_keith(12))  # Expected output: False\nprint(is_num_keith(197)) # Expected output: True",
    "test_cases": [
      "assert is_num_keith(14) == True",
      "assert is_num_keith(12) == False",
      "assert is_num_keith(197) == True"
    ]
  },
  {
    "mbpp_id": 180,
    "problem_statement": "Write a function to calculate distance between two points using latitude and longitude.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef distance_lat_long(lat1, lon1, lat2, lon2):\n    # Convert decimal degrees to radians \n    lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])\n    \n    # Haversine formula  \n    dlat = lat2 - lat1 \n    dlon = lon2 - lon1 \n    a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2\n    c = 2 * math.asin(math.sqrt(a)) \n    r = 6371 # Radius of earth in kilometers. Use 3956 for miles\n    return round(c * r, 5)",
    "test_cases": [
      "assert distance_lat_long(23.5,67.5,25.5,69.5)==12179.372041317429",
      "assert distance_lat_long(10.5,20.5,30.5,40.5)==6069.397933300514",
      "assert distance_lat_long(10,20,30,40)==6783.751974994595"
    ]
  },
  {
    "mbpp_id": 181,
    "problem_statement": "Write a function to find the longest common prefix in the given set of strings.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def common_prefix(words, n): \n    # Sort words based on length and lexicographical order\n    sorted_words = sorted(words)\n    \n    # Initialize the first word as the potential prefix\n    prefix = sorted_words[0]\n    \n    for i in range(n - 1):  \n        # If characters don't match at the current position, break the loop\n        if sorted_words[i][n-1] != sorted_words[i+1][n-1]:\n            break\n        \n        # Remove last character from the prefix until it matches with another string\n        prefix = prefix[:-1]\n        \n        if not prefix:\n            return ''  # No common prefix found\n    \n    return prefix\n\n# Test cases\nprint(common_prefix([\"tablets\", \"tables\", \"taxi\", \"tamarind\"], 4))  # Expected output: 'ta'\nprint(common_prefix([\"apples\", \"ape\", \"april\"], 3))  # Expected output: 'ap'\nprint(common_prefix([\"teens\", \"teenager\", \"teenmar\"], 3))  # Expected output: 'teen'",
    "test_cases": [
      "assert common_prefix([\"tablets\", \"tables\", \"taxi\", \"tamarind\"], 4) == 'ta'",
      "assert common_prefix([\"apples\", \"ape\", \"april\"], 3) == 'ap'",
      "assert common_prefix([\"teens\", \"teenager\", \"teenmar\"], 3) == 'teen'"
    ]
  },
  {
    "mbpp_id": 182,
    "problem_statement": "Write a function to find uppercase, lowercase, special character and numeric values using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef find_character(text):\n    upper = []\n    lower = []\n    special = []\n    num = []\n\n    for char in text:\n        if char.isupper():\n            upper.append(char)\n        elif char.islower():\n            lower.append(char)\n        elif not char.isdigit() and not char.isalpha():\n            special.append(char)\n        else:\n            num.append(char)\n\n    return (upper, lower, special, num)",
    "test_cases": [
      "assert find_character(\"ThisIsGeeksforGeeks\") == (['T', 'I', 'G', 'G'], ['h', 'i', 's', 's', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'e', 'e', 'k', 's'], [], [])",
      "assert find_character(\"Hithere2\") == (['H'], ['i', 't', 'h', 'e', 'r', 'e'], ['2'], [])",
      "assert find_character(\"HeyFolks32\") == (['H', 'F'], ['e', 'y', 'o', 'l', 'k', 's'], ['3', '2'], [])"
    ]
  },
  {
    "mbpp_id": 183,
    "problem_statement": "Write a function to count all the distinct pairs having a difference of k in any array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_pairs(arr, k, target_sum):\n    from collections import Counter\n    \n    # Create counters for each number and its complement relative to k\n    num_count = Counter(num + target_sum for num in arr)\n    \n    # Calculate the number of pairs\n    total_pairs = sum(count * (count - 1) // 2 for count in num_count.values() if count > 1)\n    \n    return total_pairs",
    "test_cases": [
      "assert count_pairs([1, 5, 3, 4, 2], 5, 3) == 2",
      "assert count_pairs([8, 12, 16, 4, 0, 20], 6, 4) == 5",
      "assert count_pairs([2, 4, 1, 3, 4], 5, 2) == 3"
    ]
  },
  {
    "mbpp_id": 184,
    "problem_statement": "Write a function to find all the values in a list that are greater than a specified number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def greater_specificnum(nums, num):\n    for i in nums:\n        if i > num:\n            return True\n    return False",
    "test_cases": [
      "assert greater_specificnum([220, 330, 500],200)==True",
      "assert greater_specificnum([12, 17, 21],20)==False",
      "assert greater_specificnum([1,2,3,4],10)==False"
    ]
  },
  {
    "mbpp_id": 185,
    "problem_statement": "Write a function to find the focus of a parabola.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def parabola_focus(a,b,c):\n    # Calculate the x-coordinate of the focus using the formula -b/(2a)\n    x = -b / (2 * a)\n    \n    # Calculate the y-coordinate of the focus using the formula c - b^2 / (4a)\n    y = c - (b ** 2) / (4 * a)\n    \n    return (x, y)\n\n# Test cases\nprint(parabola_focus(5,3,2))  # Expected output: (-0.3, 1.6)\nprint(parabola_focus(9,8,4))  # Expected output: (-0.4444444444444444, 2.25)\nprint(parabola_focus(2,4,6))  # Expected output: (-1.0, 4.125)",
    "test_cases": [
      "assert parabola_focus(5,3,2)==(-0.3, 1.6)",
      "assert parabola_focus(9,8,4)==(-0.4444444444444444, 2.25)",
      "assert parabola_focus(2,4,6)==(-1.0, 4.125)"
    ]
  },
  {
    "mbpp_id": 186,
    "problem_statement": "Write a function to search some literals strings in a string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef check_literals(input_string, pattern_list):\n    for pattern in pattern_list:\n        if re.search(pattern, input_string):\n            return 'Matched!'\n    return 'Not Matched!'",
    "test_cases": [
      "assert check_literals('The quick brown fox jumps over the lazy dog.',['fox']) == 'Matched!'",
      "assert check_literals('The quick brown fox jumps over the lazy dog.',['horse']) == 'Not Matched!'",
      "assert check_literals('The quick brown fox jumps over the lazy dog.',['lazy']) == 'Matched!'"
    ]
  },
  {
    "mbpp_id": 187,
    "problem_statement": "Write a function to find the longest common subsequence for the given two sequences.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def longest_common_subsequence(s1, s2, n1, n2):\n    # Initialize a DP table with zeros\n    dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n1 + 1):\n        for j in range(1, n2 + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                \n    # The length of the longest common subsequence is in the bottom-right cell of the DP table\n    return dp[n1][n2]",
    "test_cases": [
      "assert longest_common_subsequence(\"AGGTAB\" , \"GXTXAYB\", 6, 7) == 4",
      "assert longest_common_subsequence(\"ABCDGH\" , \"AEDFHR\", 6, 6) == 3",
      "assert longest_common_subsequence(\"AXYT\" , \"AYZX\", 4, 4) == 2"
    ]
  },
  {
    "mbpp_id": 188,
    "problem_statement": "Write a python function to check whether the given number can be represented by product of two squares or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - division by zero",
      "Test 2: FAIL - division by zero",
      "Test 3: FAIL - division by zero"
    ],
    "generated_code": "def prod_Square(n):\n    \"\"\"\n    Check if n can be represented as the product of two squares.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is representable as the product of two squares, False otherwise.\n    \"\"\"\n    for i in range(int(n**0.5)+1):\n        j = int((n / i)**0.5)\n        if i * j == n:\n            return True\n    return False",
    "test_cases": [
      "assert prod_Square(25) == False",
      "assert prod_Square(30) == False",
      "assert prod_Square(16) == True"
    ]
  },
  {
    "mbpp_id": 189,
    "problem_statement": "Write a python function to find the first missing positive number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: first_Missing_Positive() takes 1 positional argument but 2 were given"
    ],
    "generated_code": "def first_Missing_Positive(nums):\n    for i in range(len(nums)):\n        while nums[i] > 0 and nums[i] <= len(nums) and nums[nums[i]-1] != nums[i]:\n            swap = nums[nums[i]-1]\n            nums[nums[i]-1] = nums[i]\n            nums[i] = swap\n    for i in range(1, len(nums)+1):\n        if nums[i-1] != i:\n            return i\n    return len(nums)+1\n\n# Test cases\nprint(first_Missing_Positive([1,2,3,-1,5], 5))  # Output: 4\nprint(first_Missing_Positive([0,-1,-2,1,5,8], 6))  # Output: 2\nprint(first_Missing_Positive([0,1,2,5,-8], 5))  # Output: 3",
    "test_cases": [
      "assert first_Missing_Positive([1,2,3,-1,5],5) == 4",
      "assert first_Missing_Positive([0,-1,-2,1,5,8],6) == 2",
      "assert first_Missing_Positive([0,1,2,5,-8],5) == 3"
    ]
  },
  {
    "mbpp_id": 190,
    "problem_statement": "Write a python function to count the number of integral co-ordinates that lie inside a square.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Intgral_Points(x1, y1, x2, y2):\n    # Calculate the number of integer points inside the rectangle formed by the top-left corner (x1, y1) and bottom-right corner (x2, y2)\n    return max(min(x2 - x1 + 1, y2 - y1 + 1), 0)",
    "test_cases": [
      "assert count_Intgral_Points(1,1,4,4) == 4",
      "assert count_Intgral_Points(1,2,1,2) == 1",
      "assert count_Intgral_Points(4,2,6,4) == 1"
    ]
  },
  {
    "mbpp_id": 191,
    "problem_statement": "Write a function to check whether the given month name contains 30 days or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_monthnumber(month_name):\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    \n    if month_name in months_with_30_days:\n        return True\n    else:\n        return False",
    "test_cases": [
      "assert check_monthnumber(\"February\")==False",
      "assert check_monthnumber(\"June\")==True",
      "assert check_monthnumber(\"April\")==True"
    ]
  },
  {
    "mbpp_id": 192,
    "problem_statement": "Write a python function to check whether a string has atleast one letter and one number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef check_String(input_string):\n    # Use regex to search for at least one digit and one alphabet in the input string\n    pattern = r\"^[a-zA-Z][0-9]*[a-zA-Z]?$\"\n    if re.search(pattern, input_string):\n        return True\n    else:\n        return False\n\n# Test cases\nprint(check_String('thishasboth29'))  # Expected output: True\nprint(check_String('python'))         # Expected output: False\nprint(check_String('string'))         # Expected output: False",
    "test_cases": [
      "assert check_String('thishasboth29') == True",
      "assert check_String('python') == False",
      "assert check_String ('string') == False"
    ]
  },
  {
    "mbpp_id": 193,
    "problem_statement": "Write a function to remove the duplicates from the given tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'remove_tuple' is not defined",
      "Test 2: FAIL - name 'remove_tuple' is not defined",
      "Test 3: FAIL - name 'remove_tuple' is not defined"
    ],
    "generated_code": "def remove_duplicates(test_tuple):\n    seen = set()\n    result = []\n    for item in test_tuple:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return tuple(result)\n\n# Test cases\nprint(remove_duplicates((1, 3, 5, 2, 3, 5, 1, 1, 3))) # Expected output: (1, 2, 3, 5)\nprint(remove_duplicates((2, 3, 4, 4, 5, 6, 6, 7, 8, 8))) # Expected output: (2, 3, 4, 5, 6, 7, 8)\nprint(remove_duplicates((11, 12, 13, 11, 11, 12, 14, 13))) # Expected output: (11, 12, 13, 14)",
    "test_cases": [
      "assert remove_tuple((1, 3, 5, 2, 3, 5, 1, 1, 3)) == (1, 2, 3, 5)",
      "assert remove_tuple((2, 3, 4, 4, 5, 6, 6, 7, 8, 8)) == (2, 3, 4, 5, 6, 7, 8)",
      "assert remove_tuple((11, 12, 13, 11, 11, 12, 14, 13)) == (11, 12, 13, 14)"
    ]
  },
  {
    "mbpp_id": 194,
    "problem_statement": "Write a python function to convert octal number to decimal number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def octal_To_Decimal(octal_num):\n    # Convert octal string to decimal integer\n    decimal_value = int(str(octal_num), 8)\n    return decimal_value\n\n# Test cases\nprint(octal_To_Decimal(25))  # Expected output: 21\nprint(octal_To_Decimal(30))  # Expected output: 24\nprint(octal_To_Decimal(40))  # Expected output: 32",
    "test_cases": [
      "assert octal_To_Decimal(25) == 21",
      "assert octal_To_Decimal(30) == 24",
      "assert octal_To_Decimal(40) == 32"
    ]
  },
  {
    "mbpp_id": 195,
    "problem_statement": "Write a python function to find the first position of an element in a sorted array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def first(arr, x, n):\n    low = 0\n    high = n - 1\n    \n    while low <= high:\n        mid = low + (high - low) // 2\n        \n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] > x:\n            high = mid - 1\n        else:\n            # If arr[mid] == x, then there could be duplicates on the left side.\n            if mid == 0 or arr[mid-1] != x:\n                return mid\n            else:\n                high = mid - 1\n    return -1\n\n# Test cases\nprint(first([1,2,3,4,5,6,6], 6, 6))  # Expected output: 5\nprint(first([1,2,2,2,3,2,2,4,2], 2, 9))  # Expected output: 1\nprint(first([1,2,3], 1, 3))  # Expected output: 0",
    "test_cases": [
      "assert first([1,2,3,4,5,6,6],6,6) == 5",
      "assert first([1,2,2,2,3,2,2,4,2],2,9) == 1",
      "assert first([1,2,3],1,3) == 0"
    ]
  },
  {
    "mbpp_id": 196,
    "problem_statement": "Write a function to remove all the tuples with length k.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_tuples(input_list, k):\n    # Remove tuples of length k from input list\n    return [x for x in input_list if len(x) != k]\n\n# Test Cases\nprint(remove_tuples([(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)], 1)) # Output: [(4, 5), (8, 6, 7), (3, 4, 6, 7)]\nprint(remove_tuples([(4, 5), (4,5), (6, 7), (1, 2, 3), (3, 4, 6, 7)], 2)) # Output: [(1, 2, 3), (3, 4, 6, 7)]\nprint(remove_tuples([(1, 4, 4), (4, 3), (8, 6, 7), (1, ), (3, 6, 7)], 3)) # Output: [(4, 3), (1,)]",
    "test_cases": [
      "assert remove_tuples([(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)] , 1) == [(4, 5), (8, 6, 7), (3, 4, 6, 7)]",
      "assert remove_tuples([(4, 5), (4,5), (6, 7), (1, 2, 3), (3, 4, 6, 7)] ,2) == [(1, 2, 3), (3, 4, 6, 7)]",
      "assert remove_tuples([(1, 4, 4), (4, 3), (8, 6, 7), (1, ), (3, 6, 7)] , 3) == [(4, 3), (1,)]"
    ]
  },
  {
    "mbpp_id": 197,
    "problem_statement": "Write a function to perform the exponentiation of the given two tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_exponentio(tuple_a, tuple_b):\n    result = []\n    for i in range(len(tuple_a)):\n        result.append(pow(tuple_a[i], tuple_b[i]))\n    return tuple(result)\n\n# Test cases\nprint(find_exponentio((10, 4, 5, 6), (5, 6, 7, 5))) # Expected output: (100000, 4096, 78125, 7776)\nprint(find_exponentio((11, 5, 6, 7), (6, 7, 8, 6))) # Expected output: (1771561, 78125, 1679616, 117649)\nprint(find_exponentio((12, 6, 7, 8), (7, 8, 9, 7))) # Expected output: (35831808, 1679616, 40353607, 2097152)",
    "test_cases": [
      "assert find_exponentio((10, 4, 5, 6), (5, 6, 7, 5)) == (100000, 4096, 78125, 7776)",
      "assert find_exponentio((11, 5, 6, 7), (6, 7, 8, 6)) == (1771561, 78125, 1679616, 117649)",
      "assert find_exponentio((12, 6, 7, 8), (7, 8, 9, 7)) == (35831808, 1679616, 40353607, 2097152)"
    ]
  },
  {
    "mbpp_id": 198,
    "problem_statement": "Write a function to find the largest triangle that can be inscribed in an ellipse.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef largest_triangle(a, b):\n    # Calculate the semi-major axis and semi-minor axis of the ellipse\n    c = max(a, b)\n    d = min(a, b)\n    \n    # Calculate the area of the ellipse using its major and minor axes\n    area_ellipse = math.pi * a * b\n    \n    # The maximum area of a triangle inscribed in an ellipse is when the triangle is right-angled at the point on the ellipse farthest from the center.\n    # For a circle, the diameter is twice the radius, so for an ellipse with a=b, the diameter is 2*sqrt(b^2), and we divide it by sqrt(2) because of the ratio between ellipse axes.\n    area_right_triangle = (area_ellipse / 2) / math.sqrt(2)\n    \n    return area_right_triangle",
    "test_cases": [
      "assert largest_triangle(4,2)==10.392304845413264",
      "assert largest_triangle(5,7)==4.639421805988064",
      "assert largest_triangle(9,1)==105.2220865598093"
    ]
  },
  {
    "mbpp_id": 199,
    "problem_statement": "Write a python function to find highest power of 2 less than or equal to given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'math' is not defined",
      "Test 2: FAIL - name 'math' is not defined",
      "Test 3: FAIL - name 'math' is not defined"
    ],
    "generated_code": "def highest_Power_of_2(n):\n    # Use math.log2 to calculate the base-2 logarithm of n and then take the floor of it.\n    # Multiply this value with 2 to get the highest power of 2 less than or equal to n.\n    return int(n / 2 ** round(math.log2(n)))",
    "test_cases": [
      "assert highest_Power_of_2(10) == 8",
      "assert highest_Power_of_2(19) == 16",
      "assert highest_Power_of_2(32) == 32"
    ]
  },
  {
    "mbpp_id": 200,
    "problem_statement": "Write a function to find all index positions of the maximum values in a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def position_max(nums):\n    \"\"\"\n    Finds and returns the indices of all occurrences of the maximum value in a list.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    list: A list containing the indices of all maximum values in the input list.\n    \"\"\"\n    max_val = max(nums)\n    return [index for index, num in enumerate(nums) if num == max_val]\n\n# Check function with provided data points\nprint(position_max([12,33,23,10,67,89,45,667,23,12,11,10,54])) # Should print: [7]\nprint(position_max([1,2,2,2,4,4,4,5,5,5,5])) # Should print: [7,8,9,10]\nprint(position_max([2,1,5,6,8,3,4,9,10,11,8,12])) # Should print: [11]",
    "test_cases": [
      "assert position_max([12,33,23,10,67,89,45,667,23,12,11,10,54])==[7]",
      "assert position_max([1,2,2,2,4,4,4,5,5,5,5])==[7,8,9,10]",
      "assert position_max([2,1,5,6,8,3,4,9,10,11,8,12])==[11]"
    ]
  },
  {
    "mbpp_id": 201,
    "problem_statement": "Write a python function to check whether the elements in a list are same or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def chkList(lst):\n    # Check if all elements in the list are the same\n    first_element = lst[0]\n    for item in lst:\n        if item != first_element:\n            return False\n    return True",
    "test_cases": [
      "assert chkList(['one','one','one']) == True",
      "assert chkList(['one','Two','Three']) == False",
      "assert chkList(['bigdata','python','Django']) == False"
    ]
  },
  {
    "mbpp_id": 202,
    "problem_statement": "Write a function to remove even characters in a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: invalid literal for int() with base 10: 'p'"
    ],
    "generated_code": "def remove_even(s):\n    # Initialize an empty string to store odd characters\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in s:\n        # Check if the character is not even using modulo operation\n        if int(char) % 2 != 0:\n            # If it's odd, append it to the result string\n            result += char\n    \n    return result\n\n# Test case 1\nassert remove_even(\"python\") == \"pto\"\n# Test case 2\nassert remove_even(\"program\") == \"porm\"\n# Test case 3\nassert remove_even(\"language\") == \"lnug\"",
    "test_cases": [
      "assert remove_even(\"python\")==(\"pto\")",
      "assert remove_even(\"program\")==(\"porm\")",
      "assert remove_even(\"language\")==(\"lnug\")"
    ]
  },
  {
    "mbpp_id": 203,
    "problem_statement": "Write a python function to find the hamming distance between given two integers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def hamming_Distance(x, y):\n    xor_result = x ^ y\n    distance = 0\n    while xor_result:\n        # Count the number of '1's in the current result\n        distance += xor_result & 1\n        # Shift right by one bit position\n        xor_result >>= 1\n    return distance",
    "test_cases": [
      "assert hamming_Distance(4,8) == 2",
      "assert hamming_Distance(2,4) == 2",
      "assert hamming_Distance(1,2) == 2"
    ]
  },
  {
    "mbpp_id": 204,
    "problem_statement": "Write a python function to count the occurrence of a given character in a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count(s, char):\n    # Initialize counter\n    count = 0\n    \n    # Loop through each character in the string\n    for c in s:\n        if c == char:\n            count += 1\n            \n    return count",
    "test_cases": [
      "assert count(\"abcc\",\"c\") == 2",
      "assert count(\"ababca\",\"a\") == 3",
      "assert count(\"mnmm0pm\",\"m\") == 4"
    ]
  },
  {
    "mbpp_id": 205,
    "problem_statement": "Write a function to find the inversions of tuple elements in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "def inversion_elements(tup):\n    \"\"\"\n    Returns a new tuple where each element is the difference between the original element and its index.\n    \n    Parameters:\n    tup (tuple): A tuple of integers.\n    \n    Returns:\n    tuple: A tuple with elements being differences between each element of the input tuple and their indices.\n    \"\"\"\n    result = []\n    for i, num in enumerate(tup):\n        result.append(num - i)\n    return tuple(result)\n\n# Test Cases\nassert inversion_elements((7, 8, 9, 1, 10, 7)) == (-8, -9, -10, -1, -11, -8), \"Test case 1 failed\"\nassert inversion_elements((2, 4, 5, 6, 1, 7)) == (-3, -5, -6, -7, -2, -8), \"Test case 2 failed\"\nassert inversion_elements((8, 9, 11, 14, 12, 13)) == (-9, -10, -12, -15, -13, -14), \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert inversion_elements((7, 8, 9, 1, 10, 7)) == (-8, -9, -10, -2, -11, -8)",
      "assert inversion_elements((2, 4, 5, 6, 1, 7)) == (-3, -5, -6, -7, -2, -8)",
      "assert inversion_elements((8, 9, 11, 14, 12, 13)) == (-9, -10, -12, -15, -13, -14)"
    ]
  },
  {
    "mbpp_id": 206,
    "problem_statement": "Write a function to perform the adjacent element concatenation in the given tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def concatenate_elements(tuples_list):\n    # Initialize an empty list to store concatenated strings\n    result = []\n    \n    # Iterate through each tuple in the input list\n    for t in tuples_list:\n        # Concatenate all elements of the current tuple and append to the result list\n        result.append(\" \".join(t))\n    \n    return result",
    "test_cases": [
      "assert concatenate_elements((\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\")) == ('DSP IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL UTS')",
      "assert concatenate_elements((\"RES \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"QESR\")) == ('RES IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL QESR')",
      "assert concatenate_elements((\"MSAM\", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"SKD\")) == ('MSAMIS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL SKD')"
    ]
  },
  {
    "mbpp_id": 207,
    "problem_statement": "Write a function to count the longest repeating subsequences such that the two subsequences don’t have same string characters at same positions.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_longest_repeating_subseq(s):\n    max_len = 0\n    n = len(s)\n    \n    for i in range(n):\n        temp_str = \"\"\n        j = i\n        \n        while True:\n            temp_str += s[j]\n            \n            if s[i] == s[j]:\n                break\n                \n            elif len(temp_str) > max_len:\n                max_len = len(temp_str)\n                \n            j += 1\n            \n    return max_len",
    "test_cases": [
      "assert find_longest_repeating_subseq(\"AABEBCDD\") == 3",
      "assert find_longest_repeating_subseq(\"aabb\") == 2",
      "assert find_longest_repeating_subseq(\"aab\") == 1"
    ]
  },
  {
    "mbpp_id": 208,
    "problem_statement": "Write a function to check the given decimal with a precision of 2 by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef is_decimal(decimal_str):\n    # Regex pattern to match a decimal number with exactly two digits after the decimal point\n    pattern = r'^[+-]?(\\d+(\\.\\d{1,2})?)$'\n    \n    # Check if the input matches the pattern\n    return bool(re.match(pattern, decimal_str))",
    "test_cases": [
      "assert is_decimal('123.11') == True",
      "assert is_decimal('0.21') == True",
      "assert is_decimal('123.1214') == False"
    ]
  },
  {
    "mbpp_id": 209,
    "problem_statement": "Write a function to delete the smallest element from the given heap and then insert a new item.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def heap_replace(heap, new_item):\n    \"\"\"\n    Deletes the smallest element in the given heap represented as a list,\n    then inserts the new_item into the heap.\n    \n    :param heap: List representing the heap with elements stored at index 0\n                 for simplicity of deletion process.\n    :param new_item: The new item to be inserted into the heap after deletion.\n    :return: Modified heap with updated position of the removed element.\n    \"\"\"\n    # Deleting the smallest element from the heap\n    deleted_element = min(heap)\n    del heap[heap.index(min(heap))]\n    \n    # Inserting the new item into the heap\n    if len(heap) > 0:\n        heap.append(new_item)\n        # Maintaining max-heap property by applying sift down operation\n        i = len(heap) - 1\n        while i > 0:\n            parent_idx = (i - 1) // 2\n            if heap[i] < heap[parent_idx]:\n                heap[i], heap[parent_idx] = heap[parent_idx], heap[i]\n                i = parent_idx\n            else:\n                break\n    \n    return heap\n\n# Test Cases\nprint(heap_replace([25, 44, 68, 21, 39, 23, 89], 21))   # Expected output: [21, 25, 23, 44, 39, 68, 89]\nprint(heap_replace([25, 44, 68, 21, 39, 23, 89], 110))  # Expected output: [23, 25, 68, 44, 39, 110, 89]\nprint(heap_replace([25, 44, 68, 21, 39, 23, 89], 500))  # Expected output: [23, 25, 68, 44, 39, 500, 89]",
    "test_cases": [
      "assert heap_replace( [25, 44, 68, 21, 39, 23, 89],21)==[21, 25, 23, 44, 39, 68, 89]",
      "assert heap_replace([25, 44, 68, 21, 39, 23, 89],110)== [23, 25, 68, 44, 39, 110, 89]",
      "assert heap_replace([25, 44, 68, 21, 39, 23, 89],500)==[23, 25, 68, 44, 39, 500, 89]"
    ]
  },
  {
    "mbpp_id": 210,
    "problem_statement": "Write a function to check that the given string contains only a certain set of characters(in this case a-z, a-z and 0-9) by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef is_allowed_specific_char(s):\n    # Define the regular expression pattern for allowed characters.\n    pattern = '^[a-zA-Z0-9]+$'\n    \n    # Use the re.match() function to check if the entire string matches the pattern.\n    result = re.match(pattern, s)\n    \n    # If match found, return True; otherwise, return False.\n    return bool(result)\n\n# Test cases to verify the correctness of the solution.\nassert is_allowed_specific_char(\"ABCDEFabcdef123450\") == True\nassert is_allowed_specific_char(\"*&%@#!}{\") == False\nassert is_allowed_specific_char(\"HELLOhowareyou98765\") == True",
    "test_cases": [
      "assert is_allowed_specific_char(\"ABCDEFabcdef123450\") == True",
      "assert is_allowed_specific_char(\"*&%@#!}{\") == False",
      "assert is_allowed_specific_char(\"HELLOhowareyou98765\") == True"
    ]
  },
  {
    "mbpp_id": 211,
    "problem_statement": "Write a python function to count numbers whose oth and nth bits are set.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - count_Num() missing 1 required positional argument: 'n'",
      "Test 2: FAIL - count_Num() missing 1 required positional argument: 'n'",
      "Test 3: FAIL - count_Num() missing 1 required positional argument: 'n'"
    ],
    "generated_code": "def count_Num(o, n):\n    # Initialize a counter variable\n    count = 0\n    \n    # Loop through all integers from 1 to 2^n - 1\n    for i in range(1, 2**n):\n        # Check if both the ith bit and the n-th bit of i is set (equal to 1)\n        if ((i & (1 << (o-1))) > 0 and (i & (1 << (n-1))) > 0):\n            count += 1\n            \n    return count",
    "test_cases": [
      "assert count_Num(2) == 1",
      "assert count_Num(3) == 2",
      "assert count_Num(1) == 1"
    ]
  },
  {
    "mbpp_id": 212,
    "problem_statement": "Write a python function to find the sum of fourth power of n natural numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def fourth_Power_Sum(n):\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Calculate the sum of fourth powers of first 'n' natural numbers\n    for i in range(1, n + 1):\n        total_sum += pow(i, 4)\n    \n    return total_sum",
    "test_cases": [
      "assert fourth_Power_Sum(2) == 17",
      "assert fourth_Power_Sum(4) == 354",
      "assert fourth_Power_Sum(6) == 2275"
    ]
  },
  {
    "mbpp_id": 213,
    "problem_statement": "Write a function to perform the concatenation of two string tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def concatenate_strings(str_tuple1, str_tuple2):\n    # Concatenate the strings in each tuple separately and then combine them into one result\n    result = [f\"{item1}{item2}\" for item1, item2 in zip(str_tuple1, str_tuple2)]\n    return tuple(result)\n\n# Test cases\nprint(concatenate_strings((\"Manjeet\", \"Nikhil\", \"Akshat\"), (\" Singh\", \" Meherwal\", \" Garg\")))",
    "test_cases": [
      "assert concatenate_strings((\"Manjeet\", \"Nikhil\", \"Akshat\"), (\" Singh\", \" Meherwal\", \" Garg\")) == ('Manjeet Singh', 'Nikhil Meherwal', 'Akshat Garg')",
      "assert concatenate_strings((\"Shaik\", \"Ayesha\", \"Sanya\"), (\" Dawood\", \" Begum\", \" Singh\")) == ('Shaik Dawood', 'Ayesha Begum', 'Sanya Singh')",
      "assert concatenate_strings((\"Harpreet\", \"Priyanka\", \"Muskan\"), (\"Kour\", \" Agarwal\", \"Sethi\")) == ('HarpreetKour', 'Priyanka Agarwal', 'MuskanSethi')"
    ]
  },
  {
    "mbpp_id": 214,
    "problem_statement": "Write a function to convert radians to degrees.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def degree_radian(radians):\n    \"\"\"\n    Convert radians to degrees.\n    \n    Args:\n    radians (float): The angle in radians to be converted.\n    \n    Returns:\n    float: The angle in degrees.\n    \"\"\"\n    return radians * 180 / 3.141592653589793",
    "test_cases": [
      "assert degree_radian(90)==5156.620156177409",
      "assert degree_radian(60)==3437.746770784939",
      "assert degree_radian(120)==6875.493541569878"
    ]
  },
  {
    "mbpp_id": 215,
    "problem_statement": "Write a function to decode a run-length encoded given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - '>' not supported between instances of 'list' and 'int'",
      "Test 2: FAIL - '>' not supported between instances of 'str' and 'int'",
      "Test 3: FAIL - '>' not supported between instances of 'str' and 'int'"
    ],
    "generated_code": "def decode_list(lst):\n    result = []\n    for i in range(0, len(lst), 2):\n        count = lst[i]\n        item = lst[i+1]\n        while count > 0:\n            result.append(item)\n            count -= 1\n    return result",
    "test_cases": [
      "assert decode_list([[2, 1], 2, 3, [2, 4], 5,1])==[1,1,2,3,4,4,5,1]",
      "assert decode_list(['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y'])==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', 'l', 'l', 'y']",
      "assert decode_list(['p', 'y', 't', 'h', 'o', 'n'])==['p', 'y', 't', 'h', 'o', 'n']"
    ]
  },
  {
    "mbpp_id": 216,
    "problem_statement": "Write a function to check if a nested list is a subset of another nested list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - 'int' object is not iterable",
      "Test 2: FAIL - 'int' object is not iterable",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_subset_list(subset_list, main_list):\n    for sublist in subset_list:\n        found = False\n        for element in sublist:\n            for inner_list in main_list:\n                if isinstance(inner_list, list) and all(item in inner_list for item in element):\n                    found = True\n                    break\n            if not found:\n                return False\n        if not found:\n            return False\n    return True",
    "test_cases": [
      "assert check_subset_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==False",
      "assert check_subset_list([[2, 3, 1], [4, 5], [6, 8]],[[4, 5], [6, 8]])==True",
      "assert check_subset_list([['a', 'b'], ['e'], ['c', 'd']],[['g']])==False"
    ]
  },
  {
    "mbpp_id": 217,
    "problem_statement": "Write a python function to find the first repeated character in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def first_Repeated_Char(s):\n    char_map = {}\n    for char in s:\n        if char in char_map:\n            return char\n        else:\n            char_map[char] = True\n    return None",
    "test_cases": [
      "assert first_Repeated_Char(\"Google\") == \"o\"",
      "assert first_Repeated_Char(\"data\") == \"a\"",
      "assert first_Repeated_Char(\"python\") == '\\0'"
    ]
  },
  {
    "mbpp_id": 218,
    "problem_statement": "Write a python function to find the minimum operations required to make two numbers equal.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_Operations(x, y):\n    # Calculate the difference between x and y\n    diff = abs(x - y)\n    \n    # If both numbers are even, subtract each number from its complement to reach zero\n    if diff % 2 == 0:\n        return diff // 2\n    \n    # If one number is odd and the other is even, subtract the smaller number from the larger until they become equal\n    else:\n        if x > y:\n            x -= y\n        elif x < y:\n            y -= x\n        \n        while x != y:\n            if x > y:\n                x -= y\n            elif x < y:\n                y -= x\n            \n            if x == y:\n                break\n        \n        return diff - x",
    "test_cases": [
      "assert min_Operations(2,4) == 1",
      "assert min_Operations(4,10) == 4",
      "assert min_Operations(1,4) == 3"
    ]
  },
  {
    "mbpp_id": 219,
    "problem_statement": "Write a function to extract maximum and minimum k elements in the given tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def extract_min_max(input_tuple, k):\n    \"\"\"\n    Extracts the top k smallest and largest numbers from the input_tuple.\n    \n    :param input_tuple: Tuple of integers\n    :param k: Number of minimum and maximum elements to extract\n    :return: A tuple containing the k smallest and k largest elements as specified\n    \"\"\"\n    # Extracting the k smallest elements\n    min_elements = sorted(input_tuple)[:k]\n    # Extracting the k largest elements\n    max_elements = sorted(input_tuple, reverse=True)[:k]\n    # Combining both lists into one list\n    all_elements = min_elements + max_elements\n    # Sorting the combined list in ascending order for readability\n    all_elements.sort()\n    return tuple(all_elements)\n\n# Check function with provided data points\nassert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)\nassert extract_min_max((4, 5, 6, 1, 2, 7), 3) == (1, 2, 4, 5, 6, 7)\nassert extract_min_max((2, 3, 4, 8, 9, 11, 7), 4) == (2, 3, 4, 7, 8, 9, 11)\nprint(\"All tests passed!\")",
    "test_cases": [
      "assert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)",
      "assert extract_min_max((4, 5, 6, 1, 2, 7), 3) == (1, 2, 4, 5, 6, 7)",
      "assert extract_min_max((2, 3, 4, 8, 9, 11, 7), 4) == (2, 3, 4, 7, 8, 9, 11)"
    ]
  },
  {
    "mbpp_id": 220,
    "problem_statement": "Write a function to replace maximum n occurrences of spaces, commas, or dots with a colon.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef replace_max_specialchar(text,n=1):\n    # Replace multiple spaces and/or commas and/or dots with a single colon\n    pattern = r'([ ,\\.\\s]+)'\n    return re.sub(pattern, lambda x: ':'.join(x.group(0).split()), text, count=n)\n\n# Test cases\nprint(replace_max_specialchar('Python language, Programming language.'))  # Expected: 'Python:language: Programming language.'\nprint(replace_max_specialchar('a b c,d e f'))  # Expected: 'a:b:c:d e f'\nprint(replace_max_specialchar('ram reshma,ram rahim', 1))  # Expected: 'ram:reshma,ram rahim'",
    "test_cases": [
      "assert replace_max_specialchar('Python language, Programming language.',2)==('Python:language: Programming language.')",
      "assert replace_max_specialchar('a b c,d e f',3)==('a:b:c:d e f')",
      "assert replace_max_specialchar('ram reshma,ram rahim',1)==('ram:reshma,ram rahim')"
    ]
  },
  {
    "mbpp_id": 221,
    "problem_statement": "Write a python function to find the first even number in a given list of numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def first_even(numbers):\n    for num in numbers:\n        if num % 2 == 0:\n            return num",
    "test_cases": [
      "assert first_even ([1, 3, 5, 7, 4, 1, 6, 8]) == 4",
      "assert first_even([2, 3, 4]) == 2",
      "assert first_even([5, 6, 7]) == 6"
    ]
  },
  {
    "mbpp_id": 222,
    "problem_statement": "Write a function to check if all the elements in tuple have same data type or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_type(tup):\n    types = [type(i) for i in tup]\n    return len(set(types)) == 1",
    "test_cases": [
      "assert check_type((5, 6, 7, 3, 5, 6) ) == True",
      "assert check_type((1, 2, \"4\") ) == False",
      "assert check_type((3, 2, 1, 4, 5) ) == True"
    ]
  },
  {
    "mbpp_id": 223,
    "problem_statement": "Write a function to check for majority element in the given sorted array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_majority(nums, n, m):\n    count = 0\n    current_number = nums[0]\n    \n    # Check if the first number is equal to m and also checks if there's more than one occurrence of it.\n    if nums.count(current_number) > 1:\n        return True\n    \n    for num in nums:\n        if num == m:\n            count += 1\n        \n        # Resetting count when a different number is encountered.\n        else:\n            count = 0\n        \n        # If at any point the count exceeds n, then the number is not a majority.\n        if count >= n:\n            return True\n    \n    return False",
    "test_cases": [
      "assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True",
      "assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False",
      "assert is_majority([1, 1, 1, 2, 2], 5, 1) == True"
    ]
  },
  {
    "mbpp_id": 224,
    "problem_statement": "Write a python function to count set bits of a given number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_Set_Bits(n):\n    \"\"\"\n    This function takes an integer n and returns the number of 1s in its binary representation.\n    \n    Args:\n    - n (int): The integer whose set bits are to be counted\n    \n    Returns:\n    - int: Number of set bits in n\n    \"\"\"\n    # Initialize counter for set bits\n    count = 0\n    \n    # Loop until n becomes zero\n    while n > 0:\n        # If bit is set, increment counter\n        if n & 1 == 1:\n            count += 1\n        # Right shift n by one bit to process next bit\n        n >>= 1\n    \n    return count",
    "test_cases": [
      "assert count_Set_Bits(2) == 1",
      "assert count_Set_Bits(4) == 1",
      "assert count_Set_Bits(6) == 2"
    ]
  },
  {
    "mbpp_id": 225,
    "problem_statement": "Write a python function to find the minimum element in a sorted and rotated array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_Min(arr, left, right):\n    # If there is only one element, return it as the minimum\n    if left == right:\n        return arr[left]\n    \n    # If the first element is greater than the last element, the array is not rotated\n    if arr[left] > arr[right]:\n        return max(arr)\n    \n    # Calculate the middle index\n    mid = (left + right) // 2\n    \n    # Check if the middle element is the minimum element\n    if mid < right and arr[mid+1] < arr[mid]:\n        return arr[mid+1]\n    elif mid > left and arr[mid-1] > arr[mid]:\n        return arr[mid]\n    \n    # Decide whether to go to the left half or the right half\n    if arr[left] <= arr[mid]:\n        return find_Min(arr, mid + 1, right)\n    else:\n        return find_Min(arr, left, mid)\n\n# Example usage\nprint(find_Min([1,2,3,4,5],0,4))  # Output: 1\nprint(find_Min([4,6,8],0,2))      # Output: 4\nprint(find_Min([2,3,5,7,9],0,4))  # Output: 2",
    "test_cases": [
      "assert find_Min([1,2,3,4,5],0,4) == 1",
      "assert find_Min([4,6,8],0,2) == 4",
      "assert find_Min([2,3,5,7,9],0,4) == 2"
    ]
  },
  {
    "mbpp_id": 226,
    "problem_statement": "Write a python function to remove the characters which have odd index values of a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def odd_values_string(input_str):\n    # Initialize an empty list to store characters at even indices\n    result = []\n    \n    # Iterate over the input string with steps of 2 to access elements at even indices\n    for i in range(0, len(input_str), 2):\n        # Append each character at an even index to the result list\n        result.append(input_str[i])\n    \n    # Join the list into a string and return it\n    return ''.join(result)\n\n# Test cases\nprint(odd_values_string('abcdef'))  # Expected output: \"ace\"\nprint(odd_values_string('python'))  # Expected output: \"pto\"\nprint(odd_values_string('data'))    # Expected output: \"dt\"",
    "test_cases": [
      "assert odd_values_string('abcdef') == 'ace'",
      "assert odd_values_string('python') == 'pto'",
      "assert odd_values_string('data') == 'dt'"
    ]
  },
  {
    "mbpp_id": 227,
    "problem_statement": "Write a function to find minimum of three numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def min_of_three(a, b, c):\n    # Return the minimum value among the three given numbers\n    return min(a, b, c)",
    "test_cases": [
      "assert min_of_three(10,20,0)==0",
      "assert min_of_three(19,15,18)==15",
      "assert min_of_three(-10,-20,-30)==-30"
    ]
  },
  {
    "mbpp_id": 228,
    "problem_statement": "Write a python function to check whether all the bits are unset in the given range or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def all_Bits_Set_In_The_Given_Range(n, start_bit, end_bit):\n    \"\"\"\n    Check if all the bits from 'start_bit' to 'end_bit' inclusive in an integer n are unset.\n    \n    Parameters:\n    - n (int): The integer to be checked.\n    - start_bit (int): The starting bit index for checking.\n    - end_bit (int): The ending bit index for checking.\n    \n    Returns:\n    - bool: True if all the bits from 'start_bit' to 'end_bit' are unset, otherwise False.\n    \"\"\"\n    mask = ((1 << (end_bit + 1)) - 1) & (-1 << start_bit)\n    return (n & mask) == 0",
    "test_cases": [
      "assert all_Bits_Set_In_The_Given_Range(4,1,2) == True",
      "assert all_Bits_Set_In_The_Given_Range(17,2,4) == True",
      "assert all_Bits_Set_In_The_Given_Range(39,4,6) == False"
    ]
  },
  {
    "mbpp_id": 229,
    "problem_statement": "Write a function to re-arrange the elements of the given array so that all negative elements appear before positive ones.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def re_arrange_array(arr, n):\n    # Separate negative and non-negative numbers into two lists\n    negative = [num for num in arr if num < 0]\n    non_negative = [num for num in arr if num >= 0]\n\n    # Concatenate negative numbers first, then add remaining non-negative numbers at the end\n    result = negative + non_negative\n    return result[:n]  # Return the sublist of length 'n' up to the last element\n\n\n# Example usage:\nprint(re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9))  # Output: [-1, -3, -7, 4, 5, 6, 2, 8, 9]\nprint(re_arrange_array([12, -14, -26, 13, 15], 5))          # Output: [-14, -26, 12, 13, 15]\nprint(re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7)) # Output: [-42, -39, -78, 10, 24, 36, 85]",
    "test_cases": [
      "assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]",
      "assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]",
      "assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]"
    ]
  },
  {
    "mbpp_id": 230,
    "problem_statement": "Write a function to replace blank spaces with any character in a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def replace_blank(s, c):\n    return s.replace(' ', c)",
    "test_cases": [
      "assert replace_blank(\"hello people\",'@')==(\"hello@people\")",
      "assert replace_blank(\"python program language\",'$')==(\"python$program$language\")",
      "assert replace_blank(\"blank space\",\"-\")==(\"blank-space\")"
    ]
  },
  {
    "mbpp_id": 231,
    "problem_statement": "Write a function to find the maximum sum in the given right triangle of numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: max() arg is an empty sequence"
    ],
    "generated_code": "def max_sum(triangle, n):\n    \"\"\"\n    Finds the maximum sum from top to bottom in a right triangle of numbers.\n    \n    Parameters:\n    triangle (List[List[int]]): A list of lists representing the rows of the triangle.\n    n (int): The number of rows in the triangle.\n    \n    Returns:\n    int: The maximum sum possible from top to bottom.\n    \"\"\"\n    # Initialize the result array with the same length as the input triangle but filled with -inf\n    result = [-float('inf')] * (n + 1)\n    \n    for i in range(n):\n        # Iterate through each element in the current row and update the result array accordingly\n        for j in range(i + 1):\n            if j == 0:\n                result[j] = triangle[i][j] + max(result[0:j])\n            elif j == i:\n                result[j] = triangle[i][j] + max(result[j:], default=0)\n            else:\n                result[j] = triangle[i][j] + max(result[j], result[j-1])\n                \n    # Return the maximum value found in the result array\n    return max(result)\n\n# Check function with provided data points\nassert max_sum([[1],[2,1],[3,3,2]], 3) == 6\nassert max_sum([[1],[1,2],[4,1,12]], 3) == 15\nassert max_sum([[2],[3,2],[13,23,12]], 3) == 28",
    "test_cases": [
      "assert max_sum([[1], [2,1], [3,3,2]], 3) == 6",
      "assert max_sum([[1], [1, 2], [4, 1, 12]], 3) == 15 ",
      "assert max_sum([[2], [3,2], [13,23,12]], 3) == 28"
    ]
  },
  {
    "mbpp_id": 232,
    "problem_statement": "Write a function to get the n largest items from a dataset.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def larg_nnum(data, n):\n    data.sort(reverse=True)\n    return data[:n]\n\n# Test Cases\nprint(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2)) # Expected output: [100, 90]\nprint(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 5)) # Expected output: [100, 90, 80, 70, 60]\nprint(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 3)) # Expected output: [100, 90, 80]",
    "test_cases": [
      "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[100,90]",
      "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5)==[100,90,80,70,60]",
      "assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3)==[100,90,80]"
    ]
  },
  {
    "mbpp_id": 233,
    "problem_statement": "Write a function to find the lateral surface area of a cylinder.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def lateralsuface_cylinder(radius, height):\n    return 2 * 3.1415 * radius * height",
    "test_cases": [
      "assert lateralsuface_cylinder(10,5)==314.15000000000003",
      "assert lateralsuface_cylinder(4,5)==125.66000000000001",
      "assert lateralsuface_cylinder(4,10)==251.32000000000002"
    ]
  },
  {
    "mbpp_id": 234,
    "problem_statement": "Write a function to find the volume of a cube.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def volume_cube(side_length):\n    return side_length ** 3",
    "test_cases": [
      "assert volume_cube(3)==27",
      "assert volume_cube(2)==8",
      "assert volume_cube(5)==125"
    ]
  },
  {
    "mbpp_id": 235,
    "problem_statement": "Write a python function to set all even bits of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "def even_bit_set_number(number):\n    \"\"\"\n    This function takes an integer and returns its value with all even bits set.\n    \n    :param number: Integer representing the input number.\n    :return: Integer after setting all even bits in the original number.\n    \"\"\"\n    result = 0\n    while number > 0:\n        # Check if the least significant bit is even (i.e., 0)\n        if number & 1 == 0:\n            # Set the least significant bit to 1 and move right one position\n            result |= 1\n        # Shift the number to check the next least significant bit\n        number >>= 1\n    return result\n\n# Test cases to verify the correctness of the solution\nassert even_bit_set_number(10) == 10, \"Test case 1 failed\"\nassert even_bit_set_number(20) == 30, \"Test case 2 failed\"\nassert even_bit_set_number(30) == 30, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert even_bit_set_number(10) == 10",
      "assert even_bit_set_number(20) == 30",
      "assert even_bit_set_number(30) == 30"
    ]
  },
  {
    "mbpp_id": 236,
    "problem_statement": "Write a python function to count the maximum number of equilateral triangles that can be formed within a given equilateral triangle.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'No_of_Triangle' is not defined",
      "Test 2: FAIL - name 'No_of_Triangle' is not defined",
      "Test 3: FAIL - name 'No_of_Triangle' is not defined"
    ],
    "generated_code": "def no_of_triangle(sides, n):\n    # Base case: if n is less than sides, no triangles can be formed with fewer sides.\n    if n < sides:\n        return -1\n    \n    # Calculate the total number of possible triangles for a given side length 's'\n    def calculate_triangles(side_length):\n        # Formula for calculating the number of equilateral triangles in an equilateral triangle based on its side length\n        num_triangles = (side_length * (side_length + 1)) // 2\n        return num_triangles\n    \n    # Sum up the number of triangles for each possible side length from 1 to sides-1\n    max_triangles = sum(calculate_triangles(i) for i in range(1, sides))\n    \n    return max_triangles",
    "test_cases": [
      "assert No_of_Triangle(4,2) == 7",
      "assert No_of_Triangle(4,3) == 3",
      "assert No_of_Triangle(1,3) == -1"
    ]
  },
  {
    "mbpp_id": 237,
    "problem_statement": "Write a function to check the occurrences of records which occur similar times in the given tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_occurences(tuples_list):\n    frequency_map = {}\n    \n    # Iterate through each tuple in the list\n    for tup in tuples_list:\n        key = tup[0], tup[1]  # Form the key as a tuple with first and second elements swapped\n        if key not in frequency_map:\n            frequency_map[key] = 1  # If key is new, initialize its count to 1\n        else:\n            frequency_map[key] += 1  # Increment the count if key already exists\n    \n    # Return the result as a dictionary where keys are tuples with swapped first and second elements and values are counts\n    return {key: value for key, value in frequency_map.items()}\n\n# Test cases\nprint(check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]))  # Expected output: {(1, 3): 2, (2, 5): 2, (3, 6): 1}\nprint(check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)]))  # Expected output: {(2, 4): 2, (3, 6): 2, (4, 7): 1}\nprint(check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)]))  # Expected output: {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}",
    "test_cases": [
      "assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}",
      "assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}",
      "assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}"
    ]
  },
  {
    "mbpp_id": 238,
    "problem_statement": "Write a python function to count number of non-empty substrings of a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def number_of_substrings(s):\n    \"\"\"\n    Counts the number of non-empty substrings of a given string.\n    \n    Args:\n    s (str): The input string for which non-empty substrings need to be counted.\n    \n    Returns:\n    int: The total number of non-empty substrings.\n    \"\"\"\n    if not isinstance(s, str) or len(s) == 0:\n        raise ValueError(\"Input must be a non-empty string\")\n\n    n = len(s)\n    result = n * (n + 1) // 2\n    return result",
    "test_cases": [
      "assert number_of_substrings(\"abc\") == 6",
      "assert number_of_substrings(\"abcd\") == 10",
      "assert number_of_substrings(\"abcde\") == 15"
    ]
  },
  {
    "mbpp_id": 239,
    "problem_statement": "Write a function to find the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_total_number_of_sequences(n, m):\n    total = 0\n    for i in range(m+1):\n        if i >= 2**(n-1): \n            break\n        count = 1\n        j = i * 2\n        while True:\n            if j > 0 and j <= m:\n                count += 1\n                j *= 2\n            else:\n                break\n        if j == 0 or j > m:\n            continue\n        total += count\n    return total\n\n# Test Cases\nprint(get_total_number_of_sequences(10, 4)) # Expected output: 4\nprint(get_total_number_of_sequences(5, 2))  # Expected output: 6\nprint(get_total_number_of_sequences(16, 3)) # Expected output: 84",
    "test_cases": [
      "assert get_total_number_of_sequences(10, 4) == 4",
      "assert get_total_number_of_sequences(5, 2) == 6",
      "assert get_total_number_of_sequences(16, 3) == 84"
    ]
  },
  {
    "mbpp_id": 240,
    "problem_statement": "Write a function to replace the last element of the list with another list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def replace_list(original_list, new_elements):\n    return original_list[:-1] + new_elements",
    "test_cases": [
      "assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]",
      "assert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,6,7,8]",
      "assert replace_list([\"red\",\"blue\",\"green\"],[\"yellow\"])==[\"red\",\"blue\",\"yellow\"]"
    ]
  },
  {
    "mbpp_id": 241,
    "problem_statement": "Write a function to generate a 3d array having each element as '*'.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - array_3d() takes 1 positional argument but 3 were given",
      "Test 2: FAIL - array_3d() takes 1 positional argument but 3 were given",
      "Test 3: FAIL - array_3d() takes 1 positional argument but 3 were given"
    ],
    "generated_code": "def array_3d(dims):\n    # Initialize an empty list of lists with dimensions 'dims'\n    return [['*' for _ in range(dims[2])] for _ in range(dims[0]) for __ in range(dims[1])]",
    "test_cases": [
      "assert array_3d(6,4,3)==[[['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']]]",
      "assert array_3d(5,3,4)==[[['*', '*', '*', '*', '*'], ['*', '*', '*', '*','*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'],['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*']]]",
      "assert array_3d(1,2,3)==[[['*'],['*']],[['*'],['*']],[['*'],['*']]]"
    ]
  },
  {
    "mbpp_id": 242,
    "problem_statement": "Write a function to count total characters in a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_charac(s):\n    return len(s)",
    "test_cases": [
      "assert count_charac(\"python programming\")==18",
      "assert count_charac(\"language\")==8",
      "assert count_charac(\"words\")==5"
    ]
  },
  {
    "mbpp_id": 243,
    "problem_statement": "Write a function to sort the given list based on the occurrence of first element of tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from collections import Counter\n\ndef sort_on_occurence(lst):\n    \"\"\"\n    This function takes a list of tuples and returns it sorted based on the count of the first elements in each tuple.\n    The tuples with the same first element maintain their original order as they appear in the input list.\n    \n    :param lst: List of tuples\n    :return: Sorted list of tuples\n    \n    Example:\n    >>> sort_on_occurence([(1, 'Jake'), (2, 'Bob'), (1, 'Cara')])\n    [(1, 'Jake', 'Cara', 2), (2, 'Bob', 1)]\n    \"\"\"\n    # Count occurrences of each first element\n    counts = {item[0]: len(list(filter(lambda x: x[0] == item[0], lst))) for item in lst}\n    # Sort items based on the number of occurrences, then lexicographically if occurrences are equal\n    lst.sort(key=lambda x: (-counts[x[0]], x))\n    return lst",
    "test_cases": [
      "assert sort_on_occurence([(1, 'Jake'), (2, 'Bob'), (1, 'Cara')]) == [(1, 'Jake', 'Cara', 2), (2, 'Bob', 1)]",
      "assert sort_on_occurence([('b', 'ball'), ('a', 'arm'), ('b', 'b'), ('a', 'ant')]) == [('b', 'ball', 'b', 2), ('a', 'arm', 'ant', 2)]",
      "assert sort_on_occurence([(2, 'Mark'), (3, 'Maze'), (2, 'Sara')]) == [(2, 'Mark', 'Sara', 2), (3, 'Maze', 1)]"
    ]
  },
  {
    "mbpp_id": 244,
    "problem_statement": "Write a python function to find the next perfect square greater than a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def next_Perfect_Square(n):\n    \"\"\"\n    Finds the smallest integer greater than 'n' whose square is divisible by 8.\n    \n    Parameters:\n    n (int): The input number for which we want to find the next perfect square.\n    \n    Returns:\n    int: The next perfect square greater than 'n'.\n    \"\"\"\n    while True:\n        n += 1\n        if n * n % 8 == 0:\n            return n * n",
    "test_cases": [
      "assert next_Perfect_Square(35) == 36",
      "assert next_Perfect_Square(6) == 9",
      "assert next_Perfect_Square(9) == 16"
    ]
  },
  {
    "mbpp_id": 245,
    "problem_statement": "Write a function to find the maximum sum of bi-tonic sub-sequence for the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_sum(arr, n):\n    dp = [arr[0]] * n\n    dp2 = [-float('inf')] * n\n    \n    # Compute minimum so far and store in dp2 \n    min_so_far = arr[0]\n    for i in range(1, n): \n        if arr[i] < min_so_far: \n            dp2[i] = min_so_far \n        else: \n            dp2[i] = arr[i]  \n        min_so_far = min(min_so_far, arr[i]) \n\n    max_ending_here = arr[0] \n    max_till_now = arr[0]\n\n    # Traverse through all nodes \n    for i in range(1, n): \n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        max_till_now = max(max_till_now, max_ending_here)\n\n        # Store the maximum sum ending at every node\n        if(dp2[i-1] > 0): \n            dp[i] = max(arr[i], max_till_now + arr[i]) \n        else: \n            dp[i] = max_ending_here  \n\n    return max_till_now",
    "test_cases": [
      "assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9], 9) == 194",
      "assert max_sum([80, 60, 30, 40, 20, 10], 6) == 210",
      "assert max_sum([2, 3 ,14, 16, 21, 23, 29, 30], 8) == 138"
    ]
  },
  {
    "mbpp_id": 246,
    "problem_statement": "Write a function for computing square roots using the babylonian method.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def babylonian_squareroot(n):\n    if n == 0:\n        return 0\n    x = n / 2\n    while True:\n        y = (x + n / x) / 2\n        if abs(y - x) < 0.000001:\n            return y\n        x = y",
    "test_cases": [
      "assert babylonian_squareroot(10)==3.162277660168379",
      "assert babylonian_squareroot(2)==1.414213562373095",
      "assert babylonian_squareroot(9)==3.0"
    ]
  },
  {
    "mbpp_id": 247,
    "problem_statement": "Write a function to find the longest palindromic subsequence in the given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def lps(s):\n    \"\"\"\n    Finds the length of the longest palindromic subsequence within a given string.\n    \n    Parameters:\n    s (str): The input string\n    \n    Returns:\n    int: Length of the longest palindromic subsequence\n    \"\"\"\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the table from bottom-right corner\n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i+1][j-1]\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n                \n    return dp[0][n-1]\n\n# Check function with provided data points\nassert lps(\"TENS FOR TENS\") == 5, \"Test case 1 failed\"\nassert lps(\"CARDIO FOR CARDS\") == 7, \"Test case 2 failed\"\nassert lps(\"PART OF THE JOURNEY IS PART\") == 9, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert lps(\"TENS FOR TENS\") == 5 ",
      "assert lps(\"CARDIO FOR CARDS\") == 7",
      "assert lps(\"PART OF THE JOURNEY IS PART\") == 9 "
    ]
  },
  {
    "mbpp_id": 248,
    "problem_statement": "Write a function to calculate the harmonic sum of n-1.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def harmonic_sum(n):\n    if n <= 1:\n        return 1\n    else:\n        return 1 / n + harmonic_sum(n - 1)",
    "test_cases": [
      "assert harmonic_sum(7) == 2.5928571428571425",
      "assert harmonic_sum(4) == 2.083333333333333",
      "assert harmonic_sum(19) == 3.547739657143682"
    ]
  },
  {
    "mbpp_id": 249,
    "problem_statement": "Write a function to find the intersection of two arrays using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def intersection_array(arr1, arr2):\n    return list(filter(lambda x: x in arr2, arr1))",
    "test_cases": [
      "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]",
      "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])==[3,5,7,9]",
      "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[10,20,30,40])==[10]"
    ]
  },
  {
    "mbpp_id": 250,
    "problem_statement": "Write a python function to count the occcurences of an element in a tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_X(tup, x):\n    # Initialize a counter for occurrences\n    count = 0\n    # Iterate through each item in the tuple\n    for item in tup:\n        # If the current item matches the target value, increment the counter\n        if item == x:\n            count += 1\n    # Return the total number of occurrences found\n    return count",
    "test_cases": [
      "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0",
      "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),10) == 3",
      "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),8) == 4"
    ]
  },
  {
    "mbpp_id": 251,
    "problem_statement": "Write a function to insert an element before each element of a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def insert_element(lst, elem):\n    for i in range(len(lst)):\n        lst.insert(i + 1, elem)\n    return lst\n\n# Test cases\nprint(insert_element(['Red', 'Green', 'Black'], 'c'))  # Output: ['c', 'Red', 'c', 'Green', 'c', 'Black']\nprint(insert_element(['python', 'java'], 'program'))   # Output: ['program', 'python', 'program', 'java']\nprint(insert_element(['happy', 'sad'], 'laugh'))       # Output: ['laugh', 'happy', 'laugh', 'sad']",
    "test_cases": [
      "assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black'] ",
      "assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java'] ",
      "assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad'] "
    ]
  },
  {
    "mbpp_id": 252,
    "problem_statement": "Write a python function to convert complex numbers to polar coordinates.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'convert' is not defined",
      "Test 2: FAIL - name 'convert' is not defined",
      "Test 3: FAIL - name 'convert' is not defined"
    ],
    "generated_code": "import cmath\n\ndef convert_complex_to_polar(complex_number):\n    \"\"\"\n    Converts a given complex number into its corresponding polar coordinates.\n    \n    Parameters:\n    complex_number (complex): The complex number to be converted.\n    \n    Returns:\n    tuple: A tuple containing two elements - magnitude and angle in radians.\n    \"\"\"\n    # Convert the complex number to polar form\n    result = cmath.polar(complex_number)\n    return result\n\n# Check function with provided data points\nprint(convert_complex_to_polar(1))   # Expected output: (1.0, 0.0)\nprint(convert_complex_to_polar(4))   # Expected output: (4.0, 0.0)\nprint(convert_complex_to_polar(5))   # Expected output: (5.0, 0.0)",
    "test_cases": [
      "assert convert(1) == (1.0, 0.0)",
      "assert convert(4) == (4.0,0.0)",
      "assert convert(5) == (5.0,0.0)"
    ]
  },
  {
    "mbpp_id": 253,
    "problem_statement": "Write a python function to count integers from a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_integer(lst):\n    return len([item for item in lst if isinstance(item, int)])\n\n# Test cases\nprint(count_integer([1, 2, 'abc', 1.2]))  # Output should be 2\nprint(count_integer([1, 2, 3]))           # Output should be 3\nprint(count_integer([1, 1.2, 4, 5.1]))    # Output should be 2",
    "test_cases": [
      "assert count_integer([1,2,'abc',1.2]) == 2",
      "assert count_integer([1,2,3]) == 3",
      "assert count_integer([1,1.2,4,5.1]) == 2"
    ]
  },
  {
    "mbpp_id": 254,
    "problem_statement": "Write a function to find all words starting with 'a' or 'e' in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef words_ae(input_string):\n    pattern = r'\\ba|\\be'\n    return [word for word in input_string.split() if re.match(pattern, word)]",
    "test_cases": [
      "assert words_ae(\"python programe\")==['ame']",
      "assert words_ae(\"python programe language\")==['ame','anguage']",
      "assert words_ae(\"assert statement\")==['assert', 'atement']"
    ]
  },
  {
    "mbpp_id": 255,
    "problem_statement": "Write a function to choose specified number of colours from three different colours and generate all the combinations with repetitions.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def combinations_colors(colors, n):\n    result = []\n    for i in range(len(colors)):\n        for j in range(i+1, len(colors)+1):\n            combination = tuple(colors[k] for k in range(i, j))\n            if len(combination) == n:\n                result.append(combination)\n    return result",
    "test_cases": [
      "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[('Red',), ('Green',), ('Blue',)]",
      "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],2)==[('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]",
      "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],3)==[('Red', 'Red', 'Red'), ('Red', 'Red', 'Green'), ('Red', 'Red', 'Blue'), ('Red', 'Green', 'Green'), ('Red', 'Green', 'Blue'), ('Red', 'Blue', 'Blue'), ('Green', 'Green', 'Green'), ('Green', 'Green', 'Blue'), ('Green', 'Blue', 'Blue'), ('Blue', 'Blue', 'Blue')]"
    ]
  },
  {
    "mbpp_id": 256,
    "problem_statement": "Write a python function to count the number of prime numbers less than a given non-negative number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Primes_nums(n):\n    if n <= 1:\n        return 0\n    is_prime = [True] * n\n    p = 2\n    while(p*p < n):\n        if(is_prime[p]):\n            for i in range(p*2, n, p):\n                is_prime[i] = False\n        p += 1\n    \n    count = sum(is_prime)\n    return count",
    "test_cases": [
      "assert count_Primes_nums(5) == 2",
      "assert count_Primes_nums(10) == 4",
      "assert count_Primes_nums(100) == 25"
    ]
  },
  {
    "mbpp_id": 257,
    "problem_statement": "Write a function to swap two numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def swap_numbers(x, y):\n    return (y, x)\n\ndef check_solution():\n    assert swap_numbers(10, 20) == (20, 10), \"Test case 1 failed\"\n    assert swap_numbers(15, 17) == (17, 15), \"Test case 2 failed\"\n    assert swap_numbers(100, 200) == (200, 100), \"Test case 3 failed\"\n    print(\"All test cases passed!\")\n\ncheck_solution()",
    "test_cases": [
      "assert swap_numbers(10,20)==(20,10)",
      "assert swap_numbers(15,17)==(17,15)",
      "assert swap_numbers(100,200)==(200,100)"
    ]
  },
  {
    "mbpp_id": 258,
    "problem_statement": "Write a function to find number of odd elements in the given list using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "count_odd = lambda nums: sum(1 for num in nums if num % 2 != 0)",
    "test_cases": [
      "assert count_odd([1, 2, 3, 5, 7, 8, 10])==4",
      "assert count_odd([10,15,14,13,-18,12,-20])==2",
      "assert count_odd([1, 2, 4, 8, 9])==2"
    ]
  },
  {
    "mbpp_id": 259,
    "problem_statement": "Write a function to maximize the given two tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def maximize_elements(tuple1, tuple2):\n    # Compare each element of both tuples and choose the maximum one from tuple1\n    max_tuple = tuple(max(item) for item in zip(*tuple1))\n    # Compare each element of both tuples and choose the maximum one from tuple2\n    result = tuple(max(max_tuple[i], item[1]) for i, item in enumerate(zip(*tuple2)))\n    return result",
    "test_cases": [
      "assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))",
      "assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))",
      "assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))"
    ]
  },
  {
    "mbpp_id": 260,
    "problem_statement": "Write a function to find the nth newman–shanks–williams prime number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "TIMEOUT"
    ],
    "generated_code": "import math\n\ndef is_newman_shanks_williams_prime(n):\n    def factorial(x):\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    if n < 1:\n        return None\n    \n    p = 3\n    g = 1\n    while True:\n        f = factorial(p - 1)\n        t = (p - 1) * (p - 2)\n        d = gcd(t, f)\n        \n        if d == 1:\n            g += 1\n        \n        if g >= n:\n            break\n            \n        p += 2\n    \n    return p - 1\n\n# Test cases\nprint(is_newman_shanks_williams_prime(3))  # Expected output: 7\nprint(is_newman_shanks_williams_prime(4))  # Expected output: 17\nprint(is_newman_shanks_williams_prime(5))  # Expected output: 41",
    "test_cases": [
      "assert newman_prime(3) == 7 ",
      "assert newman_prime(4) == 17",
      "assert newman_prime(5) == 41"
    ]
  },
  {
    "mbpp_id": 261,
    "problem_statement": "Write a function to perform mathematical division operation across the given tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def division_elements(tup1, tup2):\n    result = [(a // b) for a, b in zip(tup1, tup2)]\n    return tuple(result)\n\n# Test cases\nprint(division_elements((10, 4, 6, 9), (5, 2, 3, 3)))  # Expected output: (2, 2, 2, 3)\nprint(division_elements((12, 6, 8, 16), (6, 3, 4, 4)))  # Expected output: (2, 2, 2, 4)\nprint(division_elements((20, 14, 36, 18), (5, 7, 6, 9)))  # Expected output: (4, 2, 6, 2)",
    "test_cases": [
      "assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)",
      "assert division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)",
      "assert division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)"
    ]
  },
  {
    "mbpp_id": 262,
    "problem_statement": "Write a function to split a given list into two parts where the length of the first part of the list is given.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def split_two_parts(lst, k):\n    return lst[:k], lst[k:]",
    "test_cases": [
      "assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])",
      "assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])",
      "assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])"
    ]
  },
  {
    "mbpp_id": 263,
    "problem_statement": "Write a function to merge two dictionaries.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def merge_dict(dict1, dict2):\n    return {**dict1, **dict2}\n\n# Test cases\nprint(merge_dict({'a': 100, 'b': 200}, {'x': 300, 'y': 200})) # Output: {'x': 300, 'y': 200, 'a': 100, 'b': 200}\nprint(merge_dict({'a':900,'b':900,'d':900}, {'a':900,'b':900,'d':900})) # Output: {'a':900,'b':900,'d':900,'a':900,'b':900,'d':900}\nprint(merge_dict({'a':10,'b':20}, {'x':30,'y':40})) # Output: {'x':30,'y':40,'a':10,'b':20}",
    "test_cases": [
      "assert merge_dict({'a': 100, 'b': 200},{'x': 300, 'y': 200})=={'x': 300, 'y': 200, 'a': 100, 'b': 200}",
      "assert merge_dict({'a':900,'b':900,'d':900},{'a':900,'b':900,'d':900})=={'a':900,'b':900,'d':900,'a':900,'b':900,'d':900}",
      "assert merge_dict({'a':10,'b':20},{'x':30,'y':40})=={'x':30,'y':40,'a':10,'b':20}"
    ]
  },
  {
    "mbpp_id": 264,
    "problem_statement": "Write a function to calculate a dog's age in dog's years.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def dog_age(animal_years):\n    if animal_years == 0:\n        return 0\n    elif animal_years == 1:\n        return 10.5\n    else:\n        return ((animal_years - 1) * 4.35) + 10.5\n\n# Example usage:\nprint(dog_age(12))   # Expected output: 61\nprint(dog_age(15))   # Expected output: 73\nprint(dog_age(24))   # Expected output: 109",
    "test_cases": [
      "assert dog_age(12)==61",
      "assert dog_age(15)==73",
      "assert dog_age(24)==109"
    ]
  },
  {
    "mbpp_id": 265,
    "problem_statement": "Write a function to split a list for every nth element.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def list_split(input_list,n):\n    return [input_list[i:i+n] for i in range(0, len(input_list), n)]",
    "test_cases": [
      "assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']] ",
      "assert list_split([1,2,3,4,5,6,7,8,9,10,11,12,13,14],3)==[[1,4,7,10,13], [2,5,8,11,14], [3,6,9,12]] ",
      "assert list_split(['python','java','C','C++','DBMS','SQL'],2)==[['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']] "
    ]
  },
  {
    "mbpp_id": 266,
    "problem_statement": "Write a function to find the lateral surface area of a cube.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube given its side length.\n    \n    Parameters:\n    - side_length: The length of one edge of the cube.\n    \n    Returns:\n    - The lateral surface area of the cube as an integer.\n    \"\"\"\n    return 4 * side_length ** 2",
    "test_cases": [
      "assert lateralsurface_cube(5)==100",
      "assert lateralsurface_cube(9)==324",
      "assert lateralsurface_cube(10)==400"
    ]
  },
  {
    "mbpp_id": 267,
    "problem_statement": "Write a python function to find the sum of squares of first n odd natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'square_Sum' is not defined",
      "Test 2: FAIL - name 'square_Sum' is not defined",
      "Test 3: FAIL - name 'square_Sum' is not defined"
    ],
    "generated_code": "def square_sum(n):\n    total = 0\n    for i in range(n):\n        total += (2*i+1)**2\n    return total",
    "test_cases": [
      "assert square_Sum(2) == 10",
      "assert square_Sum(3) == 35",
      "assert square_Sum(4) == 84"
    ]
  },
  {
    "mbpp_id": 268,
    "problem_statement": "Write a function to find the n'th star number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def find_star_num(n):\n    \"\"\"\n    Find the nth star number.\n    \n    A star number is defined as a number which can be represented in the form of a \"star\" shape using '*' characters.\n    \n    Parameters:\n    - n: An integer representing the position of the star number in the sequence.\n    \n    Returns:\n    - The nth star number as an integer.\n    \"\"\"\n    # Calculate the nth star number using the formula\n    result = int((3 * n * n) - (n * n) + 1)\n    return result\n\n# Test cases to verify the correctness of the function\nassert find_star_num(3) == 37\nassert find_star_num(4) == 73\nassert find_star_num(5) == 121",
    "test_cases": [
      "assert find_star_num(3) == 37",
      "assert find_star_num(4) == 73",
      "assert find_star_num(5) == 121"
    ]
  },
  {
    "mbpp_id": 269,
    "problem_statement": "Write a function to find the ascii value of a character.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def ascii_value(char):\n    return ord(char)\n\n# Test cases\nprint(ascii_value('A')) # Should output: 65\nprint(ascii_value('R')) # Should output: 82\nprint(ascii_value('S')) # Should output: 83",
    "test_cases": [
      "assert ascii_value('A')==65",
      "assert ascii_value('R')==82",
      "assert ascii_value('S')==83"
    ]
  },
  {
    "mbpp_id": 270,
    "problem_statement": "Write a python function to find the sum of even numbers at even positions.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_even_and_even_index(arr, n):\n    total = 0\n    for i in range(n):\n        if arr[i] % 2 == 0 and i % 2 == 0:\n            total += arr[i]\n    return total\n\n# Test cases\nprint(sum_even_and_even_index([5, 6, 12, 1, 18, 8], 6)) # Output: 30\nprint(sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18], 10)) # Output: 26\nprint(sum_even_and_even_index([5, 6, 12, 1], 4)) # Output: 12",
    "test_cases": [
      "assert sum_even_and_even_index([5, 6, 12, 1, 18, 8],6) == 30",
      "assert sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18],10) == 26",
      "assert sum_even_and_even_index([5, 6, 12, 1],4) == 12"
    ]
  },
  {
    "mbpp_id": 271,
    "problem_statement": "Write a python function to find the sum of fifth power of first n even natural numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def even_Power_Sum(n):\n    # Initialize the sum variable\n    total_sum = 0\n    \n    # Loop through the first n even numbers\n    for i in range(1, n+1):\n        # Calculate the fifth power and add it to the total sum\n        total_sum += pow((i * 2), 5)\n    \n    return total_sum",
    "test_cases": [
      "assert even_Power_Sum(2) == 1056",
      "assert even_Power_Sum(3) == 8832",
      "assert even_Power_Sum(1) == 32"
    ]
  },
  {
    "mbpp_id": 272,
    "problem_statement": "Write a function to perfom the rear element extraction from list of tuples records.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def rear_extract(records):\n    \"\"\"\n    Extracts and returns the last elements from each tuple in the given list.\n    \n    Args:\n        records (list): A list of tuples where each tuple contains at least one element.\n        \n    Returns:\n        list: A list containing the last element from each tuple.\n    \"\"\"\n    return [record[-1] for record in records]\n\n# Check function with provided data points\nprint(rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]))   # Output: [21, 20, 19]\nprint(rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]))  # Output: [36, 25, 45]\nprint(rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]))  # Output: [14, 36, 56]",
    "test_cases": [
      "assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]",
      "assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]",
      "assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]"
    ]
  },
  {
    "mbpp_id": 273,
    "problem_statement": "Write a function to substract the contents of one tuple with corresponding index of other tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def substract_elements(tuple_a, tuple_b):\n    if len(tuple_a) != len(tuple_b):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    result = []\n    for i in range(len(tuple_a)):\n        result.append(tuple_a[i] - tuple_b[i])\n    \n    return tuple(result)\n\n# Test cases\nprint(substract_elements((10, 4, 5), (2, 5, 18)))  # Expected output: (8, -1, -13)\nprint(substract_elements((11, 2, 3), (24, 45, 16)))  # Expected output: (-13, -43, -13)\nprint(substract_elements((7, 18, 9), (10, 11, 12)))  # Expected output: (-3, 7, -3)",
    "test_cases": [
      "assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)",
      "assert substract_elements((11, 2, 3), (24, 45 ,16)) == (-13, -43, -13)",
      "assert substract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)"
    ]
  },
  {
    "mbpp_id": 274,
    "problem_statement": "Write a python function to find sum of even index binomial coefficients.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def even_binomial_Coeff_Sum(n):\n    total_sum = 0\n    # Iterate through all odd indices in n (which correspond to even binomial coefficients)\n    for i in range(1, n + 1, 2):\n        total_sum += int((n / i)**i * factorial(i) // ((factorial(i) * factorial(n - i)) % 10**9 + 7))\n    return total_sum\n\n# Helper function to calculate factorial using modulo operation\nfrom math import factorial\n\ndef factorial(num):\n    fact = 1\n    for i in range(2, num + 1):\n        fact *= i\n        fact %= 10**9 + 7\n    return fact",
    "test_cases": [
      "assert even_binomial_Coeff_Sum(4) == 8",
      "assert even_binomial_Coeff_Sum(6) == 32",
      "assert even_binomial_Coeff_Sum(2) == 2"
    ]
  },
  {
    "mbpp_id": 275,
    "problem_statement": "Write a python function to find the position of the last removed element from the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_Position(arr, k, l):\n    n = len(arr)\n    for i in range(n-1, -1, -1):\n        if arr[i] == k:\n            j = i + 1\n            while j < n and arr[j] == k:\n                j += 1\n            if j >= n:\n                break\n            if j - i <= l:\n                return j\n    return -1",
    "test_cases": [
      "assert get_Position([2,5,4],3,2) == 2",
      "assert get_Position([4,3],2,2) == 2",
      "assert get_Position([1,2,3,4],4,1) == 4"
    ]
  },
  {
    "mbpp_id": 276,
    "problem_statement": "Write a function to find the volume of a cylinder.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef volume_cylinder(radius, height):\n    return math.pi * radius**2 * height",
    "test_cases": [
      "assert volume_cylinder(10,5)==1570.7500000000002",
      "assert volume_cylinder(4,5)==251.32000000000002",
      "assert volume_cylinder(4,10)==502.64000000000004"
    ]
  },
  {
    "mbpp_id": 277,
    "problem_statement": "Write a function to filter a dictionary based on values.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def dict_filter(input_dict, value):\n    # Filter out items from the input_dict where the values do not match the given value\n    filtered_dict = {key:value for key, value in input_dict.items() if value == value}\n    return filtered_dict",
    "test_cases": [
      "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}",
      "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180)=={ 'Alden Cantrell': 180, 'Pierre Cox': 190}",
      "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},190)=={ 'Pierre Cox': 190}"
    ]
  },
  {
    "mbpp_id": 278,
    "problem_statement": "Write a function to find the element count that occurs before the record in the given tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_first_elements(tup):\n    # Initialize a counter for elements appearing after '()'\n    count_after_parentheses = 0\n    i = 0\n    \n    while i < len(tup):\n        if isinstance(tup[i], tuple):  # Check if current element is a tuple\n            count_after_parentheses += 1  # Increment counter for elements after parentheses\n        else:\n            break  # Break out of loop once an element is found\n        i += 1\n    \n    # Return the difference between total length and counter for elements before tuples\n    return len(tup) - count_after_parentheses",
    "test_cases": [
      "assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3",
      "assert count_first_elements((2, 9, (5, 7), 11) ) == 2",
      "assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4"
    ]
  },
  {
    "mbpp_id": 279,
    "problem_statement": "Write a function to find the nth decagonal number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_num_decagonal(n):\n    \"\"\"\n    This function takes an integer n as input and returns the nth decagonal number.\n    The formula for calculating the nth decagonal number is:\n    D_n = 4n^2 - 3n\n    where D_n represents the nth decagonal number.\n    \n    Parameters:\n    n (int): The position of the decagonal number in the sequence.\n    \n    Returns:\n    int: The nth decagonal number.\n    \"\"\"\n    result = 4 * n ** 2 - 3 * n\n    return result\n\n# Check function with provided data points\nassert is_num_decagonal(3) == 27, \"Test case 1 failed\"\nassert is_num_decagonal(7) == 175, \"Test case 2 failed\"\nassert is_num_decagonal(10) == 370, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert is_num_decagonal(3) == 27",
      "assert is_num_decagonal(7) == 175",
      "assert is_num_decagonal(10) == 370"
    ]
  },
  {
    "mbpp_id": 280,
    "problem_statement": "Write a function to search an element in the given array by using sequential search.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sequential_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return True, i\n    return False, -1",
    "test_cases": [
      "assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)",
      "assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)",
      "assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)"
    ]
  },
  {
    "mbpp_id": 281,
    "problem_statement": "Write a python function to check if the elements of a given list are unique or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'all_unique' is not defined",
      "Test 2: FAIL - name 'all_unique' is not defined",
      "Test 3: FAIL - name 'all_unique' is not defined"
    ],
    "generated_code": "def is_all_unique(lst):\n    seen = set()\n    for num in lst:\n        if num in seen:\n            return False\n        seen.add(num)\n    return True\n\n# Test cases\nprint(is_all_unique([1,2,3]))  # Expected output: True\nprint(is_all_unique([1,2,1,2]))  # Expected output: False\nprint(is_all_unique([1,2,3,4,5]))  # Expected output: True",
    "test_cases": [
      "assert all_unique([1,2,3]) == True",
      "assert all_unique([1,2,1,2]) == False",
      "assert all_unique([1,2,3,4,5]) == True"
    ]
  },
  {
    "mbpp_id": 282,
    "problem_statement": "Write a function to substaract two lists using map and lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List\n\ndef sub_list(list1: List[int], list2: List[int]) -> List[int]:\n    # Subtract elements of second list from each element of first list using map and lambda function\n    return list(map(lambda x, y: x - y, list1, list2))",
    "test_cases": [
      "assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]",
      "assert sub_list([1,2],[3,4])==[-2,-2]",
      "assert sub_list([90,120],[50,70])==[40,50]"
    ]
  },
  {
    "mbpp_id": 283,
    "problem_statement": "Write a python function to check whether the frequency of each digit is less than or equal to the digit itself.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def validate(num):\n    digits = [int(digit) for digit in str(num)]\n    for digit in digits:\n        if digits.count(digit) > digit:\n            return False\n    return True",
    "test_cases": [
      "assert validate(1234) == True",
      "assert validate(51241) == False",
      "assert validate(321) == True"
    ]
  },
  {
    "mbpp_id": 284,
    "problem_statement": "Write a function to check whether all items of a list are equal to a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_element(list_input, target_str):\n    return len(set(list_input)) == 1 and str(target_str) in list_input\n\n# Test cases\nprint(check_element([\"green\", \"orange\", \"black\", \"white\"], 'blue')) # Expected output: False\nprint(check_element([1,2,3,4], 7)) # Expected output: False\nprint(check_element([\"green\", \"green\", \"green\", \"green\"], 'green')) # Expected output: True",
    "test_cases": [
      "assert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False",
      "assert check_element([1,2,3,4],7)==False",
      "assert check_element([\"green\", \"green\", \"green\", \"green\"],'green')==True"
    ]
  },
  {
    "mbpp_id": 285,
    "problem_statement": "Write a function that matches a string that has an a followed by two to three 'b'.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef text_match_two_three(text):\n    pattern = r'ab{2,3}'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "test_cases": [
      "assert text_match_two_three(\"ac\")==('Not matched!')",
      "assert text_match_two_three(\"dc\")==('Not matched!')",
      "assert text_match_two_three(\"abbbba\")==('Found a match!')"
    ]
  },
  {
    "mbpp_id": 286,
    "problem_statement": "Write a function to find the largest sum of contiguous array in the modified array which is formed by repeating the given array k times.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_sub_array_sum_repeated(arr, n, m):\n    # Initialize DP table where dp[i][j] represents the maximum subarray sum ending at index i with j repetitions.\n    dp = [[0 for _ in range(m + 1)] for _ in range(n)]\n    \n    # Base case initialization: If there's only one repetition, we can simply take the maximum element.\n    for i in range(n):\n        dp[i][1] = max(dp[i-1][1] if i > 0 else 0, arr[i])\n    \n    # Fill the DP table based on previous values and current elements.\n    for rep in range(2, m + 1):\n        for len_arr in range(1, n + 1):\n            for start in range(len_arr - rep + 1):\n                end = start + rep - 1\n                dp[start][rep] = max(dp[start][rep], dp[start+1][rep-1] + arr[end])\n                \n    # The result will be the maximum value from the last row in the DP table.\n    return max(max(row[-m:] for row in dp))\n\n# Example usage:\nprint(max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3))  # Output: 30\nprint(max_sub_array_sum_repeated([-1, 10, 20], 3, 2))       # Output: 59\nprint(max_sub_array_sum_repeated([-1, -2, -3], 3, 3))       # Output: -1",
    "test_cases": [
      "assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30",
      "assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59",
      "assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1"
    ]
  },
  {
    "mbpp_id": 287,
    "problem_statement": "Write a python function to find the sum of squares of first n even natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def square_Sum(n):\n    total = 0\n    for i in range(n):\n        total += (2 * i + 1) ** 2\n    return total",
    "test_cases": [
      "assert square_Sum(2) == 20",
      "assert square_Sum(3) == 56",
      "assert square_Sum(4) == 120"
    ]
  },
  {
    "mbpp_id": 288,
    "problem_statement": "Write a function to count array elements having modular inverse under given prime number p equal to itself.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: base is not invertible for the given modulus"
    ],
    "generated_code": "def modular_inverse(arr, n, p):\n    modInverse = [0] * len(arr)\n    \n    for i in range(len(arr)):\n        if arr[i] != 0:\n            temp = pow(arr[i], -1, p)\n            if temp < p and temp >= 0:\n                modInverse[i] = int(temp)\n                \n    # Return sum of all elements with their modular inverses\n    result = sum(arr[i] * modInverse[i] % p for i in range(len(arr)))\n    \n    return result\n\n# Test cases\nprint(modular_inverse([ 1, 6, 4, 5 ], 4, 7))  # Output should be 2\nprint(modular_inverse([1, 3, 8, 12, 12], 5, 13))  # Output should be 3\nprint(modular_inverse([2, 3, 4, 5], 4, 6))  # Output should be 1",
    "test_cases": [
      "assert modular_inverse([ 1, 6, 4, 5 ], 4, 7) == 2",
      "assert modular_inverse([1, 3, 8, 12, 12], 5, 13) == 3",
      "assert modular_inverse([2, 3, 4, 5], 4, 6) == 1"
    ]
  },
  {
    "mbpp_id": 289,
    "problem_statement": "Write a python function to calculate the number of odd days in a given year.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def odd_Days(year):\n    # Assuming an average year has 365.2425 days for simplicity.\n    avg_days_per_year = 365.2425\n    \n    # Calculate the number of days more than the whole years in the input year.\n    extra_days = year % 4 * 365 + year % 100 * 365 - year % 400 * 366\n    \n    # Since there is one leap day every four years on average,\n    # we need to subtract these leap days from our total to get the correct count of odd days.\n    leap_days = int(extra_days / 366)\n    \n    # Now, since we have already considered leap days as normal days in our calculation,\n    # we need to add back the full months' worth of days before and after each leap day.\n    # This accounts for the fact that leap days do not make up an entire month but extend over two.\n    total_extra_days = leap_days * (365 // 12) + (leap_days + 1) * ((extra_days % 366) // 365)\n    \n    # Finally, calculate the total odd days.\n    odd_days = year * 365 - total_extra_days\n    \n    return odd_days",
    "test_cases": [
      "assert odd_Days(100) == 5",
      "assert odd_Days(50) ==6",
      "assert odd_Days(75) == 2"
    ]
  },
  {
    "mbpp_id": 290,
    "problem_statement": "Write a function to find the list of lists with maximum length.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_length(lst):\n    if not lst:\n        return (0, [])\n    longest = max((len(sublist), sublist) for sublist in lst)\n    return longest[1]\n\n# Test cases\nprint(max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])) # Expected output: ([13, 15, 17])\nprint(max_length([[1], [5, 7], [10, 12, 14,15]])) # Expected output: ([10, 12, 14,15])\nprint(max_length([[5], [15,20,25]])) # Expected output: ([15,20,25])",
    "test_cases": [
      "assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])",
      "assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])",
      "assert max_length([[5], [15,20,25]])==(3, [15,20,25])"
    ]
  },
  {
    "mbpp_id": 291,
    "problem_statement": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "from functools import lru_cache\n\ndef count_no_of_ways(n, k):\n    \"\"\"\n    Returns the total number of ways to paint a fence of length 'n' using 'k' colors \n    such that no two adjacent fence posts have the same color.\n    \n    Args:\n    - n: An integer representing the length of the fence.\n    - k: An integer representing the number of available colors.\n    \n    Returns:\n    - An integer representing the total number of ways to paint the fence under the given constraints.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def helper(start, prev_color):\n        if start == n:\n            return 1\n        total = 0\n        for new_color in range(k):\n            if new_color != prev_color:\n                total += helper(start + 1, new_color)\n        return total\n    \n    return helper(0, 0)\n\n# Check function to verify the correctness of the solution\ndef check():\n    assert count_no_of_ways(2, 4) == 16\n    assert count_no_of_ways(3, 2) == 6\n    assert count_no_of_ways(4, 4) == 228\n    print(\"All test cases passed.\")\n\ncheck()",
    "test_cases": [
      "assert count_no_of_ways(2, 4) == 16",
      "assert count_no_of_ways(3, 2) == 6",
      "assert count_no_of_ways(4, 4) == 228"
    ]
  },
  {
    "mbpp_id": 292,
    "problem_statement": "Write a python function to find quotient of two numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find(a, b):\n    # Calculate and return the quotient of two numbers\n    return a // b",
    "test_cases": [
      "assert find(10,3) == 3",
      "assert find(4,2) == 2",
      "assert find(20,5) == 4"
    ]
  },
  {
    "mbpp_id": 293,
    "problem_statement": "Write a function to find the third side of a right angled triangle.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef otherside_rightangle(a, b):\n    return math.sqrt(math.pow(a, 2) + math.pow(b, 2))",
    "test_cases": [
      "assert otherside_rightangle(7,8)==10.63014581273465",
      "assert otherside_rightangle(3,4)==5",
      "assert otherside_rightangle(7,15)==16.55294535724685"
    ]
  },
  {
    "mbpp_id": 294,
    "problem_statement": "Write a function to find the maximum value in a given heterogeneous list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - '>' not supported between instances of 'int' and 'str'",
      "Test 2: FAIL - '>' not supported between instances of 'int' and 'str'",
      "Test 3: FAIL - '>' not supported between instances of 'int' and 'str'"
    ],
    "generated_code": "def max_val(lst):\n    # Initialize max_value with the first element of the list\n    max_value = lst[0]\n    \n    # Iterate through each item in the list\n    for item in lst:\n        # Update max_value if the current item is greater than max_value\n        if item > max_value:\n            max_value = item\n    \n    return max_value",
    "test_cases": [
      "assert max_val(['Python', 3, 2, 4, 5, 'version'])==5",
      "assert max_val(['Python', 15, 20, 25])==25",
      "assert max_val(['Python', 30, 20, 40, 50, 'version'])==50"
    ]
  },
  {
    "mbpp_id": 295,
    "problem_statement": "Write a function to return the sum of all divisors of a number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sum_div(n):\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            sum += i\n    return sum",
    "test_cases": [
      "assert sum_div(8)==7",
      "assert sum_div(12)==16",
      "assert sum_div(7)==1"
    ]
  },
  {
    "mbpp_id": 296,
    "problem_statement": "Write a python function to count inversions in an array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_Inv_Count(arr, n):\n    cnt = 0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            if arr[i] > arr[j]:\n                cnt += 1\n    return cnt",
    "test_cases": [
      "assert get_Inv_Count([1,20,6,4,5],5) == 5",
      "assert get_Inv_Count([1,2,1],3) == 1",
      "assert get_Inv_Count([1,2,5,6,1],5) == 3"
    ]
  },
  {
    "mbpp_id": 297,
    "problem_statement": "Write a function to flatten a given nested list structure.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def flatten_list(nested_list):\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list",
    "test_cases": [
      "assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]",
      "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]",
      "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]"
    ]
  },
  {
    "mbpp_id": 298,
    "problem_statement": "Write a function to find the nested list elements which are present in another list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - 'int' object is not iterable",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def intersection_nested_lists(lst1, lst2):\n    \"\"\"\n    Finds and returns the common nested lists from lst1 with elements also found in lst2.\n    \n    Parameters:\n    lst1 (list of list): The first list containing nested lists.\n    lst2 (list): The second list used for comparison.\n    \n    Returns:\n    list of list: A list containing the intersecting nested lists from lst1.\n    \"\"\"\n    return [sublst for sublst in lst1 if all(elem in lst2 for elem in sublst)]",
    "test_cases": [
      "assert intersection_nested_lists( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]])==[[12], [7, 11], [1, 5, 8]]",
      "assert intersection_nested_lists([[2, 3, 1], [4, 5], [6, 8]], [[4, 5], [6, 8]])==[[], []]",
      "assert intersection_nested_lists(['john','amal','joel','george'],[['john'],['jack','john','mary'],['howard','john'],['jude']])==[['john'], ['john'], ['john'], []]"
    ]
  },
  {
    "mbpp_id": 299,
    "problem_statement": "Write a function to calculate the maximum aggregate from the list of tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - unsupported operand type(s) for +: 'int' and 'str'",
      "Test 2: FAIL - unsupported operand type(s) for +: 'int' and 'str'",
      "Test 3: FAIL - unsupported operand type(s) for +: 'int' and 'str'"
    ],
    "generated_code": "def max_aggregate(lst):\n    return max(lst, key=lambda x: sum(x))",
    "test_cases": [
      "assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)",
      "assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)",
      "assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)"
    ]
  },
  {
    "mbpp_id": 300,
    "problem_statement": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from math import comb\n\ndef count_binary_seq(n):\n    \"\"\"\n    Counts the number of binary sequences of length 2n where the sum of the first n bits is equal to the sum of the last n bits.\n    \n    :param n: Integer representing half the length of the binary sequence.\n    :return: Float representing the count of valid binary sequences.\n    \"\"\"\n    total_sequences = 2 ** (2 * n)\n    # Calculate combinations for sequences with sum 0 and sum n in the first half\n    ones_in_first_half_sum_0_or_n = comb(2 * n - 1, n - 1)\n    zeros_in_last_half_sum_0_or_n = comb(2 * n - 1, n - 1)\n    unique_combinations_with_zeros = comb(2 * n - 1, n - 1)\n    unique_combinations_without_zeros = comb(2 * n - 1, n - 1)\n    \n    # Calculate count of valid sequences considering different positions of zeros\n    result = 0\n    for i in range(0, 2 * n + 1):\n        if i <= n:\n            result += 2 * (comb(2 * n - 1, n - 1) * ones_in_first_half_sum_0_or_n // 2)\n        else:\n            result += 2 * (unique_combinations_without_zeros - 2 * unique_combinations_with_zeros // 2)\n    \n    return result / total_sequences\n\n# Test cases\nprint(count_binary_seq(1))  # Expected output: 2.0\nprint(count_binary_seq(2))  # Expected output: 6.0\nprint(count_binary_seq(3))  # Expected output: 20.0",
    "test_cases": [
      "assert count_binary_seq(1) == 2.0",
      "assert count_binary_seq(2) == 6.0",
      "assert count_binary_seq(3) == 20.0"
    ]
  },
  {
    "mbpp_id": 301,
    "problem_statement": "Write a function to find the depth of a dictionary.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def dict_depth(d):\n    max_depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            current_depth = 1 + dict_depth(value)\n            max_depth = max(max_depth, current_depth)\n    return max_depth",
    "test_cases": [
      "assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4",
      "assert dict_depth({'a':1, 'b': {'c':'python'}})==2",
      "assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3"
    ]
  },
  {
    "mbpp_id": 302,
    "problem_statement": "Write a python function to find the most significant bit number which is also a set bit.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def set_Bit_Number(n):\n    # Iterate through all bits in the binary representation of n\n    for i in range(31, -1, -1):  # Start from 31 because we want to go backwards up to 0\n        if (n >> i) & 1 == 1:\n            return 1 << i  # Return the ith bit set to 1\n    return None  # If no such bit exists, return None",
    "test_cases": [
      "assert set_Bit_Number(6) == 4",
      "assert set_Bit_Number(10) == 8",
      "assert set_Bit_Number(18) == 16"
    ]
  },
  {
    "mbpp_id": 303,
    "problem_statement": "Write a python function to check whether the count of inversion of two types are same or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def solve(arr, n):\n    # Counting inversions in arr[i] < arr[j]\n    def counting_inv_left(i):\n        left = i - 1\n        cnt = 0\n        while left >= 0:\n            if arr[left] > arr[i]:\n                break\n            else:\n                cnt += 1\n                left -= 1\n        return cnt\n\n    # Counting inversions in arr[i] > arr[j]\n    def counting_inv_right(j):\n        right = j + 1\n        cnt = 0\n        while right < n:\n            if arr[right] < arr[j]:\n                break\n            else:\n                cnt += 1\n                right += 1\n        return cnt\n\n    inv_count_left = 0\n    for i in range(n):\n        inv_count_left += counting_inv_right(i)\n\n    inv_count_right = 0\n    for j in range(1, n):\n        inv_count_right += counting_inv_left(j)\n\n    return inv_count_left == inv_count_right",
    "test_cases": [
      "assert solve([1,0,2],3) == True",
      "assert solve([1,2,0],3) == False",
      "assert solve([1,2,1],3) == True"
    ]
  },
  {
    "mbpp_id": 304,
    "problem_statement": "Write a python function to find element at a given index after number of rotations.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - SyntaxError: invalid syntax"
    ],
    "generated_code": "```python\ndef find_Element(arr, rotate_list, i, n):\n    \"\"\"\n    Find an element in an array rotated at unknown pivot, starting from the first element,\n    where each subarray is sorted except for one.\n    \n    Parameters:\n    arr (list): The original unrotated list.\n    rotate_list (list): A list of pairs representing indices and directions to shift the array elements.\n    i (int): The target index within the rotated array.\n    n (int): The length of the original array before rotation.\n    \n    Returns:\n    int: The value at the specified index 'i' if it exists; otherwise, returns -1.\n    \"\"\"\n    # Initialize pointers for binary search\n    low, high = 0, len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        # Check if we have found the exact index\n        if arr[mid] == i:\n            return arr[i]\n        \n        # Adjust pointers based on the direction of rotation\n        if arr[mid] < i:\n            if rotate_list[mid][1] == 1:\n                # If the middle element is less than the current target and the right half is sorted\n                if arr[mid+1] >= i:\n                    break\n                else:\n                    # Otherwise, check left side\n                    high = mid - 1\n            else:\n                # If the middle element is greater than the current target and the left half is not sorted\n                if arr[mid-1] < i:\n                    break\n                else:\n                    # Otherwise, check right side\n                    low = mid + 1\n        elif arr[mid] > i:\n            if rotate_list[mid][1] == 1:\n                # If the middle element is greater than the current target and the left half is sorted\n                if arr[mid-1] <= i:\n                    break\n                else:\n                    # Otherwise, check right side\n                    low = mid + 1\n            else:\n                # If the middle element is less than the current target and the right half is not sorted\n                if arr[mid+1] > i:\n                    break\n                else:\n                    # Otherwise, check left side\n                    high = mid - 1\n        else:\n            # Handle case where arr[mid] equals i directly\n            return arr[i]\n    \n    # Return the result of the binary search operation\n    return arr[i]\n\n\n# Example usage\nprint(find_Element([1",
    "test_cases": [
      "assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3",
      "assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3",
      "assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1"
    ]
  },
  {
    "mbpp_id": 305,
    "problem_statement": "Write a function to match two words from a list of words starting with letter 'p'.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def start_withp(words_list):\n    # Iterate over each pair of words in the given list\n    for i in range(len(words_list)):\n        for j in range(i + 1, len(words_list)):\n            if words_list[i][0] == 'p' and words_list[j][0] == 'p':\n                return words_list[i], words_list[j]\n    return None\n\n# Test cases to verify the correctness of the solution\nassert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')\nassert start_withp([\"Python Programming\",\"Java Programming\"]) == ('Python','Programming')\nassert start_withp([\"Pqrst Pqr\",\"qrstuv\"]) == ('Pqrst','Pqr')\n\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')",
      "assert start_withp([\"Python Programming\",\"Java Programming\"])==('Python','Programming')",
      "assert start_withp([\"Pqrst Pqr\",\"qrstuv\"])==('Pqrst','Pqr')"
    ]
  },
  {
    "mbpp_id": 306,
    "problem_statement": "Write a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i .",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: list index out of range"
    ],
    "generated_code": "def max_sum_increasing_subseq(arr, i, j, k):\n    if arr[k] < arr[i]:\n        return arr[k]\n    \n    for x in range(i + 1, k):\n        if arr[x] >= arr[i] and (j == -1 or arr[j] <= arr[x]):\n            new_j = x\n            y = i + 1\n            while y < k:\n                if arr[y] < arr[new_j]:\n                    new_j = y\n                y += 1\n            \n            if arr[x] != arr[new_j]:\n                break\n                \n            temp_sum = max_sum_increasing_subseq(arr, x, j, k)\n            if arr[new_j] < arr[i]:\n                temp_sum = max(temp_sum, arr[i])\n            \n            arr[i:j+1] = [arr[i]] * len(arr[:i]) + list(reversed(sorted(arr[i:new_j]))) + [arr[new_j]] * len(arr[new_j:]) + arr[j:]\n            return temp_sum\n    \n    arr[i:k] = sorted(arr[i:k])\n    return sum(arr[i:k])\n\n# Test Cases\nprint(max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6))  # Output: 11\nprint(max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 2, 5))   # Output: 7\nprint(max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4)) # Output: 71",
    "test_cases": [
      "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11",
      "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7",
      "assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71"
    ]
  },
  {
    "mbpp_id": 307,
    "problem_statement": "Write a function to get a colon of a tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - can only concatenate tuple (not \"list\") to tuple",
      "Test 2: FAIL - can only concatenate tuple (not \"list\") to tuple",
      "Test 3: FAIL - can only concatenate tuple (not \"list\") to tuple"
    ],
    "generated_code": "def colon_tuplex(tuplex, index, value):\n    return tuplex[:index] + [value] + tuplex[index+1:]",
    "test_cases": [
      "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,50)==(\"HELLO\", 5, [50], True) ",
      "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,100)==((\"HELLO\", 5, [100],True))",
      "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,500)==(\"HELLO\", 5, [500], True)"
    ]
  },
  {
    "mbpp_id": 308,
    "problem_statement": "Write a function to find the specified number of largest products from two given lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - bad operand type for unary -: 'tuple'",
      "Test 2: FAIL - bad operand type for unary -: 'tuple'",
      "Test 3: FAIL - bad operand type for unary -: 'tuple'"
    ],
    "generated_code": "from typing import List\nimport heapq\n\ndef large_product(list1: List[int], list2: List[int], k: int) -> List[int]:\n    # Convert both lists into heaps based on their elements\n    heap1 = [(x, i) for i, x in enumerate(list1)]\n    heap2 = [(y, j) for j, y in enumerate(list2)]\n    \n    # Create k smallest pairs with negative values from each heap\n    pq1 = []\n    pq2 = []\n    for _ in range(k):\n        if heap1:\n            val, idx = heapq.heappop(heap1)\n            heapq.heappush(pq1, (-val, idx))\n        if heap2:\n            val, idx = heapq.heappop(heap2)\n            heapq.heappush(pq2, (-val, idx))\n    \n    result = []\n    while pq1 and pq2:\n        neg_val1, idx1 = -heapq.heappop(pq1)\n        neg_val2, idx2 = -heapq.heappop(pq2)\n        \n        result.append(neg_val1 * neg_val2)\n        if len(result) == k:\n            break\n    \n    return result",
    "test_cases": [
      "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]",
      "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]",
      "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]"
    ]
  },
  {
    "mbpp_id": 309,
    "problem_statement": "Write a python function to find the maximum of two numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def maximum(x, y):\n    if x > y:\n        return x\n    else:\n        return y",
    "test_cases": [
      "assert maximum(5,10) == 10",
      "assert maximum(-1,-2) == -1",
      "assert maximum(9,7) == 9"
    ]
  },
  {
    "mbpp_id": 310,
    "problem_statement": "Write a function to convert a given string to a tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - sequence item 0: expected str instance, tuple found",
      "Test 2: FAIL - sequence item 0: expected str instance, tuple found",
      "Test 3: FAIL - sequence item 0: expected str instance, tuple found"
    ],
    "generated_code": "def string_to_tuple(input_string):\n    # Convert each character in the input string to a tuple with single-character strings and return them as a list of tuples.\n    result = [tuple([char]) for char in input_string]\n    # Join the characters into a string with a space between each element.\n    final_result = \" \".join(result)\n    return final_result",
    "test_cases": [
      "assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')",
      "assert string_to_tuple(\"item1\")==('i', 't', 'e', 'm', '1')",
      "assert string_to_tuple(\"15.10\")==('1', '5', '.', '1', '0')"
    ]
  },
  {
    "mbpp_id": 311,
    "problem_statement": "Write a python function to set the left most unset bit.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def set_left_most_unset_bit(n):\n    # Shift right by 1 and then OR with n+1\n    return n | (n >> 1)",
    "test_cases": [
      "assert set_left_most_unset_bit(10) == 14",
      "assert set_left_most_unset_bit(12) == 14",
      "assert set_left_most_unset_bit(15) == 15"
    ]
  },
  {
    "mbpp_id": 312,
    "problem_statement": "Write a function to find the volume of a cone.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef volume_cone(radius, height):\n    # Volume formula for a cone is (1/3)πr^2h\n    return (1/3) * math.pi * radius**2 * height\n\n# Test cases\nprint(volume_cone(5,12)) # Expected output: 314.15926535897927\nprint(volume_cone(10,15)) # Expected output: 1570.7963267948965\nprint(volume_cone(19,17)) # Expected output: 6426.651371693521",
    "test_cases": [
      "assert volume_cone(5,12)==314.15926535897927",
      "assert volume_cone(10,15)==1570.7963267948965",
      "assert volume_cone(19,17)==6426.651371693521"
    ]
  },
  {
    "mbpp_id": 313,
    "problem_statement": "Write a python function to print positive numbers in a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def pos_nos(lst):\n    # Use list comprehension to filter out negative numbers and return the remaining ones\n    return [x for x in lst if x > 0]",
    "test_cases": [
      "assert pos_nos([-1,-2,1,2]) == 1,2",
      "assert pos_nos([3,4,-5]) == 3,4",
      "assert pos_nos([-2,-3,1]) == 1"
    ]
  },
  {
    "mbpp_id": 314,
    "problem_statement": "Write a function to find out the maximum sum such that no two chosen numbers are adjacent for the given rectangular grid of dimension 2 x n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - list index out of range",
      "Test 2: FAIL - list index out of range",
      "Test 3: FAIL - list index out of range"
    ],
    "generated_code": "def max_sum_rectangular_grid(grid, n):\n    \"\"\"\n    Finds the maximum sum of elements in any sub-rectangular region where no two chosen elements are adjacent.\n    \n    Parameters:\n    grid (list of list of int): A 2-dimensional list representing the rectangular grid.\n    n (int): The size of each row in the grid.\n    \n    Returns:\n    int: The maximum sum possible under the given conditions.\n    \"\"\"\n    m = len(grid)\n    dp = [[0] * (n + 2) for _ in range(m)]\n    # Initialize first column\n    for i in range(m):\n        dp[i][1] = dp[i][n+1] = grid[i][0]\n    ans = 0\n    # Fill the DP table with optimal sums\n    for j in range(1, n + 1):\n        for i in range(m):\n            dp[i][j] = max(dp[i][j - 1], dp[i][j])\n            if i > 0:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n            ans = max(ans, dp[i][j])\n    return ans",
    "test_cases": [
      "assert max_sum_rectangular_grid([ [1, 4, 5], [2, 0, 0 ] ], 3) == 7",
      "assert max_sum_rectangular_grid([ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10] ], 5) == 24",
      "assert max_sum_rectangular_grid([ [7, 9, 11, 15, 19], [21, 25, 28, 31, 32] ], 5) == 81"
    ]
  },
  {
    "mbpp_id": 315,
    "problem_statement": "Write a python function to find the first maximum length of even word.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_Max_Len_Even(input_str):\n    max_len = -1\n    for word in input_str.split():\n        if len(word) % 2 == 0:\n            max_len = max(max_len, len(word))\n    return \"\" if max_len == -1 else word[:max_len]\n\n# Test cases\nprint(find_Max_Len_Even(\"python language\"))  # Output: \"language\"\nprint(find_Max_Len_Even(\"maximum even length\"))  # Output: \"length\"\nprint(find_Max_Len_Even(\"eve\"))  # Output: \"\"",
    "test_cases": [
      "assert find_Max_Len_Even(\"python language\") == \"language\"",
      "assert find_Max_Len_Even(\"maximum even length\") == \"length\"",
      "assert find_Max_Len_Even(\"eve\") == \"-1\""
    ]
  },
  {
    "mbpp_id": 316,
    "problem_statement": "Write a function to find the index of the last occurrence of a given number in a sorted array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "from bisect import bisect_right\n\ndef find_last_occurrence(sorted_list, target):\n    \"\"\"\n    Finds the index of the last occurrence of a given number in a sorted list.\n    \n    Parameters:\n    sorted_list (list): A list of integers sorted in non-decreasing order.\n    target (int): The integer to search for.\n    \n    Returns:\n    int: The index of the last occurrence of the target in the sorted_list, or -1 if not found.\n    \"\"\"\n    # Find the rightmost index where `target` appears in `sorted_list`\n    index = bisect_right(sorted_list, target)\n    # If `index` is 0, it means there's no element less than `target`, so we return -1\n    return index if index > 0 else -1\n\n# Test cases to verify the correctness of the function\nassert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3\nassert find_last_occurrence([2, 3, 5, 8, 6, 6, 8, 9, 9, 9], 9) == 9\nassert find_last_occurrence([2, 2, 1, 5, 6, 6, 6, 9, 9, 9], 6) == 6\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3",
      "assert find_last_occurrence([2, 3, 5, 8, 6, 6, 8, 9, 9, 9], 9) == 9",
      "assert find_last_occurrence([2, 2, 1, 5, 6, 6, 6, 9, 9, 9], 6) == 6"
    ]
  },
  {
    "mbpp_id": 317,
    "problem_statement": "Write a function to reflect the modified run-length encoding from a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def modified_encode(arr):\n    result = []\n    count = 0\n    current_value = None\n    \n    for item in arr:\n        if not isinstance(item, int) and not isinstance(item, str):\n            raise ValueError(\"Input array should contain only integers and strings.\")\n        \n        if current_value is None:\n            current_value = item\n        \n        if current_value == item:\n            count += 1\n        else:\n            result.append(current_value)\n            result.extend([[count, item]])\n            current_value = item\n            count = 1\n    \n    # Append the last value and its count\n    result.append(current_value)\n    result.extend([[count, current_value]])\n    \n    return result",
    "test_cases": [
      "assert modified_encode([1,1,2,3,4,4,5,1])==[[2, 1], 2, 3, [2, 4], 5, 1]",
      "assert modified_encode('automatically')==['a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', [2, 'l'], 'y']",
      "assert modified_encode('python')==['p', 'y', 't', 'h', 'o', 'n']"
    ]
  },
  {
    "mbpp_id": 318,
    "problem_statement": "Write a python function to find the maximum volume of a cuboid with given sum of sides.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_volume(sum_of_sides):\n    \"\"\"\n    Finds the maximum volume of a cuboid where the sum of its three dimensions is equal to sum_of_sides.\n    \n    Parameters:\n    sum_of_sides (int): The sum of the three dimensions of the cuboid.\n    \n    Returns:\n    int: The maximum possible volume of the cuboid.\n    \"\"\"\n    # Initialize variables for volume calculation\n    length = width = height = -sum_of_sides / 3\n    \n    # Adjust lengths and widths to ensure they are positive integers\n    while length * width * height != sum_of_sides ** 3 // 6 and length > 0 and width > 0 and height > 0:\n        if length == 0 or width == 0 or height == 0:\n            break\n        else:\n            length += 1\n            width -= 1\n            height -= 1\n            \n    # Calculate the volume\n    volume = length * width * height\n    return volume\n\n# Test cases\nprint(max_volume(8))   # Expected output: 18\nprint(max_volume(4))   # Expected output: 2\nprint(max_volume(1))   # Expected output: 0",
    "test_cases": [
      "assert max_volume(8) == 18",
      "assert max_volume(4) == 2",
      "assert max_volume(1) == 0"
    ]
  },
  {
    "mbpp_id": 319,
    "problem_statement": "Write a function to find all five characters long word in the given string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef find_long_word(input_string):\n    pattern = r'\\b\\w{5}\\b'\n    result = re.findall(pattern, input_string)\n    return result\n\n# Test cases\nprint(find_long_word('Please move back to strem')) # Should return ['strem']\nprint(find_long_word('4K Ultra HD streaming player')) # Should return ['Ultra']\nprint(find_long_word('Streaming Media Player')) # Should return ['Media']",
    "test_cases": [
      "assert find_long_word('Please move back to strem') == ['strem']",
      "assert find_long_word('4K Ultra HD streaming player') == ['Ultra']",
      "assert find_long_word('Streaming Media Player') == ['Media']"
    ]
  },
  {
    "mbpp_id": 320,
    "problem_statement": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sum_difference(n):\n    # Calculate the squared sum of the first n natural numbers\n    sq_sum = sum(i**2 for i in range(1, n+1))\n    \n    # Calculate the sum of the squares of the first n natural numbers\n    s_sum = sum([i**2 for i in range(1, n+1)])\n    \n    # Return the difference between the two sums\n    return abs(sq_sum - s_sum)",
    "test_cases": [
      "assert sum_difference(12)==5434",
      "assert sum_difference(20)==41230",
      "assert sum_difference(54)==2151270"
    ]
  },
  {
    "mbpp_id": 321,
    "problem_statement": "Write a function to find the demlo number for the given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_demlo(num_str):\n    result = ''\n    count = len(num_str)\n    for i in range(1, count+1):\n        if i <= count // 2:\n            result += str(i) * (count - i + 1)\n        else:\n            temp = str(count - i + 1)\n            while len(temp) < count:\n                temp = \"0\" + temp\n            result += temp[::-1]\n    return result",
    "test_cases": [
      "assert find_demlo(\"111111\") == '12345654321'",
      "assert find_demlo(\"1111\") == '1234321'",
      "assert find_demlo(\"13333122222\") == '123456789101110987654321'"
    ]
  },
  {
    "mbpp_id": 322,
    "problem_statement": "Write a function to find all index positions of the minimum values in a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def position_min(lst):\n    \"\"\"\n    Returns the indices of the elements with the minimum value in lst.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    List[int]: Indices of the elements with the minimum value\n    \"\"\"\n    min_index = lst.index(min(lst))\n    return [i for i, x in enumerate(lst) if x == min(x for x in lst)]\n\n# Test cases\nprint(position_min([12,33,23,10,67,89,45,667,23,12,11,10,54])) # Expected output: [3, 11]\nprint(position_min([1,2,2,2,4,4,4,5,5,5,5]))                   # Expected output: [0]\nprint(position_min([2,1,5,6,8,3,4,9,10,11,8,12]))             # Expected output: [1]",
    "test_cases": [
      "assert position_min([12,33,23,10,67,89,45,667,23,12,11,10,54])==[3,11]",
      "assert position_min([1,2,2,2,4,4,4,5,5,5,5])==[0]",
      "assert position_min([2,1,5,6,8,3,4,9,10,11,8,12])==[1]"
    ]
  },
  {
    "mbpp_id": 323,
    "problem_statement": "Write a function to re-arrange the given array in alternating positive and negative items.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def re_arrange(arr, n):\n    pos = []\n    neg = []\n\n    # Separate positive and negative numbers into two lists\n    for i in arr:\n        if i >= 0:\n            pos.append(i)\n        else:\n            neg.append(i)\n\n    result = []\n    p_count = q_count = 0\n\n    while len(result) < n:\n        if p_count < len(pos):\n            result.append(pos[p_count])\n            p_count += 1\n        if q_count < len(neg):\n            result.append(neg[q_count])\n            q_count += 1\n\n    return result\n\n\n# Test cases\nprint(re_arrange([-5, -2, 5, 2, 4, 7, 1, 8, 0, -8], 10))  # Should return [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]\nprint(re_arrange([1, 2, 3, -4, -1, 4], 6))  # Should return [-4, 1, -1, 2, 3, 4]\nprint(re_arrange([4, 7, 9, 77, -4, 5, -3, -9], 8))  # Should return [-4, 4, -3, 7, -9, 9, 77, 5]",
    "test_cases": [
      "assert re_arrange([-5, -2, 5, 2, 4,\t7, 1, 8, 0, -8], 10) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]",
      "assert re_arrange([1, 2, 3, -4, -1, 4], 6) == [-4, 1, -1, 2, 3, 4]",
      "assert re_arrange([4, 7, 9, 77, -4, 5, -3, -9], 8) == [-4, 4, -3, 7, -9, 9, 77, 5]"
    ]
  },
  {
    "mbpp_id": 324,
    "problem_statement": "Write a function to extract the sum of alternate chains of tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "from typing import List, Tuple\n\ndef sum_of_alternates(lst: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\"\n    Given a list of integers, this function calculates two lists:\n    - The first list contains the sums of every other element from the original list.\n    - The second list contains the sums of all even-indexed elements plus one third of all odd-indexed elements.\n    \n    :param lst: List[int] - A list of integers to process.\n    :return: Tuple[List[int], List[int]] - A tuple containing the first and second lists.\n    \"\"\"\n    # Calculate sums of every other element starting with the first element\n    first_list = [lst[i] + lst[i+1] for i in range(0, len(lst), 2)]\n    \n    # Calculate sums of all even-indexed elements plus one third of all odd-indexed elements\n    second_list = [sum(lst[::2]) + lst[::2][len(lst)//3]] if len(lst) % 3 == 0 else []\n    \n    return first_list, second_list\n\n# Check function with provided data points\nassert sum_of_alternates([5, 6, 3, 6, 10, 34]) == ([46, 18], [6, 9]), \"Test case 1 failed\"\nassert sum_of_alternates([1, 2, 3, 4, 5]) == ([6, 9], [6, 9]), \"Test case 2 failed\"\nassert sum_of_alternates([6, 7, 8, 9, 4, 5]) == ([21, 18], [10, 10]), \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert sum_of_alternates((5, 6, 3, 6, 10, 34)) == (46, 18)",
      "assert sum_of_alternates((1, 2, 3, 4, 5)) == (6, 9)",
      "assert sum_of_alternates((6, 7, 8, 9, 4, 5)) == (21, 18)"
    ]
  },
  {
    "mbpp_id": 325,
    "problem_statement": "Write a python function to find the minimum number of squares whose sum is equal to a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - maximum recursion depth exceeded in comparison",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - maximum recursion depth exceeded in comparison"
    ],
    "generated_code": "def get_Min_Squares(n):\n    if n <= 3:\n        return n\n    \n    min_squares = float('inf')\n    for i in range(int(n**0.5), -1, -1):\n        if i*i > n:\n            break\n        remaining = n - i*i\n        subproblem_result = get_Min_Squares(remaining)\n        min_squares = min(min_squares, subproblem_result + 1)\n    \n    return min_squares",
    "test_cases": [
      "assert get_Min_Squares(6) == 3",
      "assert get_Min_Squares(2) == 2",
      "assert get_Min_Squares(4) == 1"
    ]
  },
  {
    "mbpp_id": 326,
    "problem_statement": "Write a function to get the word with most number of occurrences in the given strings list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from collections import Counter\n\ndef most_occurrences(words_list):\n    # Count the frequency of each word and find the one with maximum count\n    word_counts = Counter(words_list)\n    max_count_word = max(word_counts, key=word_counts.get)\n    \n    return max_count_word",
    "test_cases": [
      "assert most_occurrences([\"UTS is best for RTF\", \"RTF love UTS\", \"UTS is best\"] ) == 'UTS'",
      "assert most_occurrences([\"Its been a great year\", \"this year is so worse\", \"this year is okay\"] ) == 'year'",
      "assert most_occurrences([\"Families can be reunited\", \"people can be reunited\", \"Tasks can be achieved \"] ) == 'can'"
    ]
  },
  {
    "mbpp_id": 327,
    "problem_statement": "Write a function to print check if the triangle is isosceles or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_isosceles(a, b, c):\n    # Sort the lengths of sides in ascending order for easy comparison\n    sides = sorted([a, b, c])\n    # Check if any two sides are equal and form an isosceles triangle\n    return sides[0] + sides[1] > sides[2]",
    "test_cases": [
      "assert check_isosceles(6,8,12)==False ",
      "assert check_isosceles(6,6,12)==True",
      "assert check_isosceles(6,16,20)==False"
    ]
  },
  {
    "mbpp_id": 328,
    "problem_statement": "Write a function to rotate a given list by specified number of items to the left direction.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def rotate_left(lst, num, n):\n    return lst[num:] + lst[:num]\n\n# Test cases\nprint(rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, 4))  # Expected output: [4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4]\nprint(rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2, 2))  # Expected output: [3, 4, 5, 6, 7, 8, 9, 10, 1, 2]\nprint(rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5, 2))  # Expected output: [6, 7, 8, 9, 10, 1, 2]",
    "test_cases": [
      "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3,4)==[4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4]",
      "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2,2)==[3, 4, 5, 6, 7, 8, 9, 10, 1, 2]",
      "assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],5,2)==[6, 7, 8, 9, 10, 1, 2]"
    ]
  },
  {
    "mbpp_id": 329,
    "problem_statement": "Write a python function to count negative numbers in a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def neg_count(lst):\n    return sum(1 for x in lst if x < 0)",
    "test_cases": [
      "assert neg_count([-1,-2,3,-4,-5]) == 4",
      "assert neg_count([1,2,3]) == 0",
      "assert neg_count([1,2,-3,-10,20]) == 2"
    ]
  },
  {
    "mbpp_id": 330,
    "problem_statement": "Write a function to find all three, four, five characters long words in the given string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef find_char(text):\n    pattern = r'\\b\\w{3,5}\\b'\n    matches = re.findall(pattern, text)\n    return matches",
    "test_cases": [
      "assert find_char('For the four consumer complaints contact manager AKR reddy') == ['For', 'the', 'four', 'AKR', 'reddy']",
      "assert find_char('Certain service are subject to change MSR') == ['are', 'MSR']",
      "assert find_char('Third party legal desclaimers') == ['Third', 'party', 'legal']"
    ]
  },
  {
    "mbpp_id": 331,
    "problem_statement": "Write a python function to count unset bits of a given number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_unset_bits(num):\n    count = 0\n    while num:\n        if num & 1 == 0:\n            count += 1\n        num >>= 1\n    return count",
    "test_cases": [
      "assert count_unset_bits(2) == 1",
      "assert count_unset_bits(4) == 2",
      "assert count_unset_bits(6) == 1"
    ]
  },
  {
    "mbpp_id": 332,
    "problem_statement": "Write a function to count character frequency of a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def char_frequency(input_string):\n    return {char: input_string.count(char) for char in set(input_string)}",
    "test_cases": [
      "assert char_frequency('python')=={'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}",
      "assert char_frequency('program')=={'p': 1, 'r': 2, 'o': 1, 'g': 1, 'a': 1, 'm': 1}",
      "assert char_frequency('language')=={'l': 1, 'a': 2, 'n': 1, 'g': 2, 'u': 1, 'e': 1}"
    ]
  },
  {
    "mbpp_id": 333,
    "problem_statement": "Write a python function to sort a list according to the second element in sublist.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Sort' is not defined",
      "Test 2: FAIL - name 'Sort' is not defined",
      "Test 3: FAIL - name 'Sort' is not defined"
    ],
    "generated_code": "def sort_list_by_second_element(test_list):\n    test_list.sort(key=lambda x: x[1])\n    return test_list",
    "test_cases": [
      "assert Sort([['a', 10], ['b', 5], ['c', 20], ['d', 15]]) == [['b', 5], ['a', 10], ['d', 15], ['c', 20]]",
      "assert Sort([['452', 10], ['256', 5], ['100', 20], ['135', 15]]) == [['256', 5], ['452', 10], ['135', 15], ['100', 20]]",
      "assert Sort([['rishi', 10], ['akhil', 5], ['ramya', 20], ['gaur', 15]]) == [['akhil', 5], ['rishi', 10], ['gaur', 15], ['ramya', 20]]"
    ]
  },
  {
    "mbpp_id": 334,
    "problem_statement": "Write a python function to check whether the triangle is valid or not if sides are given.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_Validity(a, b, c):\n    # Check for invalid side lengths (sum of two sides less than third side)\n    if a + b <= c or b + c <= a or a + c <= b:\n        return False\n    else:\n        return True",
    "test_cases": [
      "assert check_Validity(1,2,3) == False",
      "assert check_Validity(2,3,5) == False",
      "assert check_Validity(7,10,5) == True"
    ]
  },
  {
    "mbpp_id": 335,
    "problem_statement": "Write a function to find the sum of arithmetic progression.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def ap_sum(first_term, last_term, step_size):\n    # Calculate the number of terms in the sequence\n    num_terms = ((last_term - first_term) // step_size) + 1\n    \n    # Use the formula for the sum of an arithmetic progression\n    total_sum = num_terms * (first_term + last_term) / 2\n    \n    return int(total_sum)",
    "test_cases": [
      "assert ap_sum(1,5,2)==25",
      "assert ap_sum(2,6,4)==72",
      "assert ap_sum(1,4,5)==34"
    ]
  },
  {
    "mbpp_id": 336,
    "problem_statement": "Write a function to check whether the given month name contains 28 days or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - 'tuple' object has no attribute 'day'",
      "Test 3: FAIL - 'tuple' object has no attribute 'day'"
    ],
    "generated_code": "import calendar\n\ndef check_monthnum(month_name):\n    return calendar.monthrange(2023, 1).day == 28 if month_name.lower() in ['january', 'march'] else False",
    "test_cases": [
      "assert check_monthnum(\"February\")==True",
      "assert check_monthnum(\"January\")==False",
      "assert check_monthnum(\"March\")==False"
    ]
  },
  {
    "mbpp_id": 337,
    "problem_statement": "Write a function that matches a word at the end of a string, with optional punctuation.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef text_match_word(text):\n    \"\"\"\n    This function checks if the provided 'text' ends with a full stop '.', underscore '_', semicolon ';', question mark '?',\n    exclamation point '!', or colon ':' and returns a message accordingly.\n    \"\"\"\n    # Define regex pattern to check for required ending characters\n    pattern = r'\\.\\w*$|_\\w*$|\\;\\w*$|\\.!\\w*|\\.?\\w*$'\n    \n    # Check if text ends with an allowed character sequence\n    if re.search(pattern, text.strip()):\n        return \"Found a match!\"\n    else:\n        return \"Not matched!\"\n\n# Test cases\nprint(text_match_word(\"python.\"))   # Expected output: Found a match!\nprint(text_match_word(\"python.\"))   # Expected output: Found a match!\nprint(text_match_word(\"  lang  \"))  # Expected output: Not matched!",
    "test_cases": [
      "assert text_match_word(\"python.\")==('Found a match!')",
      "assert text_match_word(\"python.\")==('Found a match!')",
      "assert text_match_word(\"  lang  .\")==('Not matched!')"
    ]
  },
  {
    "mbpp_id": 338,
    "problem_statement": "Write a python function to count the number of substrings with same first and last characters.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'count_Substring_With_Equal_Ends' is not defined",
      "Test 2: FAIL - name 'count_Substring_With_Equal_Ends' is not defined",
      "Test 3: FAIL - name 'count_Substring_With_Equal_Ends' is not defined"
    ],
    "generated_code": "def count_substrings_with_equal_ends(s):\n    \"\"\"\n    Counts the number of substrings in the given string 's' where each substring has the same first and last character.\n    \n    :param s: A string consisting of lowercase English letters.\n    :return: An integer representing the count of substrings with equal first and last characters.\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        if i == 0:\n            for j in range(i+1, len(s)+1):\n                sub = s[i:j]\n                if sub[0] == sub[-1]:\n                    count += 1\n        else:\n            if s[i-1] == s[i] and s[i] == s[len(s)-1]:\n                count += 1\n    return count\n\n# Test cases\nprint(count_substrings_with_equal_ends('aba'))   # Expected output: 4\nprint(count_substrings_with_equal_ends('abcab')) # Expected output: 7\nprint(count_substrings_with_equal_ends('abc'))   # Expected output: 3",
    "test_cases": [
      "assert count_Substring_With_Equal_Ends('aba') == 4",
      "assert count_Substring_With_Equal_Ends('abcab') == 7",
      "assert count_Substring_With_Equal_Ends('abc') == 3"
    ]
  },
  {
    "mbpp_id": 339,
    "problem_statement": "Write a python function to find the maximum occuring divisor in an interval.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_Divisor(start, end):\n    # Initialize the maximum occurrence of the divisor and its count\n    max_occurrence = 0\n    current_divisor_count = 0\n    \n    for i in range(start, end + 1):\n        if i % 2 == 0:\n            current_divisor_count += 1\n        else:\n            current_divisor_count = 0\n        \n        if current_divisor_count > max_occurrence:\n            max_occurrence = current_divisor_count\n    \n    return max_occurrence\n\n# Test cases\nprint(find_Divisor(2,2))  # Expected output: 2\nprint(find_Divisor(2,5))  # Expected output: 2\nprint(find_Divisor(5,10)) # Expected output: 2",
    "test_cases": [
      "assert find_Divisor(2,2) == 2",
      "assert find_Divisor(2,5) == 2",
      "assert find_Divisor(5,10) == 2"
    ]
  },
  {
    "mbpp_id": 340,
    "problem_statement": "Write a python function to find the sum of the three lowest positive numbers from a given list of numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sum_three_smallest_nums(nums):\n    # Sort the list in ascending order and remove duplicates if any\n    nums = sorted(set(nums))\n    \n    # Calculate the sum of the first three elements after removing duplicates\n    return sum(nums[:3])\n\n# Example usage:\nprint(sum_three_smallest_nums([10,20,30,40,50,60,7]))  # Output: 37\nprint(sum_three_smallest_nums([1,2,3,4,5]))           # Output: 6\nprint(sum_three_smallest_nums([0,1,2,3,4,5]))         # Output: 6",
    "test_cases": [
      "assert sum_three_smallest_nums([10,20,30,40,50,60,7]) == 37",
      "assert sum_three_smallest_nums([1,2,3,4,5]) == 6",
      "assert sum_three_smallest_nums([0,1,2,3,4,5]) == 6"
    ]
  },
  {
    "mbpp_id": 341,
    "problem_statement": "Write a function to convert the given set into ordered tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def set_to_tuple(input_set):\n    # Convert each element in the input set to an ordered tuple and return as a list of tuples\n    return [(x,) for x in sorted(input_set)]",
    "test_cases": [
      "assert set_to_tuple({1, 2, 3, 4, 5}) == (1, 2, 3, 4, 5)",
      "assert set_to_tuple({6, 7, 8, 9, 10, 11}) == (6, 7, 8, 9, 10, 11)",
      "assert set_to_tuple({12, 13, 14, 15, 16}) == (12, 13, 14, 15, 16)"
    ]
  },
  {
    "mbpp_id": 342,
    "problem_statement": "Write a function to find the smallest range that includes at-least one element from each of the given arrays.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List, Tuple\nimport heapq\n\ndef find_minimum_range(arrays: List[List[int]]) -> Tuple[int, int]:\n    if not arrays:\n        return (-1, -1)\n\n    # Use heap to maintain the min-heap of the first elements of each array\n    max_heap = []\n    for i in range(len(arrays)):\n        heapq.heappush(max_heap, (arrays[i][0], i, 0))\n\n    min_start, max_end = -1, -1\n    result_min = float('inf')\n    result_max = -float('inf')\n\n    while len(max_heap) > 0:\n        current_val, arr_id, idx = heapq.heappop(max_heap)\n        \n        if min_start == -1:\n            min_start = current_val\n        \n        if idx + 1 < len(arrays[arr_id]):\n            next_value = arrays[arr_id][idx + 1]\n            new_idx = idx + 1\n            heapq.heappush(max_heap, (next_value, arr_id, new_idx))\n            result_min = min(result_min, current_val)\n            result_max = max(result_max, current_val)\n        else:\n            result_min = min(result_min, current_val)\n            result_max = max(result_max, current_val)\n            \n            break\n\n    return (result_min, result_max)",
    "test_cases": [
      "assert find_minimum_range([[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]]) == (4, 6)",
      "assert find_minimum_range([[ 2, 3, 4, 8, 10, 15 ], [1, 5, 12], [7, 8, 15, 16], [3, 6]]) == (4, 7)",
      "assert find_minimum_range([[4, 7, 9, 11, 16], [2, 6, 13], [5, 9, 16, 17], [3, 7]]) == (5, 7)"
    ]
  },
  {
    "mbpp_id": 343,
    "problem_statement": "Write a function to calculate the number of digits and letters in a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def dig_let(s):\n    count = {'d': 0, 'l': 0}\n    for char in s:\n        if 'a' <= char <= 'z':\n            count['l'] += 1\n        elif '0' <= char <= '9':\n            count['d'] += 1\n    return (count['d'], count['l'])",
    "test_cases": [
      "assert dig_let(\"python\")==(6,0)",
      "assert dig_let(\"program\")==(7,0)",
      "assert dig_let(\"python3.0\")==(6,2)"
    ]
  },
  {
    "mbpp_id": 344,
    "problem_statement": "Write a python function to find number of elements with odd factors in a given range.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Odd_Squares(start, end):\n    def is_odd_factor(n):\n        # Check if n has an odd factor other than 1 and itself\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return True\n        return False\n    \n    # Count numbers within the range that have at least one odd factor\n    count = sum(is_odd_factor(i) for i in range(start, end+1))\n    \n    return count",
    "test_cases": [
      "assert count_Odd_Squares(5,100) == 8",
      "assert count_Odd_Squares(8,65) == 6",
      "assert count_Odd_Squares(2,5) == 1"
    ]
  },
  {
    "mbpp_id": 345,
    "problem_statement": "Write a function to find the difference between two consecutive numbers in a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def diff_consecutivenums(nums):\n    diffs = []\n    for i in range(1, len(nums)):\n        diff = nums[i] - nums[i-1]\n        diffs.append(diff)\n    return diffs",
    "test_cases": [
      "assert diff_consecutivenums([1, 1, 3, 4, 4, 5, 6, 7])==[0, 2, 1, 0, 1, 1, 1]",
      "assert diff_consecutivenums([4, 5, 8, 9, 6, 10])==[1, 3, 1, -3, 4]",
      "assert diff_consecutivenums([0, 1, 2, 3, 4, 4, 4, 4, 5, 7])==[1, 1, 1, 1, 0, 0, 0, 1, 2]"
    ]
  },
  {
    "mbpp_id": 346,
    "problem_statement": "Write a function to find entringer number e(n, k).",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ZeroDivisionError: division by zero"
    ],
    "generated_code": "import math\n\ndef zigzag(n, k):\n    \"\"\"\n    Returns the value of 'e' calculated as the sum of k-th roots of n for each root from 0 to k-1.\n    \n    Parameters:\n    - n: An integer representing the base.\n    - k: A non-negative integer specifying the power exponent.\n    \n    The result is computed using an approximation method and rounded to two decimal places.\n    \"\"\"\n    # Calculate factorial of i\n    def factorial(i):\n        if i == 0 or i == 1:\n            return 1\n        else:\n            return i * factorial(i - 1)\n        \n    denominator = 1\n    for i in range(k + 1):\n        numerator = 1 / ((k - i) * math.factorial(k))\n        denominator *= numerator\n    \n    return round(denominator, 2)\n\n# Test cases\nprint(zigzag(4, 3))  # Expected output: 5.0\nprint(zigzag(4, 2))  # Expected output: 4.0\nprint(zigzag(3, 1))  # Expected output: 1.0",
    "test_cases": [
      "assert zigzag(4, 3) == 5",
      "assert zigzag(4, 2) == 4",
      "assert zigzag(3, 1) == 1"
    ]
  },
  {
    "mbpp_id": 347,
    "problem_statement": "Write a python function to count the number of squares in a rectangle.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Squares(length, breadth):\n    # Calculate the total area of rectangles with different sizes and subtracting overlaps.\n    result = ((length * breadth) + \n              (((length - 1) * breadth) + \n               (((length - 1) * (breadth - 1)) * 4))\n             )\n    \n    return result",
    "test_cases": [
      "assert count_Squares(4,3) == 20",
      "assert count_Squares(1,2) == 2",
      "assert count_Squares(2,2) == 5"
    ]
  },
  {
    "mbpp_id": 348,
    "problem_statement": "Write a function to count sequences of given length having non-negative prefix sums that can be generated by given values.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "from math import comb\n\ndef find_ways(n):\n    \"\"\"\n    Finds the number of sequences of length n where each element is greater than or equal to its predecessor,\n    and the sum of all elements in the sequence is non-negative.\n    \n    Args:\n    - n: The length of the sequence\n    \n    Returns:\n    - The number of such sequences as an integer\n    \"\"\"\n    # Calculate the total number of ways to choose indices for the first half of the sequence\n    total_ways = comb(n + 1, n // 2)\n    # Subtract the number of ways where all elements are negative (which doesn't happen since we have positive numbers)\n    valid_ways = total_ways - comb(n // 2, n % 2)\n    return int(valid_ways)\n\n# Test cases\nassert find_ways(4) == 2, \"Test case 1 failed\"\nassert find_ways(6) == 5, \"Test case 2 failed\"\nassert find_ways(8) == 14, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert find_ways(4) == 2",
      "assert find_ways(6) == 5",
      "assert find_ways(8) == 14"
    ]
  },
  {
    "mbpp_id": 349,
    "problem_statement": "Write a python function to check whether the given string is a binary string or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check(s):\n    # Check if the string contains only '0' and '1'\n    return s.isdigit()",
    "test_cases": [
      "assert check(\"01010101010\") == \"Yes\"",
      "assert check(\"name0\") == \"No\"",
      "assert check(\"101\") == \"Yes\""
    ]
  },
  {
    "mbpp_id": 350,
    "problem_statement": "Write a python function to minimize the length of the string by removing occurrence of only one character.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def minimum_Length(s):\n    if len(set(s)) == 1:\n        return 0\n    else:\n        return min([len(s) - s.count(x) for x in set(s)])",
    "test_cases": [
      "assert minimum_Length(\"mnm\") == 1",
      "assert minimum_Length(\"abcda\") == 3",
      "assert minimum_Length(\"abcb\") == 2"
    ]
  },
  {
    "mbpp_id": 351,
    "problem_statement": "Write a python function to find the first element occurring k times in a given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\nimport bisect\n\ndef first_Element(arr: List[int], n: int, k: int) -> int:\n    # First, sort the array and then perform binary search for each value.\n    arr.sort()\n    res = -1\n    for num in set(arr): \n        index = bisect.bisect_left(arr, num)\n        if len(arr) % n == index and arr[index] == num: \n            res = num\n            break\n    return res",
    "test_cases": [
      "assert first_Element([0,1,2,3,4,5],6,1) == 0",
      "assert first_Element([1,2,1,3,4],5,2) == 1",
      "assert first_Element([2,3,4,3,5,7,1,2,3,5],10,2) == 2"
    ]
  },
  {
    "mbpp_id": 352,
    "problem_statement": "Write a python function to check whether all the characters in a given string are unique.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'unique_Characters' is not defined",
      "Test 2: FAIL - name 'unique_Characters' is not defined",
      "Test 3: FAIL - name 'unique_Characters' is not defined"
    ],
    "generated_code": "def is_unique_chars(s):\n    # Convert the input string into a set of its characters\n    char_set = set(s)\n    \n    # Compare the length of the original string with the set\n    # If they are equal, it means all characters were unique\n    return len(char_set) == len(s)\n\n# Test cases\nprint(is_unique_chars('aba'))   # Expected output: False\nprint(is_unique_chars('abc'))   # Expected output: True\nprint(is_unique_chars('abab'))  # Expected output: False",
    "test_cases": [
      "assert unique_Characters('aba') == False",
      "assert unique_Characters('abc') == True",
      "assert unique_Characters('abab') == False"
    ]
  },
  {
    "mbpp_id": 353,
    "problem_statement": "Write a function to remove a specified column from a given nested list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_column(data, index):\n    return [[row[i] for i in range(len(row)) if i != index] for row in data]\n\n# Test Cases\nprint(remove_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]], 0))\nprint(remove_column([[1, 2, 3], [-2, 4, -5], [1, -1, 1]], 2))\nprint(remove_column([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]], 0))",
    "test_cases": [
      "assert remove_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]],0)==[[2, 3], [4, 5], [1, 1]]",
      "assert remove_column([[1, 2, 3], [-2, 4, -5], [1, -1, 1]],2)==[[1, 2], [-2, 4], [1, -1]]",
      "assert remove_column([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]],0)==[[3], [7], [3], [15, 17], [7], [11]]"
    ]
  },
  {
    "mbpp_id": 354,
    "problem_statement": "Write a function to find t-nth term of arithemetic progression.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: tn_ap() missing 1 required positional argument: 'd'"
    ],
    "generated_code": "def tn_ap(t,n,a,d):\n    # Calculate the nth term of an arithmetic progression\n    return a + d * (t - 1)\n\n# Test cases\nprint(tn_ap(1,5,2))   # Expected output: 9\nprint(tn_ap(2,6,4))   # Expected output: 22\nprint(tn_ap(1,4,5))   # Expected output: 16",
    "test_cases": [
      "assert tn_ap(1,5,2)==9",
      "assert tn_ap(2,6,4)==22",
      "assert tn_ap(1,4,5)==16"
    ]
  },
  {
    "mbpp_id": 355,
    "problem_statement": "Write a python function to count the number of rectangles in a circle of radius r.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def count_Rectangles(r):\n    \"\"\"\n    Counts the number of rectangles that can be formed within a circle of given radius.\n    \n    Parameters:\n    r (int): The radius of the circle.\n    \n    Returns:\n    int: The number of rectangles inside the circle.\n    \"\"\"\n    if r < 1:\n        return 0\n    \n    # Calculate the maximum possible width and height for a rectangle\n    max_width = min(r * 2 - 1, r)\n    max_height = min(r * 2 - 1, r)\n    \n    # If both dimensions are equal, it's an exact square\n    if max_width == max_height:\n        return max_width ** 2\n    \n    # For other cases, calculate total area of smaller grid squares\n    total_area = ((max_width + 1) * (max_height + 1)) // 4\n    total_diagonal_squares = ((max_width + 1) * (max_height + 1))\n    return total_area - total_diagonal_squares\n\n# Check function with provided data points\nassert count_Rectangles(2) == 8\nassert count_Rectangles(1) == 1\nassert count_Rectangles(0) == 0\n\nprint(\"All tests passed!\")",
    "test_cases": [
      "assert count_Rectangles(2) == 8",
      "assert count_Rectangles(1) == 1",
      "assert count_Rectangles(0) == 0"
    ]
  },
  {
    "mbpp_id": 356,
    "problem_statement": "Write a function to find the third angle of a triangle using two angles.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_angle(angle1, angle2):\n    # Calculate the third angle of the triangle\n    return 180 - angle1 - angle2",
    "test_cases": [
      "assert find_angle(47,89)==44",
      "assert find_angle(45,95)==40",
      "assert find_angle(50,40)==90"
    ]
  },
  {
    "mbpp_id": 357,
    "problem_statement": "Write a function to find the maximum element of all the given tuple records.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_max(tuples_list):\n    # Convert tuples into individual elements and sort them in descending order\n    max_element = sorted([max(x) for x in tuples_list], reverse=True)\n    # Return the first element from the sorted list which is the maximum value among all the lists\n    return max_element[0]\n\n# Test cases\nprint(find_max([(2, 4), (6, 7), (5, 1), (6, 10), (8, 7)]))  # Output: 10\nprint(find_max([(3, 5), (7, 8), (6, 2), (7, 11), (9, 8)]))  # Output: 11\nprint(find_max([(4, 6), (8, 9), (7, 3), (8, 12), (10, 9)]))  # Output: 12",
    "test_cases": [
      "assert find_max([(2, 4), (6, 7), (5, 1), (6, 10), (8, 7)]) == 10",
      "assert find_max([(3, 5), (7, 8), (6, 2), (7, 11), (9, 8)]) == 11",
      "assert find_max([(4, 6), (8, 9), (7, 3), (8, 12), (10, 9)]) == 12"
    ]
  },
  {
    "mbpp_id": 358,
    "problem_statement": "Write a function to find modulo division of two lists using map and lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List\n\ndef moddiv_list(list1: List[int], list2: List[int]) -> List[int]:\n    return [x % y for x, y in zip(list1, list2)]",
    "test_cases": [
      "assert moddiv_list([4,5,6],[1, 2, 3])==[0, 1, 0]",
      "assert moddiv_list([3,2],[1,4])==[0, 2]",
      "assert moddiv_list([90,120],[50,70])==[40, 50]"
    ]
  },
  {
    "mbpp_id": 359,
    "problem_statement": "Write a python function to check whether one root of the quadratic equation is twice of the other or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'sqrt' is not defined"
    ],
    "generated_code": "def Check_Solution(a,b,c):\n    # Calculate the discriminant\n    D = b**2 - 4*a*c\n    \n    # If D is negative, there are no real roots\n    if D < 0:\n        return \"No\"\n    \n    # Calculate the two roots using the quadratic formula\n    x1 = (-b + sqrt(D)) / (2*a)\n    x2 = (-b - sqrt(D)) / (2*a)\n    \n    # Check if one root is twice the other\n    if abs(x1 - 2*x2) <= 1e-8 or abs(x2 - 2*x1) <= 1e-8:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Test cases\nprint(Check_Solution(1,3,2))  # Expected output: Yes\nprint(Check_Solution(1,2,3))  # Expected output: No\nprint(Check_Solution(1,-5,6)) # Expected output: No",
    "test_cases": [
      "assert Check_Solution(1,3,2) == \"Yes\"",
      "assert Check_Solution(1,2,3) == \"No\"",
      "assert Check_Solution(1,-5,6) == \"No\""
    ]
  },
  {
    "mbpp_id": 360,
    "problem_statement": "Write a function to find the n’th carol number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_carol(n):\n    \"\"\"\n    Generate the nth Carol number.\n    \n    A Carol number is defined as:\n    C(n) = (2^n - 1)^2 + 2^(n+1)\n    \n    Args:\n    n : int -- The position of the Carol number in the sequence\n    \n    Returns:\n    int -- The nth Carol number\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return pow(2**n - 1, 2) + 2**(n + 1)\n\n# Test cases\nprint(get_carol(2)) # Expected output: 7\nprint(get_carol(4)) # Expected output: 223\nprint(get_carol(5)) # Expected output: 959",
    "test_cases": [
      "assert get_carol(2) == 7",
      "assert get_carol(4) == 223",
      "assert get_carol(5) == 959"
    ]
  },
  {
    "mbpp_id": 361,
    "problem_statement": "Write a function to remove empty lists from a given list of lists.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_empty(lst):\n    return [item for item in lst if item]",
    "test_cases": [
      "assert remove_empty([[], [], [], 'Red', 'Green', [1,2], 'Blue', [], []])==['Red', 'Green', [1, 2], 'Blue']",
      "assert remove_empty([[], [], [],[],[], 'Green', [1,2], 'Blue', [], []])==[ 'Green', [1, 2], 'Blue']",
      "assert remove_empty([[], [], [], 'Python',[],[], 'programming', 'language',[],[],[], [], []])==['Python', 'programming', 'language']"
    ]
  },
  {
    "mbpp_id": 362,
    "problem_statement": "Write a python function to find the item with maximum occurrences in a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_occurrences(lst):\n    from collections import Counter\n    # Count the occurrences of each item in the list\n    counts = Counter(lst)\n    # Find the item(s) with the highest occurrence count\n    most_common_item, _ = counts.most_common(1)[0]\n    return most_common_item",
    "test_cases": [
      "assert max_occurrences([1,2,3,1,2,3,12,4,2]) ==  2",
      "assert max_occurrences([1,2,6,7,0,1,0,1,0]) == 1,0",
      "assert max_occurrences([1,2,3,1,2,4,1]) == 1"
    ]
  },
  {
    "mbpp_id": 363,
    "problem_statement": "Write a function to add the k elements to each element in the tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def add_K_element(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        new_tup = ()\n        for i in range(len(tup)):\n            new_tup += (tup[i] + k,)\n        result.append(new_tup)\n    return result\n\n# Test cases\nprint(add_K_element([(1, 3, 4), (2, 4, 6), (3, 8, 1)], 4)) # Expected output: [(5, 7, 8), (6, 8, 10), (7, 12, 5)]\nprint(add_K_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 8)) # Expected output: [(9, 10, 11), (12, 13, 14), (15, 16, 17)]\nprint(add_K_element([(11, 12, 13), (14, 15, 16), (17, 18, 19)], 9)) # Expected output: [(20, 21, 22), (23, 24, 25), (26, 27, 28)]",
    "test_cases": [
      "assert add_K_element([(1, 3, 4), (2, 4, 6), (3, 8, 1)], 4) == [(5, 7, 8), (6, 8, 10), (7, 12, 5)]",
      "assert add_K_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 8) == [(9, 10, 11), (12, 13, 14), (15, 16, 17)]",
      "assert add_K_element([(11, 12, 13), (14, 15, 16), (17, 18, 19)], 9) == [(20, 21, 22), (23, 24, 25), (26, 27, 28)]"
    ]
  },
  {
    "mbpp_id": 364,
    "problem_statement": "Write a function to find the number of flips required to make the given binary string a sequence of alternate characters.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_flip_to_make_string_alternate(s):\n    count_0 = 0\n    count_1 = 0\n    \n    for char in s:\n        if char == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n            \n    total_flips = abs(count_0 - count_1)\n    \n    # If both counts are equal and one is even, no additional flip needed\n    if count_0 == count_1 and count_0 % 2 == 0:\n        total_flips -= 1\n        \n    return total_flips",
    "test_cases": [
      "assert min_flip_to_make_string_alternate(\"0001010111\") == 2",
      "assert min_flip_to_make_string_alternate(\"001\") == 1",
      "assert min_flip_to_make_string_alternate(\"010111011\") == 2 "
    ]
  },
  {
    "mbpp_id": 365,
    "problem_statement": "Write a python function to count the number of digits of a given number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_Digit(num):\n    if num == 0:\n        return 1\n    digit_count = 0\n    while num > 0:\n        num //= 10\n        digit_count += 1\n    return digit_count",
    "test_cases": [
      "assert count_Digit(12345) == 5",
      "assert count_Digit(11223305) == 8",
      "assert count_Digit(4123459) == 7"
    ]
  },
  {
    "mbpp_id": 366,
    "problem_statement": "Write a python function to find the largest product of the pair of adjacent elements from a given list of integers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def adjacent_num_product(nums):\n    # Initialize the maximum product variable\n    max_product = nums[0] * nums[1]\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(nums) - 1):\n        current_product = nums[i] * nums[i + 1]\n        \n        # Update max_product if the current product is greater than the max_product found so far\n        if current_product > max_product:\n            max_product = current_product\n    \n    return max_product",
    "test_cases": [
      "assert adjacent_num_product([1,2,3,4,5,6]) == 30",
      "assert adjacent_num_product([1,2,3,4,5]) == 20",
      "assert adjacent_num_product([2,3]) == 6"
    ]
  },
  {
    "mbpp_id": 367,
    "problem_statement": "Write a function to check if a binary tree is balanced or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'root' is not defined",
      "Test 2: FAIL - name 'root1' is not defined",
      "Test 3: FAIL - name 'root2' is not defined"
    ],
    "generated_code": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_tree_balanced(root):\n    \"\"\"\n    This function checks if a binary tree is balanced.\n    \n    A binary tree is considered balanced if for each node, the height difference between its left and right subtrees \n    does not exceed 1. The function returns True if the tree is balanced, otherwise False.\n    \"\"\"\n    # Base case: An empty tree is balanced\n    if root is None:\n        return True\n    \n    # Check the balance of the left subtree\n    left_balance = is_tree_balanced(root.left)\n    \n    # Check the balance of the right subtree\n    right_balance = is_tree_balanced(root.right)\n    \n    # If both children are balanced and the absolute height difference is less than or equal to 1,\n    # then the current node's subtree is balanced\n    if abs(left_balance - right_balance) <= 1 and left_balance > 0 and right_balance > 0:\n        return True\n    \n    # Otherwise, the tree is not balanced\n    return False",
    "test_cases": [
      "assert is_tree_balanced(root) == False",
      "assert is_tree_balanced(root1) == True",
      "assert is_tree_balanced(root2) == False "
    ]
  },
  {
    "mbpp_id": 368,
    "problem_statement": "Write a function to repeat the given tuple n times.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def repeat_tuples(tup, n):\n    return tup * n",
    "test_cases": [
      "assert repeat_tuples((1, 3), 4) == ((1, 3), (1, 3), (1, 3), (1, 3))",
      "assert repeat_tuples((1, 2), 3) == ((1, 2), (1, 2), (1, 2))",
      "assert repeat_tuples((3, 4), 5) == ((3, 4), (3, 4), (3, 4), (3, 4), (3, 4))"
    ]
  },
  {
    "mbpp_id": 369,
    "problem_statement": "Write a function to find the lateral surface area of cuboid",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def lateralsurface_cuboid(length, width, height):\n    return 4 * length * width",
    "test_cases": [
      "assert lateralsurface_cuboid(8,5,6)==156",
      "assert lateralsurface_cuboid(7,9,10)==320",
      "assert lateralsurface_cuboid(10,20,30)==1800"
    ]
  },
  {
    "mbpp_id": 370,
    "problem_statement": "Write a function to sort a tuple by its float element.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def float_sort(tup):\n    # Sort the list of tuples based on the second element (float)\n    return sorted(tup, key=lambda x: float(x[1]))",
    "test_cases": [
      "assert float_sort([('item1', '12.20'), ('item2', '15.10'), ('item3', '24.5')])==[('item3', '24.5'), ('item2', '15.10'), ('item1', '12.20')] ",
      "assert float_sort([('item1', '15'), ('item2', '10'), ('item3', '20')])==[('item3', '20'), ('item1', '15'), ('item2', '10')] ",
      "assert float_sort([('item1', '5'), ('item2', '10'), ('item3', '14')])==[('item3', '14'), ('item2', '10'), ('item1', '5')] "
    ]
  },
  {
    "mbpp_id": 371,
    "problem_statement": "Write a function to find the smallest missing element in a sorted array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\nimport bisect\n\ndef smallest_missing(arr: List[int], lo: int, hi: int) -> int:\n    for i in range(lo + 1, hi + 1):\n        index = bisect.bisect_left(arr, i)\n        if arr[index] != i:\n            return i\n    return hi + 1",
    "test_cases": [
      "assert smallest_missing([0, 1, 2, 3, 4, 5, 6], 0, 6) == 7",
      "assert smallest_missing([0, 1, 2, 6, 9, 11, 15], 0, 6) == 3",
      "assert smallest_missing([1, 2, 3, 4, 6, 9, 11, 15], 0, 7) == 0"
    ]
  },
  {
    "mbpp_id": 372,
    "problem_statement": "Write a function to sort a given list of elements in ascending order using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def heap_assending(lst):\n    # Convert the list into a max-heap\n    for i in range(len(lst) // 2 - 1, -1, -1):\n        _max_heapify(lst, len(lst), i)\n    \n    # Extract elements one by one from the heap\n    for i in range(len(lst) - 1, 0, -1):\n        lst[i], lst[0] = lst[0], lst[i]  # Swap the root with the last element\n        _max_heapify(lst, i, 0)\n\ndef _max_heapify(lst, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < n and lst[left] > lst[largest]:\n        largest = left\n    \n    if right < n and lst[right] > lst[largest]:\n        largest = right\n    \n    if largest != i:\n        lst[i], lst[largest] = lst[largest], lst[i]  # Swap\n        _max_heapify(lst, n, largest)\n\n# Test the function with provided data points\nprint(heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1]))  # [1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]\nprint(heap_assending([25, 35, 22, 85, 14, 65, 75, 25, 58]))  # [14, 22, 25, 25, 35, 58, 65, 75, 85]\nprint(heap_assending([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]))     # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]",
    "test_cases": [
      "assert heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1])==[1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]",
      "assert heap_assending([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]",
      "assert heap_assending([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
    ]
  },
  {
    "mbpp_id": 373,
    "problem_statement": "Write a function to find the volume of a cuboid.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def volume_cuboid(length, width, height):\n    return length * width * height",
    "test_cases": [
      "assert volume_cuboid(1,2,3)==6",
      "assert volume_cuboid(5,7,9)==315",
      "assert volume_cuboid(10,15,21)==3150"
    ]
  },
  {
    "mbpp_id": 374,
    "problem_statement": "Write a function to print all permutations of a given string including duplicates.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - 'str' object does not support item assignment",
      "Test 2: FAIL - 'str' object does not support item assignment",
      "Test 3: FAIL - 'str' object does not support item assignment"
    ],
    "generated_code": "from typing import List\n\ndef permute_string(input_str: str) -> List[str]:\n    \"\"\"\n    Generate and return all unique permutations of the input string.\n    \n    Parameters:\n    input_str (str): The string for which permutations need to be generated.\n    \n    Returns:\n    List[str]: A list containing all unique permutations of the input string.\n    \"\"\"\n    def backtrack(start=0):\n        if start == len(input_str):\n            result.append(\"\".join(input_str))\n        else:\n            for i in range(start, len(input_str)):\n                # Swap characters at current positions\n                input_str[start], input_str[i] = input_str[i], input_str[start]\n                # Recur for the remaining part of the string\n                backtrack(start + 1)\n                # Backtrack step (swap back before moving forward)\n                input_str[start], input_str[i] = input_str[i], input_str[start]\n                \n    result = []\n    backtrack()\n    return result",
    "test_cases": [
      "assert permute_string('ab')==['ab', 'ba']",
      "assert permute_string('abc')==['abc', 'bac', 'bca', 'acb', 'cab', 'cba']",
      "assert permute_string('abcd')==['abcd', 'bacd', 'bcad', 'bcda', 'acbd', 'cabd', 'cbad', 'cbda', 'acdb', 'cadb', 'cdab', 'cdba', 'abdc', 'badc', 'bdac', 'bdca', 'adbc', 'dabc', 'dbac', 'dbca', 'adcb', 'dacb', 'dcab', 'dcba']"
    ]
  },
  {
    "mbpp_id": 375,
    "problem_statement": "Write a function to round the given number to the nearest multiple of a specific number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef round_num(number, divisor):\n    \"\"\"\n    Round the input 'number' to the nearest multiple of 'divisor'.\n    \n    Parameters:\n    - number: The number to be rounded.\n    - divisor: The divisor used for rounding.\n    \n    Returns:\n    The rounded number as an integer.\n    \"\"\"\n    return int(divisor * round(float(number) / divisor))",
    "test_cases": [
      "assert round_num(4722,10)==4720",
      "assert round_num(1111,5)==1110",
      "assert round_num(219,2)==218"
    ]
  },
  {
    "mbpp_id": 376,
    "problem_statement": "Write a function to remove tuple elements that occur more than once and replace the duplicates with some custom value.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_replica(lst):\n    counter = {}\n    result = []\n    for item in lst:\n        if item not in counter:\n            counter[item] = \"MSP\"\n        else:\n            counter[item] = \"MSP\"  # Replacing duplicate items with 'MSP'\n        result.append(counter[item])\n    return tuple(result)",
    "test_cases": [
      "assert remove_replica((1, 1, 4, 4, 4, 5, 5, 6, 7, 7)) == (1, 'MSP', 4, 'MSP', 'MSP', 5, 'MSP', 6, 7, 'MSP')",
      "assert remove_replica((2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 9)) == (2, 3, 4, 'MSP', 5, 6, 'MSP', 7, 8, 9, 'MSP')",
      "assert remove_replica((2, 2, 5, 4, 5, 7, 5, 6, 7, 7)) == (2, 'MSP', 5, 4, 'MSP', 7, 'MSP', 6, 'MSP', 'MSP')"
    ]
  },
  {
    "mbpp_id": 377,
    "problem_statement": "Write a python function to remove all occurrences of a character in a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_Char(input_str, char_to_remove):\n    # Using str.replace() method to replace occurrences of the specified character with an empty string\n    modified_string = input_str.replace(char_to_remove, \"\")\n    return modified_string\n\n# Test cases to verify the correctness of the function\nprint(remove_Char(\"aba\", 'a'))  # Expected output: \"b\"\nprint(remove_Char(\"toggle\", 'g'))  # Expected output: \"tole\"\nprint(remove_Char(\"aabbc\", 'b'))  # Expected output: \"aac\"",
    "test_cases": [
      "assert remove_Char(\"aba\",'a') == \"b\"",
      "assert remove_Char(\"toggle\",'g') == \"tole\"",
      "assert remove_Char(\"aabbc\",'b') == \"aac\""
    ]
  },
  {
    "mbpp_id": 378,
    "problem_statement": "Write a python function to shift last element to first position in the given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def move_first(lst):\n    if len(lst) > 1:\n        lst[0], lst[-1] = lst[-1], lst[0]\n    return lst\n\n# Test cases\nprint(move_first([1,2,3,4]))  # Expected output: [4, 1, 2, 3]\nprint(move_first([0,1,2,3]))  # Expected output: [3, 0, 1, 2]\nprint(move_first([9,8,7,1]))  # Expected output: [1, 9, 8, 7]",
    "test_cases": [
      "assert move_first([1,2,3,4]) == [4,1,2,3]",
      "assert move_first([0,1,2,3]) == [3,0,1,2]",
      "assert move_first([9,8,7,1]) == [1,9,8,7]"
    ]
  },
  {
    "mbpp_id": 379,
    "problem_statement": "Write a function to find the surface area of a cuboid.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def surfacearea_cuboid(length, width, height):\n    # Calculate the surface area of a cuboid\n    return 2 * (length*width + length*height + width*height)",
    "test_cases": [
      "assert surfacearea_cuboid(1,2,3)==22",
      "assert surfacearea_cuboid(5,7,9)==286",
      "assert surfacearea_cuboid(10,15,21)==1350"
    ]
  },
  {
    "mbpp_id": 380,
    "problem_statement": "Write a function to generate a two-dimensional array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def multi_list(n, m):\n    return [[i * j for i in range(m)] for j in range(n)]",
    "test_cases": [
      "assert multi_list(3,4)==[[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]] ",
      "assert multi_list(5,7)==[[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 8, 10, 12], [0, 3, 6, 9, 12, 15, 18], [0, 4, 8, 12, 16, 20, 24]]",
      "assert multi_list(10,15)==[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28], [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42], [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56], [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70], [0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84], [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112], [0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99, 108, 117, 126]]"
    ]
  },
  {
    "mbpp_id": 381,
    "problem_statement": "Write a function to sort a list of lists by a given index of the inner list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def index_on_inner_list(data, idx):\n    return sorted(data, key=lambda x: x[idx])",
    "test_cases": [
      "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==[('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99), ('Wyatt Knott', 91, 94)]",
      "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,1)==[('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99)]",
      "assert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[('Wyatt Knott', 91, 94), ('Brady Kent', 97, 96), ('Beau Turnbull', 94, 98), ('Greyson Fulton', 98, 99)]"
    ]
  },
  {
    "mbpp_id": 382,
    "problem_statement": "Write a function to find the number of rotations in a circularly sorted array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_rotation_count(arr):\n    low = 0\n    high = len(arr) - 1\n    \n    while arr[low] >= arr[high]:\n        if high == low:\n            return high + 1\n        \n        mid = (low + high) // 2\n        next_mid = (mid + 1) % len(arr)\n        \n        if arr[mid] <= arr[next_mid]:\n            # If all elements after the mid point were smaller,\n            # then rotation must be on the right side.\n            low = mid + 1\n        else:\n            # Else rotation is before mid point.\n            high = mid\n            \n    return high",
    "test_cases": [
      "assert find_rotation_count([8, 9, 10, 1, 2, 3, 4, 5, 6, 7]) == 3",
      "assert find_rotation_count([8, 9, 10,2, 5, 6]) == 3",
      "assert find_rotation_count([2, 5, 6, 8, 9, 10]) == 0"
    ]
  },
  {
    "mbpp_id": 383,
    "problem_statement": "Write a python function to toggle all odd bits of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def even_bit_toggle_number(n):\n    # Initialize an empty list to store the result bits\n    result_bits = []\n    \n    # Loop through each bit position from 0 to 31 (binary range)\n    for i in range(32):\n        # Check if the current bit is set (odd position)\n        if n & (1 << i): \n            # If set, invert it (toggle it)\n            result_bits.append('1')\n        else:\n            # If not set, append '0'\n            result_bits.append('0')\n    \n    # Convert the list of bits back to an integer and return\n    return int(''.join(result_bits), 2)\n\n# Example usage:\nprint(even_bit_toggle_number(10))  # Output should be 15\nprint(even_bit_toggle_number(20))  # Output should be 1\nprint(even_bit_toggle_number(30))  # Output should be 11",
    "test_cases": [
      "assert even_bit_toggle_number(10) == 15",
      "assert even_bit_toggle_number(20) == 1",
      "assert even_bit_toggle_number(30) == 11"
    ]
  },
  {
    "mbpp_id": 384,
    "problem_statement": "Write a python function to find the frequency of the smallest value in a given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def frequency_Of_Smallest(n,arr):\n    # Find the smallest element in the array\n    min_val = min(arr)\n    \n    # Count how many times the smallest element appears in the array\n    count = arr.count(min_val)\n    \n    # Return the count of occurrences of the smallest element\n    return count",
    "test_cases": [
      "assert frequency_Of_Smallest(5,[1,2,3,4,3]) == 1",
      "assert frequency_Of_Smallest(7,[3,1,2,5,6,2,3]) == 1",
      "assert frequency_Of_Smallest(7,[3,3,6,3,7,4,9]) == 3"
    ]
  },
  {
    "mbpp_id": 385,
    "problem_statement": "Write a function to find the n'th perrin number using recursion.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - RecursionError: maximum recursion depth exceeded in comparison"
    ],
    "generated_code": "def get_perrin(n):\n    \"\"\"\n    This function calculates the nth Perrin number recursively.\n    \n    Parameters:\n    n (int): The position in the sequence of Perrin numbers.\n    \n    Returns:\n    int: The nth Perrin number.\n    \"\"\"\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    else:\n        return get_perrin(n - 2) + get_perrin(n - 3)\n\n# Check function with provided data points\nassert get_perrin(9) == 12\nassert get_perrin(4) == 2\nassert get_perrin(6) == 5\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert get_perrin(9) == 12",
      "assert get_perrin(4) == 2",
      "assert get_perrin(6) == 5"
    ]
  },
  {
    "mbpp_id": 386,
    "problem_statement": "Write a function to find out the minimum no of swaps required for bracket balancing in the given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def swap_count(s):\n    count = 0\n    stack = []\n    \n    for char in s:\n        if char == '[':\n            stack.append(char)\n        else:\n            if not stack:\n                count += 1\n            elif stack[-1] == '[':\n                stack.pop()\n    \n    # Count remaining brackets on the stack\n    count += len(stack) // 2\n    \n    return count",
    "test_cases": [
      "assert swap_count(\"[]][][\") == 2",
      "assert swap_count(\"[[][]]\") == 0",
      "assert swap_count(\"[[][]]][\") == 1"
    ]
  },
  {
    "mbpp_id": 387,
    "problem_statement": "Write a python function to check whether the hexadecimal number is even or odd.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def even_or_odd(hex_num):\n    # Convert hex string to int and then to str in base 16 for easier manipulation of digits.\n    decimal_value = int(hex_num, 16)\n    # Check if the last digit of the binary representation of decimal value makes it even or odd.\n    if decimal_value % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n\n# Test cases\nprint(even_or_odd(\"AB3454D\"))  # Output: Odd\nprint(even_or_odd(\"ABC\"))      # Output: Even\nprint(even_or_odd(\"AAD\"))      # Output: Odd",
    "test_cases": [
      "assert even_or_odd(\"AB3454D\") ==\"Odd\"",
      "assert even_or_odd(\"ABC\") == \"Even\"",
      "assert even_or_odd(\"AAD\") == \"Odd\""
    ]
  },
  {
    "mbpp_id": 388,
    "problem_statement": "Write a python function to find the highest power of 2 that is less than or equal to n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def highest_Power_of_2(n):\n    # Initialize the result as 1\n    result = 1\n    \n    # Loop until the current result exceeds n\n    while result <= n:\n        # Double the result to get the next lower power of 2\n        result *= 2\n    \n    # Return the result which will be the highest power of 2 less than or equal to n\n    return result - 1",
    "test_cases": [
      "assert highest_Power_of_2(10) == 8",
      "assert highest_Power_of_2(19) == 16",
      "assert highest_Power_of_2(32) == 32"
    ]
  },
  {
    "mbpp_id": 389,
    "problem_statement": "Write a function to find the n'th lucas number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b",
    "test_cases": [
      "assert find_lucas(9) == 76",
      "assert find_lucas(4) == 7",
      "assert find_lucas(3) == 4"
    ]
  },
  {
    "mbpp_id": 390,
    "problem_statement": "Write a function to insert a given string at the beginning of all items in a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def add_string(lst, s):\n    return [s + str(i) for i in lst]",
    "test_cases": [
      "assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']",
      "assert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']",
      "assert add_string([5,6,7,8],'string{0}')==['string5', 'string6', 'string7', 'string8']"
    ]
  },
  {
    "mbpp_id": 391,
    "problem_statement": "Write a function to convert more than one list to nested dictionary.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: Keys and values must have the same length."
    ],
    "generated_code": "from typing import List, Dict\n\ndef convert_list_dictionary(keys: List[str], values: List[int], dict_: Dict) -> Dict:\n    \"\"\"\n    Converts lists of keys and values into a nested dictionary structure.\n    \n    Parameters:\n    - keys (List[str]): A list of string keys for the top-level dictionary entries.\n    - values (List[int]): A list of integer values corresponding to each key.\n    - dict_ (Dict): The initial dictionary to which new entries will be added.\n    \n    Returns:\n    - Dict: A nested dictionary with top-level keys derived from 'keys' and inner dictionary structures based on 'values'.\n    \"\"\"\n    if not all(len(x) == len(y) for x, y in zip(keys, values)):\n        raise ValueError(\"Keys and values must have the same length.\")\n    for k, v in zip(keys, values):\n        if k not in dict_.keys():\n            dict_[k] = {}\n        dict_[k].update({str(v): {}})\n    return dict_\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1\n    print(convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],\n                                  [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"],\n                                  {}))\n    # Test case 2\n    print(convert_list_dictionary([\"abc\", \"def\", \"ghi\", \"jkl\"],\n                                  [\"python\", \"program\", \"language\", \"programs\"],\n                                  {}))\n    # Test case 3\n    print(convert_list_dictionary([\"A1\", \"A2\", \"A3\", \"A4\"],\n                                  [10, 20, 30, 40],\n                                  {}))",
    "test_cases": [
      "assert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]",
      "assert convert_list_dictionary([\"abc\",\"def\",\"ghi\",\"jkl\"],[\"python\",\"program\",\"language\",\"programs\"],[100,200,300,400])==[{'abc':{'python':100}},{'def':{'program':200}},{'ghi':{'language':300}},{'jkl':{'programs':400}}]",
      "assert convert_list_dictionary([\"A1\",\"A2\",\"A3\",\"A4\"],[\"java\",\"C\",\"C++\",\"DBMS\"],[10,20,30,40])==[{'A1':{'java':10}},{'A2':{'C':20}},{'A3':{'C++':30}},{'A4':{'DBMS':40}}]"
    ]
  },
  {
    "mbpp_id": 392,
    "problem_statement": "Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def get_max_sum(n):\n    \"\"\"\n    Calculate the maximum sum possible using the formula f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    :param n: Integer value.\n    :return: Maximum sum for the given integer n.\n    \"\"\"\n    def helper(x):\n        if x <= 4:\n            return x * (x - 1) // 2  # Sum of first x natural numbers\n        else:\n            return max(helper(x // 2), helper(x // 3), helper(x // 4), helper(x // 5)) + x\n    \n    result = helper(n)\n    return result if isinstance(result, int) else -1  # Ensuring result is an integer\n\n# Test cases to verify the correctness of the solution\nassert get_max_sum(60) == 106\nassert get_max_sum(10) == 12\nassert get_max_sum(2) == 2",
    "test_cases": [
      "assert get_max_sum(60) == 106",
      "assert get_max_sum(10) == 12",
      "assert get_max_sum(2) == 2"
    ]
  },
  {
    "mbpp_id": 393,
    "problem_statement": "Write a function to find the list with maximum length using lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\n\ndef max_length_list(lst: List[List[int]]) -> tuple:\n    return max((len(sublist), sublist) for sublist in lst)[1]",
    "test_cases": [
      "assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])",
      "assert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(5,[1,2,3,4,5])",
      "assert max_length_list([[3,4,5],[6,7,8,9],[10,11,12]])==(4,[6,7,8,9])"
    ]
  },
  {
    "mbpp_id": 394,
    "problem_statement": "Write a function to check if given tuple is distinct or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_distinct(input_tuple):\n    # Convert all elements in the tuple to strings and sort them.\n    sorted_str_elements = sorted(str(element) for element in input_tuple)\n    \n    # Check if there are consecutive duplicate elements in the list of stringified elements.\n    for i in range(len(sorted_str_elements)-1):\n        if sorted_str_elements[i] == sorted_str_elements[i+1][:len(sorted_str_elements[i])]:\n            return False\n    \n    # If no consecutive duplicates were found, return True.\n    return True\n\n# Test cases\nassert check_distinct((1, 4, 5, 6, 1, 4)) == False\nassert check_distinct((1, 4, 5, 6)) == True\nassert check_distinct((2, 3, 4, 5, 6)) == True",
    "test_cases": [
      "assert check_distinct((1, 4, 5, 6, 1, 4)) == False",
      "assert check_distinct((1, 4, 5, 6)) == True",
      "assert check_distinct((2, 3, 4, 5, 6)) == True"
    ]
  },
  {
    "mbpp_id": 395,
    "problem_statement": "Write a python function to find the first non-repeated character in a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def first_non_repeating_character(s):\n    # Initialize dictionaries to keep track of characters and their counts\n    char_count = {}\n    last_index = {}\n\n    for i, c in enumerate(s):\n        if c not in char_count:\n            char_count[c] = 0\n            last_index[c] = -1\n        char_count[c] += 1\n        last_index[c] = i\n\n    # Find the first character with count 1\n    for c in s:\n        if char_count[c] == 1:\n            return c\n    return None",
    "test_cases": [
      "assert first_non_repeating_character(\"abcabc\") == None",
      "assert first_non_repeating_character(\"abc\") == \"a\"",
      "assert first_non_repeating_character(\"ababc\") == \"c\""
    ]
  },
  {
    "mbpp_id": 396,
    "problem_statement": "Write a function to check whether the given string starts and ends with the same character or not using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef check_char(s):\n    \"\"\"\n    This function checks if the input string s starts and ends with the same character.\n    It uses regular expressions to find the first occurrence of each character in the string,\n    then checks if the last character is equal to the first one. The result is either 'Valid'\n    or 'Invalid' based on the comparison.\n    \"\"\"\n    # Find all characters except the last one\n    chars = re.findall(r'.', s)\n    \n    # Check if there's more than one unique character and compare the first and last found characters\n    if len(set(chars)) > 1:\n        return \"Invalid\"\n    elif chars[-1] == s[0]:\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n\n# Test cases\nprint(check_char(\"abba\"))  # Expected output: Valid\nprint(check_char(\"a\"))     # Expected output: Valid\nprint(check_char(\"abcd\"))  # Expected output: Invalid",
    "test_cases": [
      "assert check_char(\"abba\") == \"Valid\"",
      "assert check_char(\"a\") == \"Valid\"",
      "assert check_char(\"abcd\") == \"Invalid\""
    ]
  },
  {
    "mbpp_id": 397,
    "problem_statement": "Write a function to find the median of three specific numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def median_numbers(a, b, c):\n    # Sort the list of numbers in ascending order\n    sorted_list = sorted([a, b, c])\n    # Calculate the median based on whether the length of the list is odd or even\n    if len(sorted_list) % 2 == 0:\n        return float(sorted_list[1])  # Median is between the two middle numbers when the list has an even number of elements\n    else:\n        return float(sorted_list[len(sorted_list) // 2])  # Median is the middle number when the list has an odd number of elements",
    "test_cases": [
      "assert median_numbers(25,55,65)==55.0",
      "assert median_numbers(20,10,30)==20.0",
      "assert median_numbers(15,45,75)==45.0"
    ]
  },
  {
    "mbpp_id": 398,
    "problem_statement": "Write a function to compute the sum of digits of each number of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_of_digits(numbers):\n    total = 0\n    for num in numbers:\n        if isinstance(num, int) or isinstance(num, float): # Check if it's an integer or float\n            total += sum(int(digit) for digit in str(abs(num)))\n        elif isinstance(num, str): # Check if it's a string and contains only digits\n            total += sum(int(digit) for digit in num)\n        else:\n            continue\n    return total",
    "test_cases": [
      "assert sum_of_digits([10,2,56])==14",
      "assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19",
      "assert sum_of_digits([10,20,-4,5,-70])==19"
    ]
  },
  {
    "mbpp_id": 399,
    "problem_statement": "Write a function to perform the mathematical bitwise xor operation across the given tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def bitwise_xor(tup1, tup2):\n    result = tuple(x ^ y for x, y in zip(tup1, tup2))\n    return result",
    "test_cases": [
      "assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)",
      "assert bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)",
      "assert bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)"
    ]
  },
  {
    "mbpp_id": 400,
    "problem_statement": "Write a function to extract the frequency of unique tuples in the given list order irrespective.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import Counter\n\ndef extract_freq(lst):\n    # Count the occurrences of each tuple\n    counts = Counter(tuple(sorted(item)) for item in lst)\n    # Return the sum of frequencies\n    return sum(counts.values())",
    "test_cases": [
      "assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3",
      "assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4",
      "assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4"
    ]
  },
  {
    "mbpp_id": 401,
    "problem_statement": "Write a function to perform index wise addition of tuple elements in the given two nested tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def add_nested_tuples(tup1, tup2):\n    result = []\n    for i in range(len(tup1)):\n        result.append(tuple(x + y for x, y in zip(tup1[i], tup2[i])))\n    return result",
    "test_cases": [
      "assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))",
      "assert add_nested_tuples(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((9, 12), (9, 16), (5, 12), (10, 15))",
      "assert add_nested_tuples(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((11, 14), (11, 18), (7, 14), (12, 17))"
    ]
  },
  {
    "mbpp_id": 402,
    "problem_statement": "Write a function to compute the value of ncr%p.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\ndef ncr_modp(n, k, p):\n    return ((math.factorial(n) // (math.factorial(k) * math.factorial(n - k))) % p)",
    "test_cases": [
      "assert ncr_modp(10,2,13)==6",
      "assert ncr_modp(15,12,43)==25",
      "assert ncr_modp(17,9,18)==10"
    ]
  },
  {
    "mbpp_id": 403,
    "problem_statement": "Write a function to check if a url is valid or not using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef is_valid_URL(url):\n    pattern = r'^https?://[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}:[/][/]?[\\w@%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}(:(\\d+))?$'\n    if re.match(pattern, url) and '//' in url:\n        return True\n    else:\n        return False\n\n# Test cases\nprint(is_valid_URL(\"https://www.google.com\")) # Expected output: True\nprint(is_valid_URL(\"https:/www.gmail.com\")) # Expected output: False\nprint(is_valid_URL(\"https:// www.redit.com\")) # Expected output: False",
    "test_cases": [
      "assert is_valid_URL(\"https://www.google.com\") == True",
      "assert is_valid_URL(\"https:/www.gmail.com\") == False",
      "assert is_valid_URL(\"https:// www.redit.com\") == False"
    ]
  },
  {
    "mbpp_id": 404,
    "problem_statement": "Write a python function to find the minimum of two numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def minimum(a, b):\n    if a <= b:\n        return a\n    else:\n        return b",
    "test_cases": [
      "assert minimum(1,2) == 1",
      "assert minimum(-5,-4) == -5",
      "assert minimum(0,0) == 0"
    ]
  },
  {
    "mbpp_id": 405,
    "problem_statement": "Write a function to check whether an element exists within a tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_tuplex(tup, elem):\n    return elem in tup",
    "test_cases": [
      "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True",
      "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'5')==False",
      "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\",\"e\"),3)==True"
    ]
  },
  {
    "mbpp_id": 406,
    "problem_statement": "Write a python function to find the parity of a given number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_Parity(num):\n    \"\"\"\n    This function calculates the parity of a given integer.\n    \n    Parameters:\n        num (int): The integer whose parity needs to be found\n    \n    Returns:\n        str: 'Even Parity' if the number is even, otherwise 'Odd Parity'\n    \"\"\"\n    # Check if the number is even or odd and return the appropriate message\n    return \"Even Parity\" if num % 2 == 0 else \"Odd Parity\"\n\n# Function to check the correctness of the solution with provided data points\ndef check_solution():\n    assert find_Parity(12) == \"Even Parity\", \"Test case 1 failed\"\n    assert find_Parity(7) == \"Odd Parity\", \"Test case 2 failed\"\n    assert find_Parity(10) == \"Even Parity\", \"Test case 3 failed\"\n    print(\"All test cases passed!\")\n\ncheck_solution()",
    "test_cases": [
      "assert find_Parity(12) == \"Even Parity\"",
      "assert find_Parity(7) == \"Odd Parity\"",
      "assert find_Parity(10) == \"Even Parity\""
    ]
  },
  {
    "mbpp_id": 407,
    "problem_statement": "Write a function to create the next bigger number by rearranging the digits of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "from itertools import permutations\n\ndef find_next_bigger_number(n):\n    \"\"\"\n    Finds and returns the next bigger number formed by the digits of the given number n.\n    \n    Parameters:\n    - n: Integer\n    \n    Returns:\n    - A tuple (next_biggest_number, is_found) where 'is_found' is True if a larger number was found, False otherwise.\n      The first element in the tuple is the next bigger number.\n      \n    Example usage:\n    >>> find_next_bigger_number(12)\n    (21, True)\n    >>> find_next_bigger_number(99)\n    (99, False)\n    >>> find_next_bigger_number(2017)\n    (2071, True)\n    \"\"\"\n    # Convert the number to a list of its digits for easy manipulation\n    digits = [int(digit) for digit in str(n)]\n    length = len(digits)\n\n    # Try all possible rotations of the number as potential candidates for the next bigger number\n    for i in range(length-1):\n        if digits[i] < digits[i+1]:\n            break\n    else:\n        # If no such rotation exists, there's no greater number we can form with these digits\n        return None, False\n\n    next_num_list = list(permutations(digits[:i]+digits[i+1:], length-i))\n    next_num_str = ''.join(str(num) for num in next_num_list).lstrip('0')\n\n    # Handle the case when next_num_str becomes an empty string which means no valid permutation exists\n    if not next_num_str:\n        return None, False\n\n    next_num = int(next_num_str)\n\n    return next_num, True\n\n# Test cases to verify the correctness of the generated function\nassert find_next_bigger_number(12) == (21, True), \"Test case 1 failed\"\nassert find_next_bigger_number(10) == (False, True), \"Test case 2 failed\"\nassert find_next_bigger_number(102) == (120, True), \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert rearrange_bigger(12)==21",
      "assert rearrange_bigger(10)==False",
      "assert rearrange_bigger(102)==120"
    ]
  },
  {
    "mbpp_id": 408,
    "problem_statement": "Write a function to find k number of pairs which consist of one element from the first array and one element from the second array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n    Finds k smallest pairs where each pair consists of elements from two given lists.\n    \n    :param nums1: List of integers.\n    :param nums2: List of integers.\n    :param k: Integer representing the number of smallest pairs to find.\n    :return: A list of integer arrays, each containing a pair from the input lists with the smallest sum.\n    \"\"\"\n    result = []\n    # Sort pairs based on their sum in ascending order\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            result.append([nums1[i], nums2[j]])\n    return result[:k]",
    "test_cases": [
      "assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]",
      "assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]",
      "assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]"
    ]
  },
  {
    "mbpp_id": 409,
    "problem_statement": "Write a function to find the minimum product from the pairs of tuples within a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_product_tuple(tuples_list):\n    # Find the smallest and largest numbers in the tuples\n    smallest_num = min(min(t) for t in tuples_list)\n    largest_num = max(max(t) for t in tuples_list)\n\n    # Calculate the minimum product using the smallest and largest numbers\n    min_product = smallest_num * largest_num\n    return min_product",
    "test_cases": [
      "assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8",
      "assert min_product_tuple([(10,20), (15,2), (5,10)] )==30",
      "assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100"
    ]
  },
  {
    "mbpp_id": 410,
    "problem_statement": "Write a function to find the minimum value in a given heterogeneous list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def min_val(lst):\n    return min([item for item in lst if isinstance(item, (int, float))])",
    "test_cases": [
      "assert min_val(['Python', 3, 2, 4, 5, 'version'])==2",
      "assert min_val(['Python', 15, 20, 25])==15",
      "assert min_val(['Python', 30, 20, 40, 50, 'version'])==20"
    ]
  },
  {
    "mbpp_id": 411,
    "problem_statement": "Write a function to convert the given snake case string to camel case string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef snake_to_camel(snake_str):\n    # Split the input string by underscore and capitalize each word except the first one.\n    words = snake_str.split('_')\n    # Join the capitalized words together into a single string.\n    camel_case_str = ''.join(word.capitalize() for word in words)\n    return camel_case_str",
    "test_cases": [
      "assert snake_to_camel('android_tv') == 'AndroidTv'",
      "assert snake_to_camel('google_pixel') == 'GooglePixel'",
      "assert snake_to_camel('apple_watch') == 'AppleWatch'"
    ]
  },
  {
    "mbpp_id": 412,
    "problem_statement": "Write a python function to remove odd numbers from a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_odd(nums):\n    # Filter out odd numbers and convert back to list type if necessary\n    result = [num for num in nums if not num % 2]\n    return result",
    "test_cases": [
      "assert remove_odd([1,2,3]) == [2]",
      "assert remove_odd([2,4,6]) == [2,4,6]",
      "assert remove_odd([10,20,3]) == [10,20]"
    ]
  },
  {
    "mbpp_id": 413,
    "problem_statement": "Write a function to extract the nth element from a given list of tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def extract_nth_element(lst, n):\n    return [x[n] for x in lst]\n\n# Test cases\nprint(extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 0))\nprint(extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 2))\nprint(extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)], 1))",
    "test_cases": [
      "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']",
      "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[99, 96, 94, 98]",
      "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],1)==[98, 97, 91, 94]"
    ]
  },
  {
    "mbpp_id": 414,
    "problem_statement": "Write a python function to check whether the value exists in a sequence or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def overlapping(sequence1, sequence2):\n    # Check if all elements of sequence1 are contained within sequence2\n    return all(x in sequence2 for x in sequence1)\n\n# Test cases\nprint(overlapping([1,2,3,4,5], [6,7,8,9]))  # Expected output: False\nprint(overlapping([1,2,3], [4,5,6]))        # Expected output: False\nprint(overlapping([1,4,5], [1,4,5]))         # Expected output: True",
    "test_cases": [
      "assert overlapping([1,2,3,4,5],[6,7,8,9]) == False",
      "assert overlapping([1,2,3],[4,5,6]) == False",
      "assert overlapping([1,4,5],[1,4,5]) == True"
    ]
  },
  {
    "mbpp_id": 415,
    "problem_statement": "Write a python function to find a pair with highest product from a given array of integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_Product(nums):\n    \"\"\"\n    Finds two numbers in the given list whose multiplication is maximum.\n    \n    Parameters:\n    nums (List[int]): A list of integers.\n    \n    Returns:\n    Tuple[int]: A tuple containing the two integers with the highest product.\n    \"\"\"\n    # Initialize variables to store the maximum and second maximum products\n    max_product = float('-inf')\n    second_max_product = float('-inf')\n\n    for num in nums:\n        if num > max_product:\n            # Update max_product and second_max_product\n            second_max_product = max_product\n            max_product = num\n        elif num > second_max_product:\n            # Update second_max_product\n            second_max_product = num\n\n    return (max_product, second_max_product)\n\n# Test cases\nprint(max_Product([1,2,3,4,7,0,8,4]))  # Expected output: (7, 8)\nprint(max_Product([0,-1,-2,-4,5,0,-6]))  # Expected output: (-4, -6)\nprint(max_Product([1,2,3]))  # Expected output: (2, 3)",
    "test_cases": [
      "assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)",
      "assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)",
      "assert max_Product([1,2,3]) == (2,3)"
    ]
  },
  {
    "mbpp_id": 416,
    "problem_statement": "Write a function to find the maximum sum we can make by dividing number in three parts recursively and summing them up together for the given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - list index out of range",
      "Test 2: FAIL - list index out of range",
      "Test 3: FAIL - list index out of range"
    ],
    "generated_code": "def breakSum(num):\n    def helper(n, count, memo):\n        if n == 0:\n            return count * n\n        elif memo[n] is not None:\n            return memo[n]\n        max_sum = float('-inf')\n        for i in range(1, int(n ** 0.5) + 1):\n            current_sum = helper(n - i**2, count + 1, memo)\n            max_sum = max(max_sum, current_sum)\n        memo[n] = max_sum\n        return max_sum\n    \n    memo = [None] * num\n    result = helper(num, 0, memo)\n    return result",
    "test_cases": [
      "assert breakSum(12) == 13",
      "assert breakSum(24) == 27",
      "assert breakSum(23) == 23"
    ]
  },
  {
    "mbpp_id": 417,
    "problem_statement": "Write a function to find common first element in given list of tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'itertools' is not defined",
      "Test 2: FAIL - name 'itertools' is not defined",
      "Test 3: FAIL - name 'itertools' is not defined"
    ],
    "generated_code": "def group_tuples(tuples_list):\n    # Extract the first element from each tuple and sort them alphabetically.\n    sorted_elements = sorted(set(map(lambda x: x[0], tuples_list)))\n    \n    # Generate all possible combinations of the sorted elements as a new list of tuples.\n    combinations = [tuple(sorted_element) for sorted_element in itertools.product(*zip(*sorted_elements))]\n    \n    return combinations",
    "test_cases": [
      "assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]",
      "assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]",
      "assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]"
    ]
  },
  {
    "mbpp_id": 418,
    "problem_statement": "Write a python function to find the sublist having maximum length.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def Find_Max(L):\n    # Initialize variables to store the longest sublist and its index\n    max_length = -1\n    result_index = -1\n    \n    # Iterate through each sublist in L\n    for i in range(len(L)):\n        if len(L[i]) > max_length:\n            max_length = len(L[i])\n            result_index = i\n            \n    # Return the sublist with the maximum length at the stored index\n    return L[result_index]\n\n# Test cases\nprint(Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]))  # Expected output: ['A', 'B', 'C']\nprint(Find_Max([[1], [1, 2], [1, 2, 3]]))             # Expected output: [1, 2, 3]\nprint(Find_Max([[1, 1], [1, 2, 3], [1, 5, 6, 1]]))    # Expected output: [1, 5, 6, 1]",
    "test_cases": [
      "assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']",
      "assert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]",
      "assert Find_Max([[1,1],[1,2,3],[1,5,6,1]]) == [1,5,6,1]"
    ]
  },
  {
    "mbpp_id": 419,
    "problem_statement": "Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List\n\ndef round_and_sum(numbers: List[float]) -> int:\n    rounded_numbers = [round(num) for num in numbers]\n    return sum(rounded_numbers) * len(numbers)",
    "test_cases": [
      "assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243",
      "assert round_and_sum([5,2,9,24.3,29])==345",
      "assert round_and_sum([25.0,56.7,89.2])==513"
    ]
  },
  {
    "mbpp_id": 420,
    "problem_statement": "Write a python function to find the cube sum of first n even natural numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def cube_Sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        even_num = 2 * i\n        total += even_num ** 3\n    return total",
    "test_cases": [
      "assert cube_Sum(2) == 72",
      "assert cube_Sum(3) == 288",
      "assert cube_Sum(4) == 800"
    ]
  },
  {
    "mbpp_id": 421,
    "problem_statement": "Write a function to concatenate each element of tuple by the delimiter.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def concatenate_tuple(test_tuple):\n    # Use join method with delimiter \"-\" between elements in the tuple\n    result = \"-\".join(str(i) for i in test_tuple)\n    return result\n\n# Test cases\nprint(concatenate_tuple((\"ID\", \"is\", 4, \"UTS\")))  # Output: ID-is-4-UTS\nprint(concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\")))  # Output: QWE-is-4-RTY\nprint(concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\")))   # Output: ZEN-is-4-OP",
    "test_cases": [
      "assert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == 'ID-is-4-UTS'",
      "assert concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\") ) == 'QWE-is-4-RTY'",
      "assert concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\") ) == 'ZEN-is-4-OP'"
    ]
  },
  {
    "mbpp_id": 422,
    "problem_statement": "Write a python function to find the average of cubes of first n natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_Average_Of_Cube(n):\n    # Calculate sum of cubes using arithmetic progression formula and divide it by n\n    return (n * (n + 1) * (2*n + 1)) / 6 / n",
    "test_cases": [
      "assert find_Average_Of_Cube(2) == 4.5",
      "assert find_Average_Of_Cube(3) == 12",
      "assert find_Average_Of_Cube(1) == 1"
    ]
  },
  {
    "mbpp_id": 423,
    "problem_statement": "Write a function to solve gold mine problem.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_maxgold(mine_field, rows, cols):\n    # Initialize the DP table with zeros\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Calculate the maximum gold possible starting from each cell\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                dp[i][j] = mine_field[i][j]\n            elif i > 0 and j == 0:\n                dp[i][j] = dp[i-1][j] + mine_field[i][j]\n            elif i == 0 and j > 0:\n                dp[i][j] = dp[i][j-1] + mine_field[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + mine_field[i][j]\n                \n    return dp[-1][-1]\n\n# Test cases\nprint(get_maxgold([[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]],4,4))  # Expected output: 16\nprint(get_maxgold([[10,20],[30,40]],2,2))  # Expected output: 70\nprint(get_maxgold([[4,9],[3,7]],2,2))  # Expected output: 13",
    "test_cases": [
      "assert get_maxgold([[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]],4,4)==16",
      "assert get_maxgold([[10,20],[30,40]],2,2)==70",
      "assert get_maxgold([[4,9],[3,7]],2,2)==13"
    ]
  },
  {
    "mbpp_id": 424,
    "problem_statement": "Write a function to extract only the rear index element of each string in the given tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def extract_rear(strings_tuple):\n    return [string[-1] for string in strings_tuple]\n\n# Test cases\nprint(extract_rear(('Mers', 'for', 'Vers')))  # Expected output: ['s', 'r', 's']\nprint(extract_rear(('Avenge', 'for', 'People')))  # Expected output: ['e', 'r', 'e']\nprint(extract_rear(('Gotta', 'get', 'go')))  # Expected output: ['a', 't', 'o']",
    "test_cases": [
      "assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']",
      "assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']",
      "assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']"
    ]
  },
  {
    "mbpp_id": 425,
    "problem_statement": "Write a function to count the number of sublists containing a particular element.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_element_in_list(lst, elem):\n    return sum(1 for sublist in lst if elem in sublist)",
    "test_cases": [
      "assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3",
      "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3",
      "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1"
    ]
  },
  {
    "mbpp_id": 426,
    "problem_statement": "Write a function to filter odd numbers using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def filter_oddnumbers(nums):\n    return list(filter(lambda x: x % 2 != 0, nums))\n\n# Test cases\nprint(filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])) # Should print [1,3,5,7,9]\nprint(filter_oddnumbers([10,20,45,67,84,93]))            # Should print [45,67,93]\nprint(filter_oddnumbers([5,7,9,8,6,4,3]))               # Should print [5,7,9,3]",
    "test_cases": [
      "assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]",
      "assert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]",
      "assert filter_oddnumbers([5,7,9,8,6,4,3])==[5,7,9,3]"
    ]
  },
  {
    "mbpp_id": 427,
    "problem_statement": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef change_date_format(date_str):\n    \"\"\"\n    This function takes a string in the format \"yyyy-mm-dd\" and returns it in the format \"dd-mm-yyyy\".\n    \"\"\"\n    # Use regular expression to replace the pattern with the new order\n    return re.sub(r'(\\d{4})-(\\d{2})-(\\d{2})', r'\\3-\\2-\\1', date_str)\n\n# Test cases\nprint(change_date_format(\"2026-01-02\"))  # Expected output: '02-01-2026'\nprint(change_date_format(\"2020-11-13\"))  # Expected output: '13-11-2020'\nprint(change_date_format(\"2021-04-26\"))  # Expected output: '26-04-2021'",
    "test_cases": [
      "assert change_date_format(\"2026-01-02\") == '02-01-2026'",
      "assert change_date_format(\"2020-11-13\") == '13-11-2020'",
      "assert change_date_format(\"2021-04-26\") == '26-04-2021'"
    ]
  },
  {
    "mbpp_id": 428,
    "problem_statement": "Write a function to sort the given array by using shell sort.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr\n\n# Test the function with provided data points\nprint(shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]))  # Expected output: [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\nprint(shell_sort([24, 22, 39, 34, 87, 73, 68]))  # Expected output: [22, 24, 34, 39, 68, 73, 87]\nprint(shell_sort([32, 30, 16, 96, 82, 83, 74]))  # Expected output: [16, 30, 32, 74, 82, 83, 96]",
    "test_cases": [
      "assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]",
      "assert shell_sort([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]",
      "assert shell_sort([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]"
    ]
  },
  {
    "mbpp_id": 429,
    "problem_statement": "Write a function to extract the elementwise and tuples from the given two tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def and_tuples(tup1, tup2):\n    result = []\n    for x, y in zip(tup1, tup2):\n        result.append(x & y)\n    return tuple(result)\n\n# Test cases\nprint(and_tuples((10, 4, 6, 9), (5, 2, 3, 3))) # Output: (0, 0, 2, 1)\nprint(and_tuples((1, 2, 3, 4), (5, 6, 7, 8)))   # Output: (1, 2, 3, 0)\nprint(and_tuples((8, 9, 11, 12), (7, 13, 14, 17))) # Output: (0, 9, 10, 0)",
    "test_cases": [
      "assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)",
      "assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)",
      "assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)"
    ]
  },
  {
    "mbpp_id": 430,
    "problem_statement": "Write a function to find the directrix of a parabola.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def parabola_directrix(a,b,c):\n    return -c/(a*a) * (b*b + b*c) / a",
    "test_cases": [
      "assert parabola_directrix(5,3,2)==-198",
      "assert parabola_directrix(9,8,4)==-2336",
      "assert parabola_directrix(2,4,6)==-130"
    ]
  },
  {
    "mbpp_id": 431,
    "problem_statement": "Write a function that takes two lists and returns true if they have at least one common element.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def common_element(list1, list2):\n    return len(set(list1) & set(list2)) > 0",
    "test_cases": [
      "assert common_element([1,2,3,4,5], [5,6,7,8,9])==True",
      "assert common_element([1,2,3,4,5], [6,7,8,9])==None",
      "assert common_element(['a','b','c'], ['d','b','e'])==True"
    ]
  },
  {
    "mbpp_id": 432,
    "problem_statement": "Write a function to find the median of a trapezium.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def median_trapezium(a, b, c):\n    \"\"\"\n    Calculate the median of a trapezium with sides 'a', 'b', and 'c'.\n    \n    Parameters:\n        a (float): length of one parallel side\n        b (float): length of the other parallel side\n        c (float): height\n        \n    Returns:\n        float: Median of the trapezium\n    \"\"\"\n    return (a + b) / 2\n\n# Test cases\nprint(median_trapezium(15, 25, 35)) # Expected output: 20\nprint(median_trapezium(10, 20, 30)) # Expected output: 15\nprint(median_trapezium(6, 9, 4)) # Expected output: 7.5",
    "test_cases": [
      "assert median_trapezium(15,25,35)==20",
      "assert median_trapezium(10,20,30)==15",
      "assert median_trapezium(6,9,4)==7.5"
    ]
  },
  {
    "mbpp_id": 433,
    "problem_statement": "Write a function to check whether the entered number is greater than the elements of the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_greater(arr, num):\n    if arr[-1] < num:\n        return 'Yes, entered number is greater than those in the array'\n    else:\n        return 'No, entered number is less than those in the array'",
    "test_cases": [
      "assert check_greater([1, 2, 3, 4, 5], 4) == 'No, entered number is less than those in the array'",
      "assert check_greater([2, 3, 4, 5, 6], 8) == 'Yes, the entered number is greater than those in the array'",
      "assert check_greater([9, 7, 4, 8, 6, 1], 11) == 'Yes, the entered number is greater than those in the array'"
    ]
  },
  {
    "mbpp_id": 434,
    "problem_statement": "Write a function that matches a string that has an a followed by one or more b's.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def text_match_one(text):\n    if 'a' in text and all(x == 'b' for x in text.split('a')[1].strip()):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "test_cases": [
      "assert text_match_one(\"ac\")==('Not matched!')",
      "assert text_match_one(\"dc\")==('Not matched!')",
      "assert text_match_one(\"abba\")==('Found a match!')"
    ]
  },
  {
    "mbpp_id": 435,
    "problem_statement": "Write a python function to find the last digit of a given number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def last_Digit(n):\n    # Return the last digit of n using modulo operator\n    return n % 10",
    "test_cases": [
      "assert last_Digit(123) == 3",
      "assert last_Digit(25) == 5",
      "assert last_Digit(30) == 0"
    ]
  },
  {
    "mbpp_id": 436,
    "problem_statement": "Write a python function to print negative numbers in a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def neg_nos(lst):\n    # Use list comprehension to filter and create a new list with negative numbers from the input list\n    return [num for num in lst if num < 0]\n\n# Test cases to verify the correctness of the function\nprint(neg_nos([-1,4,5,-6]))  # Expected output: [-1, -6]\nprint(neg_nos([-1,-2,3,4]))  # Expected output: [-1, -2]\nprint(neg_nos([-7,-6,8,9]))  # Expected output: [-7, -6]",
    "test_cases": [
      "assert neg_nos([-1,4,5,-6]) == -1,-6",
      "assert neg_nos([-1,-2,3,4]) == -1,-2",
      "assert neg_nos([-7,-6,8,9]) == -7,-6"
    ]
  },
  {
    "mbpp_id": 437,
    "problem_statement": "Write a function to remove odd characters in a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_odd(s):\n    # Convert the string into a list for easier manipulation\n    s = list(s)\n    \n    i = 0\n    j = len(s) - 1\n    \n    while i < j:\n        if s[i] != s[j]:\n            # Swap elements at indices i and j\n            s[i], s[j] = s[j], s[i]\n        \n        # Move towards the middle of the string\n        i += 1\n        j -= 1\n    \n    return ''.join(s)\n\n# Test cases\nprint(remove_odd(\"python\"))  # Expected output: \"yhn\"\nprint(remove_odd(\"program\"))  # Expected output: \"rga\"\nprint(remove_odd(\"language\"))  # Expected output: \"agae\"",
    "test_cases": [
      "assert remove_odd(\"python\")==(\"yhn\")",
      "assert remove_odd(\"program\")==(\"rga\")",
      "assert remove_odd(\"language\")==(\"agae\")"
    ]
  },
  {
    "mbpp_id": 438,
    "problem_statement": "Write a function to count bidirectional tuple pairs.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_bidirectional(pairs):\n    pair_count = {}\n    \n    # Count each unique pair\n    for pair in pairs:\n        if pair[0] < pair[1]:\n            pair_key = str(pair)\n        else:\n            pair_key = str(pair[::-1])\n        \n        if pair_key not in pair_count:\n            pair_count[pair_key] = 0\n        \n        pair_count[pair_key] += 1\n    \n    # Calculate number of bidirectional pairs\n    num_bidirectional_pairs = sum(count // 2 for key, count in pair_count.items())\n    \n    return num_bidirectional_pairs",
    "test_cases": [
      "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '3'",
      "assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == '2'",
      "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == '4'"
    ]
  },
  {
    "mbpp_id": 439,
    "problem_statement": "Write a function to convert a list of multiple integers into a single integer.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def multiple_to_single(nums):\n    # Convert each element in nums from tuple to string, then join them with an empty string and finally cast it back to int\n    return int(''.join(str(i) for i in nums))",
    "test_cases": [
      "assert multiple_to_single([11, 33, 50])==113350",
      "assert multiple_to_single([-1,2,3,4,5,6])==-123456",
      "assert multiple_to_single([10,15,20,25])==10152025"
    ]
  },
  {
    "mbpp_id": 440,
    "problem_statement": "Write a function to find all adverbs and their positions in a given sentence.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef find_adverb_position(sentence):\n    # Use regular expression to match adverbs followed by a period\n    pattern = r'\\b([A-Z][^\\.]+)\\.\\s*'\n    matches = re.finditer(pattern, sentence)\n    \n    # Collect positions of found adverbs\n    positions = [(match.start(1), match.end(1)) for match in matches]\n    \n    return positions[0] if positions else None\n\n# Test cases\nprint(find_adverb_position(\"clearly!! we can see the sky\"))  # Expected output: (0, 7, 'clearly')\nprint(find_adverb_position(\"seriously!! there are many roses\"))  # Expected output: (0, 9, 'seriously')\nprint(find_adverb_position(\"unfortunately!! sita is going to home\"))  # Expected output: (0, 13, 'unfortunately')",
    "test_cases": [
      "assert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')",
      "assert find_adverb_position(\"seriously!! there are many roses\")==(0, 9, 'seriously')",
      "assert find_adverb_position(\"unfortunately!! sita is going to home\")==(0, 13, 'unfortunately')"
    ]
  },
  {
    "mbpp_id": 441,
    "problem_statement": "Write a function to find the surface area of a cube.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def surfacearea_cube(side_length):\n    \"\"\"\n    Calculate the surface area of a cube given its side length.\n    \n    Args:\n    side_length (float): The length of each side of the cube.\n    \n    Returns:\n    float: The total surface area of the cube.\n    \"\"\"\n    return 6 * (side_length ** 2)",
    "test_cases": [
      "assert surfacearea_cube(5)==150",
      "assert surfacearea_cube(3)==54",
      "assert surfacearea_cube(10)==600"
    ]
  },
  {
    "mbpp_id": 442,
    "problem_statement": "Write a function to find the ration of positive numbers in an array of integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - '>' not supported between instances of 'list' and 'int'",
      "Test 2: FAIL - '>' not supported between instances of 'list' and 'int'",
      "Test 3: FAIL - '>' not supported between instances of 'list' and 'int'"
    ],
    "generated_code": "import numpy as np\n\ndef positive_count(arr):\n    # Counting positive numbers and total elements\n    count = np.sum(arr > 0)\n    total_elements = len(arr)\n    \n    # Calculating ratio of positive numbers\n    if total_elements == 0:\n        return 0\n    else:\n        return float(count) / total_elements",
    "test_cases": [
      "assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54",
      "assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69",
      "assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56"
    ]
  },
  {
    "mbpp_id": 443,
    "problem_statement": "Write a python function to find the largest negative number from the given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def largest_neg(nums):\n    # Find the maximum value in the list\n    max_value = max(nums)\n    \n    # Check if the maximum value is less than zero\n    if max_value < 0:\n        return max_value\n    else:\n        return None\n\n# Test cases\nprint(largest_neg([1,2,3,-4,-6]))  # Expected output: -6\nprint(largest_neg([1,2,3,-8,-9]))  # Expected output: -9\nprint(largest_neg([1,2,3,4,-1]))   # Expected output: -1",
    "test_cases": [
      "assert largest_neg([1,2,3,-4,-6]) == -6",
      "assert largest_neg([1,2,3,-8,-9]) == -9",
      "assert largest_neg([1,2,3,4,-1]) == -1"
    ]
  },
  {
    "mbpp_id": 444,
    "problem_statement": "Write a function to trim each tuple by k in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def trim_tuple(tuple_list, k):\n    # Trimming tuples based on the value of k and converting them back into tuples for uniformity.\n    trimmed_tuples = [tuple([x if x != k else None for x in t]) for t in tuple_list]\n    # Filtering out any None values from the list.\n    trimmed_tuples = [tup for tup in trimmed_tuples if len(tup) > 0]\n    # Converting each tuple to string representation.\n    result = ['(' + ', '.join(str(x) for x in tup) + ')' for tup in trimmed_tuples]\n    return '[' + ', '.join(result) + ']'\n\n# Test cases\nprint(trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2))\nprint(trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1))\nprint(trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4), (4, 1, 7, 8), (3, 6, 9, 7)], 1))",
    "test_cases": [
      "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'",
      "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'",
      "assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'"
    ]
  },
  {
    "mbpp_id": 445,
    "problem_statement": "Write a function to perform index wise multiplication of tuple elements in the given two tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: can't multiply sequence by non-int of type 'tuple'"
    ],
    "generated_code": "def index_multiplication(tuple1, tuple2):\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the indices and corresponding values from both tuples\n    for i in range(len(tuple1)):\n        # Multiply the ith element of each tuple and append the result as a tuple to the result list\n        result.append((tuple1[i] * tuple2[i],))\n    \n    return tuple(result)\n\n# Test cases to verify the correctness of the function\nprint(index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)))) # ((6, 21), (12, 45), (2, 9), (7, 30))\nprint(index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)))) # ((14, 32), (20, 60), (6, 20), (16, 44))\nprint(index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)))) # ((24, 45), (30, 77), (12, 33), (27, 60))",
    "test_cases": [
      "assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))",
      "assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))",
      "assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))"
    ]
  },
  {
    "mbpp_id": 446,
    "problem_statement": "Write a python function to count the occurence of all elements of list in a tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_Occurrence(lst, tpl):\n    from collections import Counter\n    \n    # Convert tuple to list for counting occurrences\n    lst = list(lst)\n    \n    # Count occurrences of each element in list\n    counts = Counter(lst)\n    \n    total_occurrences = sum(counts[t] for t in tpl if t in counts)\n    \n    return total_occurrences",
    "test_cases": [
      "assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3",
      "assert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6",
      "assert count_Occurrence((1,2,3,4,5,6),[1,2]) == 2"
    ]
  },
  {
    "mbpp_id": 447,
    "problem_statement": "Write a function to find cubes of individual elements in a list using lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "cube_nums = lambda lst: [lambda x: x ** 3 for x in lst]\n\n# Test Cases\nprint(cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))  # Expected output: [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\nprint(cube_nums([10,20,30]))  # Expected output: [1000, 8000, 27000]\nprint(cube_nums([12,15]))  # Expected output: [1728, 3375]",
    "test_cases": [
      "assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]",
      "assert cube_nums([10,20,30])==([1000, 8000, 27000])",
      "assert cube_nums([12,15])==([1728, 3375])"
    ]
  },
  {
    "mbpp_id": 448,
    "problem_statement": "Write a function to calculate the sum of perrin numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def cal_sum(n):\n    if n <= 2:\n        return n\n    else:\n        # Initialize the first two Pern numbers\n        prev1 = 3\n        prev2 = 0\n        current = 2\n        \n        for _ in range(3, n + 1):\n            next_num = prev1 + prev2\n            prev2 = prev1\n            prev1 = next_num\n            current += next_num\n            \n        return current\n\n# Test cases\nprint(cal_sum(9))  # Expected output: 49\nprint(cal_sum(10))  # Expected output: 66\nprint(cal_sum(11))  # Expected output: 88",
    "test_cases": [
      "assert cal_sum(9) == 49",
      "assert cal_sum(10) == 66",
      "assert cal_sum(11) == 88"
    ]
  },
  {
    "mbpp_id": 449,
    "problem_statement": "Write a python function to check whether the triangle is valid or not if 3 points are given.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate distances between all three sides of the triangle using the distance formula\n    side1 = ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n    side2 = ((x2 - x3)**2 + (y2 - y3)**2)**0.5\n    side3 = ((x3 - x1)**2 + (y3 - y1)**2)**0.5\n    \n    # Check if the sum of any two sides is greater than the third side and all sides are positive\n    if side1 + side2 > side3 and side2 + side3 > side1 and side3 + side1 > side2:\n        return 'Yes'\n    else:\n        return 'No'\n\n# Test cases\nprint(check_Triangle(1,5,2,5,4,6))  # Expected output: Yes\nprint(check_Triangle(1,1,1,4,1,5))  # Expected output: No\nprint(check_Triangle(1,1,1,1,1,1))  # Expected output: No",
    "test_cases": [
      "assert check_Triangle(1,5,2,5,4,6) == 'Yes'",
      "assert check_Triangle(1,1,1,4,1,5) == 'No'",
      "assert check_Triangle(1,1,1,1,1,1) == 'No'"
    ]
  },
  {
    "mbpp_id": 450,
    "problem_statement": "Write a function to extract specified size of strings from a give list of string values.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def extract_string(lst, n):\n    return [s[:n] for s in lst]",
    "test_cases": [
      "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']",
      "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,6)==['Python']",
      "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,9)==['exercises']"
    ]
  },
  {
    "mbpp_id": 451,
    "problem_statement": "Write a function to remove all whitespaces from the given string using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef remove_whitespaces(s):\n    # Remove leading and trailing whitespaces using regex\n    s = re.sub(r'^\\s+|\\s+$', '', s)\n    return s",
    "test_cases": [
      "assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'",
      "assert remove_whitespaces(' Google    Dart ') == 'GoogleDart'",
      "assert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'"
    ]
  },
  {
    "mbpp_id": 452,
    "problem_statement": "Write a function that gives loss amount if the given amount has loss else return none.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def loss_amount(amount_gained, total_loss):\n    # Calculate loss based on the formula provided in the task description\n    loss = total_loss - amount_gained\n    \n    # Check if there is a loss and return it\n    return loss if loss > 0 else None\n\n# Test cases to verify the correctness of the solution\nassert loss_amount(1500, 1200) == None\nassert loss_amount(100, 200) == 100\nassert loss_amount(2000, 5000) == 3000",
    "test_cases": [
      "assert loss_amount(1500,1200)==None",
      "assert loss_amount(100,200)==100",
      "assert loss_amount(2000,5000)==3000"
    ]
  },
  {
    "mbpp_id": 453,
    "problem_statement": "Write a python function to find the sum of even factors of a number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef sumofFactors(n):\n    def sum_factors(x):\n        result = x // 2 * (x + 1)\n        for i in range(int(math.sqrt(x)), 1, -1):\n            if x % i == 0:\n                if i == x / i:\n                    result += i\n                else:\n                    result += i + x // i\n        return result\n    \n    # Sum up all even factors using the helper function\n    total_sum = sum(sum_factors(i) for i in range(2, n+1, 2))\n    return total_sum",
    "test_cases": [
      "assert sumofFactors(18) == 26",
      "assert sumofFactors(30) == 48",
      "assert sumofFactors(6) == 8"
    ]
  },
  {
    "mbpp_id": 454,
    "problem_statement": "Write a function that matches a word containing 'z'.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef text_match_wordz(text):\n    # Use regex to find if the input string contains 'z'\n    pattern = r'\\b\\w*z\\b' \n    result = re.search(pattern, text)\n    \n    if result:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "test_cases": [
      "assert text_match_wordz(\"pythonz.\")==('Found a match!')",
      "assert text_match_wordz(\"xyz.\")==('Found a match!')",
      "assert text_match_wordz(\"  lang  .\")==('Not matched!')"
    ]
  },
  {
    "mbpp_id": 455,
    "problem_statement": "Write a function to check whether the given month number contains 31 days or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_monthnumb_number(month_number):\n    # Check if the month is February and it's either a leap year or non-leap year.\n    if month_number == 2:\n        return True  # Feb has 29 days in a leap year, and 28 days otherwise.\n    \n    # All other months have 31 days.\n    return False",
    "test_cases": [
      "assert check_monthnumb_number(5)==True",
      "assert check_monthnumb_number(2)==False",
      "assert check_monthnumb_number(6)==False"
    ]
  },
  {
    "mbpp_id": 456,
    "problem_statement": "Write a function to reverse strings in a given list of string values.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]",
    "test_cases": [
      "assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']",
      "assert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']",
      "assert reverse_string_list(['jack','john','mary'])==['kcaj','nhoj','yram']"
    ]
  },
  {
    "mbpp_id": 457,
    "problem_statement": "Write a python function to find the sublist having minimum length.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Find_Min' is not defined",
      "Test 2: FAIL - name 'Find_Min' is not defined",
      "Test 3: FAIL - name 'Find_Min' is not defined"
    ],
    "generated_code": "def find_min(lst):\n    # Initialize the minimum list with the first element of the input list\n    min_list = lst[0] if isinstance(lst[0], list) else [lst[0]]\n    \n    # Iterate through each element in the input list\n    for sub_lst in lst:\n        # If the current sublist is shorter than the minimum list, update it\n        if len(sub_lst) < len(min_list):\n            min_list = sub_lst\n    \n    return min_list",
    "test_cases": [
      "assert Find_Min([[1],[1,2],[1,2,3]]) == [1]",
      "assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]",
      "assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']"
    ]
  },
  {
    "mbpp_id": 458,
    "problem_statement": "Write a function to find the area of a rectangle.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def rectangle_area(length, width):\n    return length * width",
    "test_cases": [
      "assert rectangle_area(10,20)==200",
      "assert rectangle_area(10,5)==50",
      "assert rectangle_area(4,2)==8"
    ]
  },
  {
    "mbpp_id": 459,
    "problem_statement": "Write a function to remove uppercase substrings from a given string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef remove_uppercase(s):\n    # Remove all uppercase letters in the string\n    return re.sub('[A-Z]', '', s)",
    "test_cases": [
      "assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'",
      "assert remove_uppercase('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'",
      "assert remove_uppercase('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'"
    ]
  },
  {
    "mbpp_id": 460,
    "problem_statement": "Write a python function to get the first element of each sublist.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Extract' is not defined",
      "Test 2: FAIL - name 'Extract' is not defined",
      "Test 3: FAIL - name 'Extract' is not defined"
    ],
    "generated_code": "def extract(lst):\n    \"\"\"\n    This function takes a list of lists and returns a new list containing the first element from each sublist.\n    \n    :param lst: List of lists\n    :return: A list with the first element from each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst]\n\n# Test Cases\nprint(extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]))  # Output: [1, 3, 6]\nprint(extract([[1,2,3],[4, 5]]))  # Output: [1, 4]\nprint(extract([[9,8,1],[1,2]]))  # Output: [9, 1]",
    "test_cases": [
      "assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]",
      "assert Extract([[1,2,3],[4, 5]]) == [1,4]",
      "assert Extract([[9,8,1],[1,2]]) == [9,1]"
    ]
  },
  {
    "mbpp_id": 461,
    "problem_statement": "Write a python function to count the upper case characters in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def upper_ctr(s):\n    # Initialize counter for uppercase letters\n    upper_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        if char >= 'A' and char <= 'Z':\n            upper_count += 1\n            \n    return upper_count",
    "test_cases": [
      "assert upper_ctr('PYthon') == 1",
      "assert upper_ctr('BigData') == 1",
      "assert upper_ctr('program') == 0"
    ]
  },
  {
    "mbpp_id": 462,
    "problem_statement": "Write a function to find all possible combinations of the elements of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from itertools import permutations\n\ndef combinations_list(lst):\n    result = []\n    for r in range(len(lst) + 1):\n        for item in set(permutations(lst, r)):\n            result.append(list(item))\n    return sorted(result)\n\n# Test cases\nprint(combinations_list(['orange', 'red', 'green', 'blue']))\nprint(combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange']))\nprint(combinations_list(['red', 'green', 'black', 'orange']))",
    "test_cases": [
      "assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]",
      "assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]",
      "assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]"
    ]
  },
  {
    "mbpp_id": 463,
    "problem_statement": "Write a function to find the maximum product subarray of the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    max_product = current_max = min_product = arr[0]\n    \n    for num in arr[1:]:\n        temp = current_max\n        current_max = max(num, current_max * num, min_product * num)\n        min_product = min(temp, current_max, min_product * num)\n        \n        max_product = max(max_product, current_max)\n    \n    return max_product",
    "test_cases": [
      "assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112",
      "assert max_subarray_product([6, -3, -10, 0, 2]) == 180 ",
      "assert max_subarray_product([-2, -40, 0, -2, -3]) == 80"
    ]
  },
  {
    "mbpp_id": 464,
    "problem_statement": "Write a function to check if all values are same in a dictionary.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_value(dictionary, value_to_compare):\n    # Check if all values in the dictionary are equal to the given value\n    return len(set(dictionary.values())) == 1 and list(dictionary.values())[0] != None",
    "test_cases": [
      "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False",
      "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True",
      "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False"
    ]
  },
  {
    "mbpp_id": 465,
    "problem_statement": "Write a function to drop empty items from a given dictionary.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def drop_empty(dct):\n    return {k: v for k, v in dct.items() if v is not None}",
    "test_cases": [
      "assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}",
      "assert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}",
      "assert drop_empty({'c1': None, 'c2': 'Green', 'c3':None})=={ 'c2': 'Green'}"
    ]
  },
  {
    "mbpp_id": 466,
    "problem_statement": "Write a function to find the peak element in the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_peak(arr, n):\n    # Check if the first element is greater than the second element.\n    # If it is, then it's a possible peak. Otherwise, check the last element.\n    if arr[0] > arr[1]:\n        return arr[0]\n    elif arr[n-1] > arr[n-2]:\n        return arr[n-1]\n\n    left, right = 1, n - 2  # Initialize left and right pointers\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] > arr[mid - 1] and arr[mid] > arr[mid + 1]:  # It is the peak\n            return arr[mid]\n        elif arr[mid] < arr[mid + 1]:  # Move left pointer\n            left = mid + 1\n        else:  # Move right pointer\n            right = mid - 1\n    return -1  # This line will never be reached because of the conditions above",
    "test_cases": [
      "assert find_peak([1, 3, 20, 4, 1, 0], 6) == 2",
      "assert find_peak([2, 3, 4, 5, 6], 5) == 4",
      "assert find_peak([8, 9, 11, 12, 14, 15], 6) == 5 "
    ]
  },
  {
    "mbpp_id": 467,
    "problem_statement": "Write a python function to convert decimal number to octal number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def decimal_to_Octal(decimal_number):\n    \"\"\"\n    Convert a given decimal number to its octal equivalent.\n    \n    Args:\n    decimal_number (int): The decimal number to be converted.\n    \n    Returns:\n    str: The octal representation of the given decimal number.\n    \"\"\"\n    if decimal_number == 0:\n        return \"0\"\n    octal_number = \"\"\n    while decimal_number > 0:\n        remainder = decimal_number % 8\n        octal_number = str(remainder) + octal_number\n        decimal_number //= 8\n    return octal_number",
    "test_cases": [
      "assert decimal_to_Octal(10) == 12",
      "assert decimal_to_Octal(2) == 2",
      "assert decimal_to_Octal(33) == 41"
    ]
  },
  {
    "mbpp_id": 468,
    "problem_statement": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_product(nums, n):\n    dp = [nums[0]] * n\n    for i in range(1, n):\n        if nums[i] > dp[-1]:\n            dp[-1] = nums[i]\n        elif nums[i] <= dp[-1]:\n            dp.append(dp.pop() * nums[i])\n    return max(dp)",
    "test_cases": [
      "assert max_product([3, 100, 4, 5, 150, 6], 6) == 45000 ",
      "assert max_product([4, 42, 55, 68, 80], 5) == 50265600",
      "assert max_product([10, 22, 9, 33, 21, 50, 41, 60], 8) == 21780000 "
    ]
  },
  {
    "mbpp_id": 469,
    "problem_statement": "Write a function to find the maximum profit earned from a maximum of k stock transactions",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: index out of range"
    ],
    "generated_code": "from typing import List\nimport heapq\n\ndef max_profit(prices: List[int], k: int) -> int:\n    if not prices or len(prices) < 2:\n        return 0\n    \n    n = len(prices)\n    \n    # Max heap for buying stocks and Min heap for selling stocks\n    buy_heap = []\n    sell_heap = []\n    \n    result = [0] * n\n    \n    for i in range(n):\n        while buy_heap and prices[i] >= -buy_heap[0]:\n            heapq.heappop(buy_heap)\n        \n        if sell_heap and -sell_heap[0] <= prices[i]:\n            price = -heapq.heappop(sell_heap)\n            heapq.heappush(buy_heap, price)\n        \n        result[i] = max(result[i-1], prices[i] + -heapq.heappop(buy_heap))\n    \n    return result[-1]\n\n# Test cases\nprint(max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3))  # Output: 10\nprint(max_profit([2, 4, 7, 5, 4, 3, 5], 2))     # Output: 7\nprint(max_profit([10, 6, 8, 4, 2], 2))          # Output: 2",
    "test_cases": [
      "assert max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3) == 10",
      "assert max_profit([2, 4, 7, 5, 4, 3, 5], 2) == 7",
      "assert max_profit([10, 6, 8, 4, 2], 2) == 2"
    ]
  },
  {
    "mbpp_id": 470,
    "problem_statement": "Write a function to find the pairwise addition of the elements of the given tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: 'int' object is not iterable"
    ],
    "generated_code": "def add_pairwise(tuples):\n    # Convert each tuple into a list for easier iteration\n    list_tuples = [list(tup) for tup in tuples]\n    \n    # Pairwise addition operation on all elements\n    result = [(a + b) for tup in list_tuples for a, b in zip(*tup)]\n    \n    return tuple(result)\n\n# Test cases\nprint(add_pairwise([(1, 5, 7, 8, 10)]))\nprint(add_pairwise([(2, 6, 8, 9, 11)]))\nprint(add_pairwise([(3, 7, 9, 10, 12)]))",
    "test_cases": [
      "assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)",
      "assert add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)",
      "assert add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)"
    ]
  },
  {
    "mbpp_id": 471,
    "problem_statement": "Write a python function to find remainder of array multiplication divided by n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_remainder(arr, n, m):\n    # Initialize result as 1\n    res = 1\n    \n    # Calculate product of all elements in arr\n    for i in range(len(arr)):\n        res *= arr[i]\n    \n    # Find remainder when calculated product is divided by n and m\n    rem = res % n\n    \n    # Check if remainder equals to m\n    if rem != m:\n        return \"No\"\n    else:\n        return \"Yes\"\n\n# Test cases\nprint(find_remainder([ 100, 10, 5, 25, 35, 14 ],6,11))  # Output: Yes\nprint(find_remainder([1,1,1],3,1))  # Output: No\nprint(find_remainder([1,2,1],3,2))  # Output: No",
    "test_cases": [
      "assert find_remainder([ 100, 10, 5, 25, 35, 14 ],6,11) ==9",
      "assert find_remainder([1,1,1],3,1) == 0",
      "assert find_remainder([1,2,1],3,2) == 0"
    ]
  },
  {
    "mbpp_id": 472,
    "problem_statement": "Write a python function to check whether the given list contains consecutive numbers or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_Consecutive(lst):\n    # Check if all elements in the list are consecutive\n    return lst == sorted(set(lst))\n\n# Test cases\nprint(check_Consecutive([1,2,3,4,5]))  # Expected output: True\nprint(check_Consecutive([1,2,3,5,6]))  # Expected output: False\nprint(check_Consecutive([1,2,1]))      # Expected output: False",
    "test_cases": [
      "assert check_Consecutive([1,2,3,4,5]) == True",
      "assert check_Consecutive([1,2,3,5,6]) == False",
      "assert check_Consecutive([1,2,1]) == False"
    ]
  },
  {
    "mbpp_id": 473,
    "problem_statement": "Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def tuple_intersection(tuples_list_1, tuples_list_2):\n    # Convert each tuple list into a set for O(1) average-time complexity lookups\n    sets = [set(tup) for tup in tuples_list_1 + tuples_list_2]\n    \n    # Find common elements between all sets using intersection\n    intersection_elements = set.intersection(*sets)\n    \n    # Convert the intersection back into a sorted tuple and format it as per task requirements\n    result = tuple(sorted(intersection_elements))\n    \n    return result",
    "test_cases": [
      "assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}",
      "assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}",
      "assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}"
    ]
  },
  {
    "mbpp_id": 474,
    "problem_statement": "Write a function to replace characters in a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)",
    "test_cases": [
      "assert replace_char(\"polygon\",'y','l')==(\"pollgon\")",
      "assert replace_char(\"character\",'c','a')==(\"aharaater\")",
      "assert replace_char(\"python\",'l','a')==(\"python\")"
    ]
  },
  {
    "mbpp_id": 475,
    "problem_statement": "Write a function to sort counter by value.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import Counter\n\ndef sort_counter(counter):\n    return sorted(counter.items(), key=lambda x: x[1], reverse=True)",
    "test_cases": [
      "assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]",
      "assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]",
      "assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]"
    ]
  },
  {
    "mbpp_id": 476,
    "problem_statement": "Write a python function to find the sum of the largest and smallest value in a given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Return the sum of the maximum and minimum values\n    return max_value + min_value",
    "test_cases": [
      "assert big_sum([1,2,3]) == 4",
      "assert big_sum([-1,2,3,4]) == 3",
      "assert big_sum([2,3,6]) == 8"
    ]
  },
  {
    "mbpp_id": 477,
    "problem_statement": "Write a python function to convert the given string to lower case.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_lower(s):\n    # Convert each character in the string to lowercase and join them back into a new string\n    return s.lower()\n\n# Test cases\nprint(is_lower(\"InValid\"))  # Expected output: invalid\nprint(is_lower(\"TruE\"))     # Expected output: true\nprint(is_lower(\"SenTenCE\")) # Expected output: sentence",
    "test_cases": [
      "assert is_lower(\"InValid\") == \"invalid\"",
      "assert is_lower(\"TruE\") == \"true\"",
      "assert is_lower(\"SenTenCE\") == \"sentence\""
    ]
  },
  {
    "mbpp_id": 478,
    "problem_statement": "Write a function to remove lowercase substrings from a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_lowercase(s):\n    # Convert the input string to lowercase and then filter out non-lowercase characters\n    return ''.join([char for char in s.lower() if not char.islower()])",
    "test_cases": [
      "assert remove_lowercase(\"PYTHon\")==('PYTH')",
      "assert remove_lowercase(\"FInD\")==('FID')",
      "assert remove_lowercase(\"STRinG\")==('STRG')"
    ]
  },
  {
    "mbpp_id": 479,
    "problem_statement": "Write a python function to find the first digit of a given number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def first_Digit(number):\n    # Remove all non-digit characters from the number and convert it to a string\n    str_number = ''.join(filter(str.isdigit, str(number)))\n    # If the resulting string is empty, the original number had no digits\n    if not str_number:\n        raise ValueError(\"The input number has no digits.\")\n    \n    # Return the first character in the cleaned string which represents the first digit\n    return int(str_number[0])",
    "test_cases": [
      "assert first_Digit(123) == 1",
      "assert first_Digit(456) == 4",
      "assert first_Digit(12) == 1"
    ]
  },
  {
    "mbpp_id": 480,
    "problem_statement": "Write a python function to find the maximum occurring character in a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_max_occuring_char(input_string):\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count the occurrence of each character in the input string\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find and return the character with the highest occurrence\n    max_char = \"\"\n    max_count = 0\n    for char, count in char_count.items():\n        if count > max_count:\n            max_count = count\n            max_char = char\n            \n    return max_char",
    "test_cases": [
      "assert get_max_occuring_char(\"data\") == \"a\"",
      "assert get_max_occuring_char(\"create\") == \"e\"",
      "assert get_max_occuring_char(\"brilliant girl\") == \"i\""
    ]
  },
  {
    "mbpp_id": 481,
    "problem_statement": "Write a function to determine if there is a subset of the given set with sum equal to the given sum.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_subset_sum(arr, n, target_sum):\n    dp = [[False for _ in range(target_sum + 1)] for _ in range(n + 1)]\n    \n    # Base case initialization\n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    # Filling the table in bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n                \n    return dp[n][target_sum]\n\n# Test cases\nprint(is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9))   # Expected output: True\nprint(is_subset_sum([3, 34, 4, 12, 5, 2], 6, 30))  # Expected output: False\nprint(is_subset_sum([3, 34, 4, 12, 5, 2], 6, 15))  # Expected output: True",
    "test_cases": [
      "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9) == True",
      "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 30) == False",
      "assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 15) == True"
    ]
  },
  {
    "mbpp_id": 482,
    "problem_statement": "Write a function to find sequences of one upper case letter followed by lower case letters in the given string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef match(text):\n    pattern = r\"[A-Z][a-z]*\"\n    result = re.search(pattern, text)\n    if result:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Test cases\nprint(match(\"Geeks\"))  # Expected output: Yes\nprint(match(\"geeksforGeeks\"))  # Expected output: Yes\nprint(match(\"geeks\"))  # Expected output: No",
    "test_cases": [
      "assert match(\"Geeks\") == 'Yes'",
      "assert match(\"geeksforGeeks\") == 'Yes'",
      "assert match(\"geeks\") == 'No'"
    ]
  },
  {
    "mbpp_id": 483,
    "problem_statement": "Write a python function to find the first natural number whose factorial is divisible by x.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'reduce' is not defined",
      "Test 2: FAIL - name 'reduce' is not defined",
      "Test 3: FAIL - name 'reduce' is not defined"
    ],
    "generated_code": "def first_Factorial_Divisible_Number(x):\n    n = 1\n    while True:\n        if reduce(lambda x,y: x*y, range(1,n+1)) % x == 0:\n            return n\n        n += 1",
    "test_cases": [
      "assert first_Factorial_Divisible_Number(10) == 5",
      "assert first_Factorial_Divisible_Number(15) == 5",
      "assert first_Factorial_Divisible_Number(5) == 4"
    ]
  },
  {
    "mbpp_id": 484,
    "problem_statement": "Write a function to remove the matching tuples from the given two tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - SyntaxError: unmatched ')'"
    ],
    "generated_code": "def remove_matching_tuple(tup1, tup2):\n    # Create sets of elements in each tuple for efficient comparison\n    set1 = set(map(str.lower, tup1[0]))\n    set2 = set(map(str.lower, tup1[1]))\n\n    result = []\n    for i in range(len(tup2)):\n        if not ((set1 & set2) or (tup2[i] in set1 and tup2[i+1] in set2)):\n            result.append(tuple(tup2[:i + 2]))  # Append up to the current element\n\n    return result\n\n# Test cases\nprint(remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]))  # Should return [('you', '?')]\nprint(remove_matching_tuple([('Part', 'of'), ('the', 'journey'), ('is '), 'end']), [('Journey', 'the'), ('is', 'end')]))  # Should return [('Part', 'of'), ('the', 'journey'), ('is ', 'end')]\nprint(remove_matching_tuple([('Its', 'been'), ('a', 'long'), ('day', 'without')], [('a', 'long'), ('my', 'friend')]))  # Should return [('Its', 'been'), ('day', 'without')])",
    "test_cases": [
      "assert remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]) == [('you', '?')]",
      "assert remove_matching_tuple([('Part', 'of'), ('the', 'journey'), ('is ', 'end')], [('Journey', 'the'), ('is', 'end')]) == [('Part', 'of'), ('the', 'journey'), ('is ', 'end')]",
      "assert remove_matching_tuple([('Its', 'been'), ('a', 'long'), ('day', 'without')], [('a', 'long'), ('my', 'friend')]) == [('Its', 'been'), ('day', 'without')]"
    ]
  },
  {
    "mbpp_id": 485,
    "problem_statement": "Write a function to find the largest palindromic number in the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def largest_palindrome(arr, n):\n    arr.sort(reverse=True)\n    for i in range(n - 1):\n        if arr[i] == arr[n - i - 2]:\n            return arr[n - i - 2]",
    "test_cases": [
      "assert largest_palindrome([1, 232, 54545, 999991], 4) == 54545",
      "assert largest_palindrome([1, 2, 3, 4, 5, 50], 6) == 5",
      "assert largest_palindrome([1, 3, 7, 9, 45], 5)  == 9"
    ]
  },
  {
    "mbpp_id": 486,
    "problem_statement": "Write a function to compute binomial probability for the given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef binomial_probability(n, k, p):\n    if n < k:\n        return 0\n    binom_coeff = math.comb(n, k)\n    prob = binom_coeff * (p**k) * ((1-p)**(n-k))\n    return round(prob, 12)\n\n# Test cases\nprint(binomial_probability(10, 5, 1.0 / 3))  # Expected output: 0.13656454808718185\nprint(binomial_probability(11, 6, 2.0 / 4))  # Expected output: 0.2255859375\nprint(binomial_probability(12, 7, 3.0 / 5))  # Expected output: 0.227030335488",
    "test_cases": [
      "assert binomial_probability(10, 5, 1.0/3) == 0.13656454808718185",
      "assert binomial_probability(11, 6, 2.0/4) == 0.2255859375",
      "assert binomial_probability(12, 7, 3.0/5) == 0.227030335488"
    ]
  },
  {
    "mbpp_id": 487,
    "problem_statement": "Write a function to sort a list of tuples in increasing order by the last element in each tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sort_tuple(tuples_list):\n    # Sort the list using key argument with itemgetter which extracts the last element from each tuple\n    return sorted(tuples_list, key=lambda x: x[-1])",
    "test_cases": [
      "assert sort_tuple([(1, 3), (3, 2), (2, 1)] ) == [(2, 1), (3, 2), (1, 3)]",
      "assert sort_tuple([(2, 4), (3, 3), (1, 1)] ) == [(1, 1), (3, 3), (2, 4)]",
      "assert sort_tuple([(3, 9), (6, 7), (4, 3)] ) == [(4, 3), (6, 7), (3, 9)]"
    ]
  },
  {
    "mbpp_id": 488,
    "problem_statement": "Write a function to find the area of a pentagon.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef area_pentagon(side_length):\n    \"\"\"\n    Calculate the area of a regular pentagon given its side length.\n    \n    Args:\n    side_length (float): The length of each side of the pentagon.\n    \n    Returns:\n    float: The area of the pentagon rounded to 8 decimal places.\n    \"\"\"\n    # Formula for the area of a regular pentagon: (sqrt(5*(5+2*sqrt(5))) / 4) * side_length^2\n    return round((math.sqrt(5 * (5 + 2 * math.sqrt(5))) / 4) * pow(side_length, 2), 8)",
    "test_cases": [
      "assert area_pentagon(5)==43.01193501472417",
      "assert area_pentagon(10)==172.0477400588967",
      "assert area_pentagon(15)==387.10741513251753"
    ]
  },
  {
    "mbpp_id": 489,
    "problem_statement": "Write a python function to find the frequency of the largest value in a given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - frequency_Of_Largest() takes 1 positional argument but 2 were given",
      "Test 2: FAIL - frequency_Of_Largest() takes 1 positional argument but 2 were given",
      "Test 3: FAIL - frequency_Of_Largest() takes 1 positional argument but 2 were given"
    ],
    "generated_code": "def frequency_Of_Largest(arr):\n    max_value = max(arr)\n    count = arr.count(max_value)\n    return count",
    "test_cases": [
      "assert frequency_Of_Largest(5,[1,2,3,4,4]) == 2",
      "assert frequency_Of_Largest(3,[5,6,5]) == 1",
      "assert frequency_Of_Largest(4,[2,7,7,7]) == 3"
    ]
  },
  {
    "mbpp_id": 490,
    "problem_statement": "Write a function to extract all the pairs which are symmetric in the given tuple list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def extract_symmetric(tuples_list):\n    result = set()\n    for i in range(len(tuples_list)):\n        for j in range(i + 1, len(tuples_list)):\n            if tuples_list[i] == tuples_list[j][::-1]:\n                result.add(tuple(sorted(tuples_list[i])))\n    return result",
    "test_cases": [
      "assert extract_symmetric([(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)] ) == {(8, 9), (6, 7)}",
      "assert extract_symmetric([(7, 8), (3, 4), (8, 7), (10, 9), (11, 3), (9, 10)] ) == {(9, 10), (7, 8)}",
      "assert extract_symmetric([(8, 9), (4, 5), (9, 8), (11, 10), (12, 4), (10, 11)] ) == {(8, 9), (10, 11)}"
    ]
  },
  {
    "mbpp_id": 491,
    "problem_statement": "Write a function to find the sum of geometric progression series.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sum_gp(a, r, n):\n    return a * ((1 - pow(r, n)) / (1 - r))",
    "test_cases": [
      "assert sum_gp(1,5,2)==31",
      "assert sum_gp(1,5,4)==341",
      "assert sum_gp(2,6,3)==728"
    ]
  },
  {
    "mbpp_id": 492,
    "problem_statement": "Write a function to search an element in the given array by using binary search.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def binary_search(arr, target):\n    \"\"\"\n    Searches for a target value in a sorted list and returns True if found, otherwise False.\n    \n    Parameters:\n    arr (list): A list of integers which is already sorted in ascending order.\n    target (int): The integer you're searching for within the array.\n    \n    Returns:\n    bool: True if the target is found, False otherwise.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # If the middle element is equal to the target, return True\n        if arr[mid] == target:\n            return True\n        # If the middle element is greater than the target, move the end pointer\n        elif arr[mid] > target:\n            right = mid - 1\n        # If the middle element is less than the target, move the start pointer\n        else:\n            left = mid + 1\n            \n    # If the loop completes without finding the target, return False\n    return False\n\n# Test cases\nprint(binary_search([1,2,3,5,8], 6))  # Expected output: False\nprint(binary_search([7, 8, 9, 10, 13], 10))  # Expected output: True\nprint(binary_search([11, 13, 14, 19, 22, 36], 23))  # Expected output: False",
    "test_cases": [
      "assert binary_search([1,2,3,5,8], 6) == False",
      "assert binary_search([7, 8, 9, 10, 13], 10) == True",
      "assert binary_search([11, 13, 14, 19, 22, 36], 23) == False"
    ]
  },
  {
    "mbpp_id": 493,
    "problem_statement": "Write a function to calculate a grid of hexagon coordinates where function returns a list of lists containing 6 tuples of x, y point coordinates.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - SyntaxError: invalid syntax"
    ],
    "generated_code": "```python\nimport math\n\ndef calculate_polygons(x1, y1, x2, y2, steps):\n    # Calculate step size for horizontal and vertical distances\n    h_step = abs(y2 - y1) / steps\n    v_step = abs(x2 - x1) / steps\n    \n    # Generate points along each dimension\n    xs = []\n    ys = []\n    \n    for i in range(steps + 1):\n        y_start = y1 + i * h_step\n        for j in range(steps + 1):\n            x_start = x1 + j * v_step\n            \n            if i > 0:\n                y_next = y_start + h_step\n                for k in range(i - 1):\n                    x_end = x_start + h_step\n                    x_list = [x_start, x_end]\n                    y_list = [y_start, y_next]\n                    xy_points = []\n                    \n                    # Find intersections between adjacent lines\n                    line_a = (x_list[k], y_list[k])\n                    line_b = (x_list[k+1], y_list[k+1])\n                    \n                    # Find intersection points\n                    dx_a, dy_a = line_a[1] - line_a[0], line_a[0] - line_a[1]\n                    dx_b, dy_b = line_b[1] - line_b[0], line_b[0] - line_b[1]\n                    \n                    det_ab = dx_a * dy_b - dy_a * dx_b\n                    \n                    if det_ab != 0:\n                        px = ((dy_a * y_list[k] - dy_b * y_list[k]) / det_ab)\n                        py = ((dx_a * x_list[k] - dx_b * x_list[k]) / det_ab)\n                        \n                        while True:\n                            x = round(px, 5)\n                            y = round(py, 5)\n                            \n                            if x == x_list[k] and y == y_list[k]:\n                                break\n                                \n                            xy_points.append((x, y))\n                            \n                            px += h_step\n                            py -= v_step\n                            \n                        xy_points.append(line_a)\n                        xy_points.append(line_b)\n                    else:\n                        xy_points.extend([(x_list[k], y)])\n                    \n                    xs.append(xy_points)\n                    ys.append([])\n                \n            ys[-1].append([x_start, y_start])\n\n    polygons = [[tuple(point) for point in polygon] for polygon in zip(*xs)]\n    result = [[[polygon[i:i+6] for",
    "test_cases": [
      "assert calculate_polygons(1,1, 4, 4, 3)==[[(-5.0, -4.196152422706632), (-5.0, -0.7320508075688767), (-2.0, 1.0), (1.0, -0.7320508075688767), (1.0, -4.196152422706632), (-2.0, -5.928203230275509), (-5.0, -4.196152422706632)], [(1.0, -4.196152422706632), (1.0, -0.7320508075688767), (4.0, 1.0), (7.0, -0.7320508075688767), (7.0, -4.196152422706632), (4.0, -5.928203230275509), (1.0, -4.196152422706632)], [(7.0, -4.196152422706632), (7.0, -0.7320508075688767), (10.0, 1.0), (13.0, -0.7320508075688767), (13.0, -4.196152422706632), (10.0, -5.928203230275509), (7.0, -4.196152422706632)], [(-2.0, 1.0000000000000004), (-2.0, 4.464101615137755), (1.0, 6.196152422706632), (4.0, 4.464101615137755), (4.0, 1.0000000000000004), (1.0, -0.7320508075688767), (-2.0, 1.0000000000000004)], [(4.0, 1.0000000000000004), (4.0, 4.464101615137755), (7.0, 6.196152422706632), (10.0, 4.464101615137755), (10.0, 1.0000000000000004), (7.0, -0.7320508075688767), (4.0, 1.0000000000000004)], [(-5.0, 6.196152422706632), (-5.0, 9.660254037844387), (-2.0, 11.392304845413264), (1.0, 9.660254037844387), (1.0, 6.196152422706632), (-2.0, 4.464101615137755), (-5.0, 6.196152422706632)], [(1.0, 6.196152422706632), (1.0, 9.660254037844387), (4.0, 11.392304845413264), (7.0, 9.660254037844387), (7.0, 6.196152422706632), (4.0, 4.464101615137755), (1.0, 6.196152422706632)], [(7.0, 6.196152422706632), (7.0, 9.660254037844387), (10.0, 11.392304845413264), (13.0, 9.660254037844387), (13.0, 6.196152422706632), (10.0, 4.464101615137755), (7.0, 6.196152422706632)], [(-2.0, 11.392304845413264), (-2.0, 14.85640646055102), (1.0, 16.588457268119896), (4.0, 14.85640646055102), (4.0, 11.392304845413264), (1.0, 9.660254037844387), (-2.0, 11.392304845413264)], [(4.0, 11.392304845413264), (4.0, 14.85640646055102), (7.0, 16.588457268119896), (10.0, 14.85640646055102), (10.0, 11.392304845413264), (7.0, 9.660254037844387), (4.0, 11.392304845413264)]]",
      "assert calculate_polygons(5,4,7,9,8)==[[(-11.0, -9.856406460551018), (-11.0, -0.6188021535170058), (-3.0, 4.0), (5.0, -0.6188021535170058), (5.0, -9.856406460551018), (-3.0, -14.475208614068023), (-11.0, -9.856406460551018)], [(5.0, -9.856406460551018), (5.0, -0.6188021535170058), (13.0, 4.0), (21.0, -0.6188021535170058), (21.0, -9.856406460551018), (13.0, -14.475208614068023), (5.0, -9.856406460551018)], [(21.0, -9.856406460551018), (21.0, -0.6188021535170058), (29.0, 4.0), (37.0, -0.6188021535170058), (37.0, -9.856406460551018), (29.0, -14.475208614068023), (21.0, -9.856406460551018)], [(-3.0, 4.0), (-3.0, 13.237604307034012), (5.0, 17.856406460551018), (13.0, 13.237604307034012), (13.0, 4.0), (5.0, -0.6188021535170058), (-3.0, 4.0)], [(13.0, 4.0), (13.0, 13.237604307034012), (21.0, 17.856406460551018), (29.0, 13.237604307034012), (29.0, 4.0), (21.0, -0.6188021535170058), (13.0, 4.0)], [(-11.0, 17.856406460551018), (-11.0, 27.09401076758503), (-3.0, 31.712812921102035), (5.0, 27.09401076758503), (5.0, 17.856406460551018), (-3.0, 13.237604307034012), (-11.0, 17.856406460551018)], [(5.0, 17.856406460551018), (5.0, 27.09401076758503), (13.0, 31.712812921102035), (21.0, 27.09401076758503), (21.0, 17.856406460551018), (13.0, 13.237604307034012), (5.0, 17.856406460551018)], [(21.0, 17.856406460551018), (21.0, 27.09401076758503), (29.0, 31.712812921102035), (37.0, 27.09401076758503), (37.0, 17.856406460551018), (29.0, 13.237604307034012), (21.0, 17.856406460551018)], [(-3.0, 31.712812921102035), (-3.0, 40.95041722813605), (5.0, 45.569219381653056), (13.0, 40.95041722813605), (13.0, 31.712812921102035), (5.0, 27.09401076758503), (-3.0, 31.712812921102035)], [(13.0, 31.712812921102035), (13.0, 40.95041722813605), (21.0, 45.569219381653056), (29.0, 40.95041722813605), (29.0, 31.712812921102035), (21.0, 27.09401076758503), (13.0, 31.712812921102035)]]",
      "assert calculate_polygons(9,6,4,3,2)==[[(5.0, 2.5358983848622456), (5.0, 4.8452994616207485), (7.0, 6.0), (9.0, 4.8452994616207485), (9.0, 2.5358983848622456), (7.0, 1.3811978464829942), (5.0, 2.5358983848622456)], [(7.0, 6.0), (7.0, 8.309401076758503), (9.0, 9.464101615137753), (11.0, 8.309401076758503), (11.0, 6.0), (9.0, 4.8452994616207485), (7.0, 6.0)]]"
    ]
  },
  {
    "mbpp_id": 494,
    "problem_statement": "Write a function to convert the given binary tuple to integer.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def binary_to_integer(binary_tuple):\n    # Convert the tuple of binary digits to an integer\n    integer_value = int(''.join(str(bit) for bit in binary_tuple), 2)\n    return str(integer_value)\n\n# Test cases\nprint(binary_to_integer((1, 1, 0, 1, 0, 0, 1)))  # Expected output: \"105\"\nprint(binary_to_integer((0, 1, 1, 0, 0, 1, 0, 1)))  # Expected output: \"101\"\nprint(binary_to_integer((1, 1, 0, 1, 0, 1)))  # Expected output: \"53\"",
    "test_cases": [
      "assert binary_to_integer((1, 1, 0, 1, 0, 0, 1)) == '105'",
      "assert binary_to_integer((0, 1, 1, 0, 0, 1, 0, 1)) == '101'",
      "assert binary_to_integer((1, 1, 0, 1, 0, 1)) == '53'"
    ]
  },
  {
    "mbpp_id": 495,
    "problem_statement": "Write a function to remove lowercase substrings from a given string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef remove_lowercase(input_string):\n    # Use regular expression to replace lowercase letters with an empty string\n    return re.sub('[a-z]', '', input_string)",
    "test_cases": [
      "assert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'",
      "assert remove_lowercase('ProducTnamEstreAmIngMediAplAYer') == 'PTEAIMAAY'",
      "assert remove_lowercase('maNufacTuredbYSheZenTechNolOGIes') == 'NTYSZTNOGI'"
    ]
  },
  {
    "mbpp_id": 496,
    "problem_statement": "Write a function to find the smallest integers from a given list of numbers using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from heapq import heappush, heappop\n\ndef heap_queue_smallest(nums, k):\n    \"\"\"\n    Given a list of numbers and an integer k, return the k smallest elements in the list.\n    \n    :param nums: List[int] - A list of integers.\n    :param k: int - The number of smallest elements to return.\n    :return: List[int] - A list containing the k smallest elements from nums.\n    \"\"\"\n    min_heap = []\n    for num in nums:\n        if len(min_heap) < k:\n            heappush(min_heap, num)\n        else:\n            if num < min_heap[0]:\n                heappop(min_heap)\n                heappush(min_heap, num)\n    result = []\n    while min_heap:\n        result.append(heappop(min_heap))\n    return result[::-1]\n\n# Check function with provided data points\nprint(heap_queue_smallest([25, 35, 22, 85, 14, 65, 75, 25, 58], 3))  # Expected output: [14, 22, 25]\nprint(heap_queue_smallest([25, 35, 22, 85, 14, 65, 75, 25, 58], 2))  # Expected output: [14, 22]\nprint(heap_queue_smallest([25, 35, 22, 85, 14, 65, 75, 22, 58], 5))  # Expected output: [14, 22, 22, 25, 35]",
    "test_cases": [
      "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],3)==[14, 22, 25] ",
      "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 25, 58],2)==[14, 22]",
      "assert heap_queue_smallest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[14, 22, 22, 25, 35]"
    ]
  },
  {
    "mbpp_id": 497,
    "problem_statement": "Write a function to find the surface area of a cone.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'surfacearea_cone' is not defined",
      "Test 2: FAIL - name 'surfacearea_cone' is not defined",
      "Test 3: FAIL - name 'surfacearea_cone' is not defined"
    ],
    "generated_code": "import math\n\ndef surface_area_of_cone(radius, slant_height):\n    # Calculate the base area\n    base_area = math.pi * radius ** 2\n    \n    # Calculate the lateral surface area\n    lateral_surface_area = math.pi * radius * slant_height\n    \n    # Surface area is the sum of the base area and the lateral surface area\n    surface_area = base_area + lateral_surface_area\n    \n    return round(surface_area, 5)\n\n# Test cases\nprint(surface_area_of_cone(5,12)) # Expected output: 282.74334\nprint(surface_area_of_cone(10,15)) # Expected output: 880.51794\nprint(surface_area_of_cone(19,17)) # Expected output: 2655.924",
    "test_cases": [
      "assert surfacearea_cone(5,12)==282.7433388230814",
      "assert surfacearea_cone(10,15)==880.5179353159282",
      "assert surfacearea_cone(19,17)==2655.923961165254"
    ]
  },
  {
    "mbpp_id": 498,
    "problem_statement": "Write a python function to find gcd of two positive integers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def gcd(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\n# Test cases\nprint(gcd(12, 17))  # Expected output: 1\nprint(gcd(4, 6))    # Expected output: 2\nprint(gcd(2, 9))    # Expected output: 1",
    "test_cases": [
      "assert gcd(12, 17) == 1",
      "assert gcd(4,6) == 2",
      "assert gcd(2,9) == 1"
    ]
  },
  {
    "mbpp_id": 499,
    "problem_statement": "Write a function to find the diameter of a circle.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def diameter_circle(radius):\n    return 2 * radius",
    "test_cases": [
      "assert diameter_circle(10)==20",
      "assert diameter_circle(40)==80",
      "assert diameter_circle(15)==30"
    ]
  },
  {
    "mbpp_id": 500,
    "problem_statement": "Write a function to concatenate all elements of the given list into a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def concatenate_elements(elements_list):\n    # Concatenating all elements in the list and removing extra spaces\n    result_string = ''.join(elements_list).strip()\n    return result_string",
    "test_cases": [
      "assert concatenate_elements(['hello','there','have','a','rocky','day'] ) == '  hello there have a rocky day'",
      "assert concatenate_elements([ 'Hi', 'there', 'How','are', 'you'] ) == '  Hi there How are you'",
      "assert concatenate_elements([ 'Part', 'of', 'the','journey', 'is', 'end'] ) == '  Part of the journey is end'"
    ]
  },
  {
    "mbpp_id": 501,
    "problem_statement": "Write a python function to find common divisor between two numbers in a given pair.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def num_comm_div(x, y):\n    def gcd(a, b):\n        while b:\n            t = b\n            b = a % b\n            a = t\n        return a\n    \n    return gcd(x, y)",
    "test_cases": [
      "assert num_comm_div(2,4) == 2",
      "assert num_comm_div(2,8) == 2",
      "assert num_comm_div(12,24) == 6"
    ]
  },
  {
    "mbpp_id": 502,
    "problem_statement": "Write a python function to find remainder of two numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find(x, y):\n    # Calculate the remainder of x divided by y\n    return x % y",
    "test_cases": [
      "assert find(3,3) == 0",
      "assert find(10,3) == 1",
      "assert find(16,5) == 1"
    ]
  },
  {
    "mbpp_id": 503,
    "problem_statement": "Write a function to add consecutive numbers of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def add_consecutive_nums(nums):\n    result = []\n    i = 0\n    while i < len(nums) - 1:\n        current_sum = sum(nums[i:i+2])\n        result.append(current_sum)\n        i += 2\n    return result",
    "test_cases": [
      "assert add_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7])==[2, 4, 7, 8, 9, 11, 13]",
      "assert add_consecutive_nums([4, 5, 8, 9, 6, 10])==[9, 13, 17, 15, 16]",
      "assert add_consecutive_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[3, 5, 7, 9, 11, 13, 15, 17, 19]"
    ]
  },
  {
    "mbpp_id": 504,
    "problem_statement": "Write a python function to find the cube sum of first n natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'sum_Of_Series' is not defined",
      "Test 2: FAIL - name 'sum_Of_Series' is not defined",
      "Test 3: FAIL - name 'sum_Of_Series' is not defined"
    ],
    "generated_code": "def sum_of_series(n):\n    # Calculate the sum of cubes for each number from 1 to n using a loop and an accumulator.\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += i ** 3\n    return total_sum\n\n# Test the function with provided data points\nprint(sum_of_series(5))   # Expected output: 225\nprint(sum_of_series(2))   # Expected output: 9\nprint(sum_of_series(3))   # Expected output: 36",
    "test_cases": [
      "assert sum_Of_Series(5) == 225",
      "assert sum_Of_Series(2) == 9",
      "assert sum_Of_Series(3) == 36"
    ]
  },
  {
    "mbpp_id": 505,
    "problem_statement": "Write a function to move all zeroes to the end of the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: object of type 'NoneType' has no len()"
    ],
    "generated_code": "from typing import List\n\ndef re_order(nums: List[int]) -> None:\n    \"\"\"\n    Moves all zeroes in the given list 'nums' to the end while maintaining the relative order of non-zero elements.\n    \n    Args:\n    nums (List[int]): The input list containing integers.\n    \"\"\"\n    count = nums.count(0)\n    for _ in range(count):\n        nums.remove(0)\n\n    for i in range(count):\n        nums.append(0)\n\n# Check function with provided data points\ndef check_solution():\n    test_cases = [\n        ([6, 0, 8, 2, 3, 0, 4, 0, 1], [6, 8, 2, 3, 4, 1, 0, 0, 0]),\n        ([4, 0, 2, 7, 0, 9, 0, 12, 0], [4, 2, 7, 9, 12, 0, 0, 0, 0]),\n        ([3, 11, 0, 74, 14, 0, 1, 0, 2], [3, 11, 74, 14, 1, 2, 0, 0, 0])\n    ]\n\n    for idx, (input_nums, expected) in enumerate(test_cases, 1):\n        result = re_order(input_nums)\n        if len(result) != len(expected): \n            print(f\"Test Case {idx} failed: Expected length {len(expected)}, but got length {len(result)}\")\n            continue\n        for num, exp_num in zip(result, expected):\n            if num != exp_num:\n                print(f\"Test Case {idx} failed: Result at index {result.index(num)} is {num}, which does not match the expected value {exp_num}\")\n                break\n        else:\n            print(f\"Test Case {idx} passed!\")\n\ncheck_solution()",
    "test_cases": [
      "assert re_order([6, 0, 8, 2, 3, 0, 4, 0, 1]) == [6, 8, 2, 3, 4, 1, 0, 0, 0]",
      "assert re_order([4, 0, 2, 7, 0, 9, 0, 12, 0]) == [4, 2, 7, 9, 12, 0, 0, 0, 0]",
      "assert re_order([3, 11, 0, 74, 14, 0, 1, 0, 2]) == [3, 11, 74, 14, 1, 2, 0, 0, 0]"
    ]
  },
  {
    "mbpp_id": 506,
    "problem_statement": "Write a function to calculate the permutation coefficient of given p(n, k).",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef permutation_coefficient(p, k):\n    \"\"\"\n    Calculate the permutation coefficient of n choose k.\n\n    Args:\n    p (int): The total number of items.\n    k (int): The number of items to be chosen from p.\n\n    Returns:\n    int: The permutation coefficient of p choose k.\n    \"\"\"\n    return math.perm(p, k)\n\n# Check function with provided data points\nprint(permutation_coefficient(10, 2))  # Expected output: 90\nprint(permutation_coefficient(10, 3))  # Expected output: 720\nprint(permutation_coefficient(10, 1))  # Expected output: 10",
    "test_cases": [
      "assert permutation_coefficient(10, 2) == 90",
      "assert permutation_coefficient(10, 3) == 720",
      "assert permutation_coefficient(10, 1) == 10"
    ]
  },
  {
    "mbpp_id": 507,
    "problem_statement": "Write a function to remove specific words from a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_words(word_list, filter_list):\n    return [word for word in word_list if word not in filter_list]",
    "test_cases": [
      "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['white', 'orange'])==['red', 'green', 'blue', 'black']",
      "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['black', 'orange'])==['red', 'green', 'blue', 'white']",
      "assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'],['blue', 'white'])==['red', 'green', 'black', 'orange']"
    ]
  },
  {
    "mbpp_id": 508,
    "problem_statement": "Write a function to check if the common elements between two given lists are in the same order or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\n\ndef same_order(list1: List[str], list2: List[str]) -> bool:\n    # Check if both lists have the same length and contain the same elements in order.\n    return sorted(list1) == sorted(list2)",
    "test_cases": [
      "assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True",
      "assert same_order([\"red\",\"pink\",\"green\",\"white\",\"black\"],[\"white\",\"orange\",\"pink\",\"black\"])==False",
      "assert same_order([\"red\",\"green\",\"black\",\"orange\"],[\"red\",\"pink\",\"green\",\"white\",\"black\"])==True"
    ]
  },
  {
    "mbpp_id": 509,
    "problem_statement": "Write a python function to find the average of odd numbers till a given odd number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def average_Odd(n):\n    sum_odd = 0\n    count = 0\n    for i in range(1, n+1, 2):\n        sum_odd += i\n        count += 1\n    if count == 0:\n        return 0\n    else:\n        return sum_odd / count",
    "test_cases": [
      "assert average_Odd(9) == 5",
      "assert average_Odd(5) == 3",
      "assert average_Odd(11) == 6"
    ]
  },
  {
    "mbpp_id": 510,
    "problem_statement": "Write a function to find the number of subsequences having product smaller than k for the given non negative array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def no_of_subsequences(nums, k):\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        current_product = 1\n        for j in range(i, n):\n            current_product *= nums[j]\n            if current_product < k:\n                count += 1\n    \n    return count",
    "test_cases": [
      "assert no_of_subsequences([1,2,3,4], 10) == 11",
      "assert no_of_subsequences([4,8,7,2], 50) == 9",
      "assert no_of_subsequences([5,6,7,8], 15) == 4"
    ]
  },
  {
    "mbpp_id": 601,
    "problem_statement": "Write a function to find the longest chain which can be formed from the given set of pairs.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List, Tuple\n\nclass Pair:\n    def __init__(self, start: int, end: int):\n        self.start = start\n        self.end = end\n\ndef max_chain_length(pairs: List[Pair], n: int) -> int:\n    # Sort pairs based on their first value in descending order\n    pairs.sort(key=lambda x: -x.start)\n    \n    dp = [1] * n\n    res = 0\n    \n    for i in range(n-1, -1, -1):\n        temp_res = 0\n        for j in range(i+1, min(n, i + 10)):  # Consider up to 10 elements ahead\n            if pairs[j].start > pairs[i].end and dp[j] > temp_res:\n                temp_res = dp[j]\n        \n        dp[i] = temp_res + 1\n        res = max(res, dp[i])\n    \n    return res",
    "test_cases": [
      "assert max_chain_length([Pair(5, 24), Pair(15, 25),Pair(27, 40), Pair(50, 60)], 4) == 3",
      "assert max_chain_length([Pair(1, 2), Pair(3, 4),Pair(5, 6), Pair(7, 8)], 4) == 4",
      "assert max_chain_length([Pair(19, 10), Pair(11, 12),Pair(13, 14), Pair(15, 16), Pair(31, 54)], 5) == 5"
    ]
  },
  {
    "mbpp_id": 602,
    "problem_statement": "Write a python function to find the first repeated character in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def first_repeated_char(s):\n    char_set = set()\n    for char in s:\n        if char in char_set:\n            return char\n        else:\n            char_set.add(char)\n    return None",
    "test_cases": [
      "assert first_repeated_char(\"abcabc\") == \"a\"",
      "assert first_repeated_char(\"abc\") == \"None\"",
      "assert first_repeated_char(\"123123\") == \"1\""
    ]
  },
  {
    "mbpp_id": 603,
    "problem_statement": "Write a function to get a lucid number smaller than or equal to n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from math import isqrt\n\ndef get_ludic(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, isqrt(num) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    result = []\n    num = 2\n    while len(result) < n:\n        if is_prime(num):\n            result.append(num)\n        num += 1\n    return result[:n]\n\n# Test cases\nprint(get_ludic(10))   # Output: [1, 2, 3, 5, 7]\nprint(get_ludic(25))   # Output: [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\nprint(get_ludic(45))   # Output: [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]",
    "test_cases": [
      "assert get_ludic(10) == [1, 2, 3, 5, 7]",
      "assert get_ludic(25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]",
      "assert get_ludic(45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]"
    ]
  },
  {
    "mbpp_id": 604,
    "problem_statement": "Write a function to reverse words in a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def reverse_words(input_str):\n    # Split the input string into words based on spaces and reverse it\n    return ' '.join(input_str.split()[::-1])",
    "test_cases": [
      "assert reverse_words(\"python program\")==(\"program python\")",
      "assert reverse_words(\"java language\")==(\"language java\")",
      "assert reverse_words(\"indian man\")==(\"man indian\")"
    ]
  },
  {
    "mbpp_id": 605,
    "problem_statement": "Write a function to check if the given integer is a prime number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def prime_num(n):\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True",
    "test_cases": [
      "assert prime_num(13)==True",
      "assert prime_num(7)==True",
      "assert prime_num(-1010)==False"
    ]
  },
  {
    "mbpp_id": 606,
    "problem_statement": "Write a function to convert degrees to radians.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef radian_degree(degree):\n    return degree * math.pi / 180",
    "test_cases": [
      "assert radian_degree(90)==1.5707963267948966",
      "assert radian_degree(60)==1.0471975511965976",
      "assert radian_degree(120)==2.0943951023931953"
    ]
  },
  {
    "mbpp_id": 607,
    "problem_statement": "Write a function to search a literals string in a string and also find the location within the original string where the pattern occurs by using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef find_literals(s, p):\n    result = re.search(p, s)\n    if result:\n        start_index = result.start()\n        end_index = result.end()\n        return (result.group(), start_index, end_index - 1)  # Subtract 1 because end index is exclusive\n    else:\n        return None",
    "test_cases": [
      "assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)",
      "assert find_literals('Its been a very crazy procedure right', 'crazy') == ('crazy', 16, 21)",
      "assert find_literals('Hardest choices required strongest will', 'will') == ('will', 35, 39)"
    ]
  },
  {
    "mbpp_id": 608,
    "problem_statement": "Write a python function to find nth bell number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'bell_Number' is not defined",
      "Test 2: FAIL - name 'bell_Number' is not defined",
      "Test 3: FAIL - name 'bell_Number' is not defined"
    ],
    "generated_code": "def bell_number(n):\n    if n == 0:\n        return 1\n    bell = [1] * (n+1)\n    for i in range(2, n+1):\n        for j in range(i-1, -1, -1):\n            bell[i] += bell[j]\n    return bell[n]\n\n# Test cases\nprint(bell_number(2))  # Output: 2\nprint(bell_number(3))  # Output: 5\nprint(bell_number(4))  # Output: 15",
    "test_cases": [
      "assert bell_Number(2) == 2",
      "assert bell_Number(3) == 5",
      "assert bell_Number(4) == 15"
    ]
  },
  {
    "mbpp_id": 609,
    "problem_statement": "Write a python function to find minimum possible value for the given periodic function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def floor_Min(n, m, p):\n    return min(n // m * m, n - (n % m)) if m != 0 else max(n)",
    "test_cases": [
      "assert floor_Min(10,20,30) == 15",
      "assert floor_Min(1,2,1) == 0",
      "assert floor_Min(11,10,9) == 9"
    ]
  },
  {
    "mbpp_id": 610,
    "problem_statement": "Write a python function to remove the k'th element from a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_kth_element(lst, k):\n    del lst[k-1]\n    return lst",
    "test_cases": [
      "assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]",
      "assert remove_kth_element([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4],4)==[0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]",
      "assert remove_kth_element([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10],5)==[10,10,15,19, 18, 17, 26, 26, 17, 18, 10]"
    ]
  },
  {
    "mbpp_id": 611,
    "problem_statement": "Write a function to find the maximum of nth column from the given tuple list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_of_nth(lst, n):\n    # Extract the nth element from each inner tuple and convert them into integers\n    return max([item[n] for item in lst])\n\n# Test Cases\nprint(max_of_nth([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2))  # Output: 19\nprint(max_of_nth([(6, 7, 8), (2, 4, 6), (9, 10, 20)], 1))  # Output: 10\nprint(max_of_nth([(7, 8, 9), (3, 5, 7), (10, 11, 21)], 1))  # Output: 11",
    "test_cases": [
      "assert max_of_nth([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 19",
      "assert max_of_nth([(6, 7, 8), (2, 4, 6), (9, 10, 20)], 1) == 10",
      "assert max_of_nth([(7, 8, 9), (3, 5, 7), (10, 11, 21)], 1) == 11"
    ]
  },
  {
    "mbpp_id": 612,
    "problem_statement": "Write a python function to merge the first and last elements separately in a list of lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def merge(list_of_lists):\n    # Extracting first and last elements from each sublist and appending them accordingly\n    result = []\n    for sub_list in list_of_lists:\n        if len(sub_list) % 2 == 0:\n            result.append(sub_list[:])\n        else:\n            result.append([sub_list[0]] + sub_list[:-1] + [sub_list[-1]])\n    \n    return result",
    "test_cases": [
      "assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]",
      "assert merge([[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]]",
      "assert merge([['x', 'y','z' ], ['a', 'b','c'], ['m', 'n','o']]) == [['x', 'a', 'm'], ['y', 'b', 'n'],['z', 'c','o']]"
    ]
  },
  {
    "mbpp_id": 613,
    "problem_statement": "Write a function to find the maximum value in record list as tuple attribute in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Invalid tuple found with key key1",
      "Test 2: FAIL - Invalid tuple found with key key1",
      "Test 3: FAIL - Invalid tuple found with key key1"
    ],
    "generated_code": "def maximum_value(tuples_list):\n    max_values = []\n    for key, value in tuples_list:\n        if not isinstance(value, tuple) or len(value) == 0:\n            raise ValueError(f\"Invalid tuple found with key {key}\")\n        max_val = max(item for sublist in value for item in sublist)\n        max_values.append((key, max_val))\n    return max_values",
    "test_cases": [
      "assert maximum_value([('key1', [3, 4, 5]), ('key2', [1, 4, 2]), ('key3', [9, 3])]) == [('key1', 5), ('key2', 4), ('key3', 9)]",
      "assert maximum_value([('key1', [4, 5, 6]), ('key2', [2, 5, 3]), ('key3', [10, 4])]) == [('key1', 6), ('key2', 5), ('key3', 10)]",
      "assert maximum_value([('key1', [5, 6, 7]), ('key2', [3, 6, 4]), ('key3', [11, 5])]) == [('key1', 7), ('key2', 6), ('key3', 11)]"
    ]
  },
  {
    "mbpp_id": 614,
    "problem_statement": "Write a function to find the cumulative sum of all the values that are present in the given tuple list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List, Tuple\n\ndef cummulative_sum(tuple_list: List[Tuple[int]]) -> int:\n    # Calculate the total value for each tuple and then add them together.\n    return sum(sum(tup) for tup in tuple_list)",
    "test_cases": [
      "assert cummulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30",
      "assert cummulative_sum([(2, 4), (6, 7, 8), (3, 7)]) == 37",
      "assert cummulative_sum([(3, 5), (7, 8, 9), (4, 8)]) == 44"
    ]
  },
  {
    "mbpp_id": 615,
    "problem_statement": "Write a function to find average value of the numbers in a given tuple of tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def average_tuple(tuples_list):\n    return [sum(sublist)/len(sublist) for sublist in zip(*tuples_list)]",
    "test_cases": [
      "assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]",
      "assert average_tuple(((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3)))== [25.5, -18.0, 3.75]",
      "assert average_tuple( ((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40)))==[305.0, 342.5, 270.0, 232.5]"
    ]
  },
  {
    "mbpp_id": 616,
    "problem_statement": "Write a function to perfom the modulo of tuple elements in the given two tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def tuple_modulo(tup1, tup2):\n    result = []\n    for i in range(len(tup1)):\n        result.append(tup1[i] % tup2[i])\n    return tuple(result)\n\n# Test cases\nprint(tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5))) # Expected output: (0, 4, 5, 1)\nprint(tuple_modulo((11, 5, 6, 7), (6, 7, 8, 6))) # Expected output: (5, 5, 6, 1)\nprint(tuple_modulo((12, 6, 7, 8), (7, 8, 9, 7))) # Expected output: (5, 6, 7, 1)",
    "test_cases": [
      "assert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)",
      "assert tuple_modulo((11, 5, 6, 7), (6, 7, 8, 6)) == (5, 5, 6, 1)",
      "assert tuple_modulo((12, 6, 7, 8), (7, 8, 9, 7)) == (5, 6, 7, 1)"
    ]
  },
  {
    "mbpp_id": 617,
    "problem_statement": "Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_Jumps(length_a, length_b, target):\n    # Check if it's possible to reach (target, 0)\n    if target < max(length_a, length_b):\n        return float('inf')\n    \n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    \n    for i in range(target + 1):\n        if dp[i] != float('inf'):\n            dp[i + length_a] = min(dp[i + length_a], dp[i // length_a] + 1)\n            dp[i + length_b] = min(dp[i + length_b], dp[i // length_b] + 1)\n    \n    return dp[target]\n\n# Test cases\nprint(min_Jumps(3, 4, 11))  # Expected output: 3.5\nprint(min_Jumps(3, 4, 0))   # Expected output: 0\nprint(min_Jumps(11, 14, 11))# Expected output: 1",
    "test_cases": [
      "assert min_Jumps(3,4,11)==3.5",
      "assert min_Jumps(3,4,0)==0",
      "assert min_Jumps(11,14,11)==1"
    ]
  },
  {
    "mbpp_id": 618,
    "problem_statement": "Write a function to divide two lists using map and lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\nimport math\n\ndef div_list(list1: List[int], list2: List[int]) -> List[float]:\n    return [math.floor(num / den) for num, den in zip(list1, list2)]",
    "test_cases": [
      "assert div_list([4,5,6],[1, 2, 3])==[4.0,2.5,2.0]",
      "assert div_list([3,2],[1,4])==[3.0, 0.5]",
      "assert div_list([90,120],[50,70])==[1.8, 1.7142857142857142]"
    ]
  },
  {
    "mbpp_id": 619,
    "problem_statement": "Write a function to move all the numbers in it to the given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef move_num(s):\n    \"\"\"\n    This function takes a string and moves all the numbers within it to the end of the string.\n    The original positions of the numbers are preserved.\n    \n    Parameters:\n    s (str): The input string containing numbers.\n    \n    Returns:\n    str: The modified string with numbers moved to the end.\n    \"\"\"\n    # Extract numbers from the string using regular expression\n    num_pattern = r'\\d+'\n    nums = [match.group(0) for match in re.finditer(num_pattern, s)]\n    # Join the extracted numbers at the end of the string\n    result = ''.join([char for char in s if not char.isdigit()])\n    for num in sorted(nums, reverse=True):\n        result += num\n    return result\n\n# Test cases\nprint(move_num('I1love143you55three3000thousand'))  # Expected output: 'Iloveyouthreethousand1143553000'\nprint(move_num('Avengers124Assemble'))  # Expected output: 'AvengersAssemble124'\nprint(move_num('Its11our12path13to14see15things16do17things'))  # Expected output: 'Itsourpathtoseethingsdothings11121314151617'",
    "test_cases": [
      "assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'",
      "assert move_num('Avengers124Assemble') == 'AvengersAssemble124'",
      "assert move_num('Its11our12path13to14see15things16do17things') == 'Itsourpathtoseethingsdothings11121314151617'"
    ]
  },
  {
    "mbpp_id": 620,
    "problem_statement": "Write a function to find the largest subset where each pair is divisible.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def largest_subset(arr, k):\n    arr.sort()\n    max_length = 1\n    start = 0\n    for end in range(1, len(arr)):\n        if arr[end] - arr[start] >= k:\n            start = end\n        max_length = max(max_length, end - start + 1)\n    return max_length\n\n# Test cases\nprint(largest_subset([1, 3, 6, 13, 17, 18], 6))  # Output: 4\nprint(largest_subset([10, 5, 3, 15, 20], 5))     # Output: 3\nprint(largest_subset([18, 1, 3, 6, 13, 17], 6))   # Output: 4",
    "test_cases": [
      "assert largest_subset([ 1, 3, 6, 13, 17, 18 ], 6) == 4",
      "assert largest_subset([10, 5, 3, 15, 20], 5) == 3",
      "assert largest_subset([18, 1, 3, 6, 13, 17], 6) == 4"
    ]
  },
  {
    "mbpp_id": 621,
    "problem_statement": "Write a function to increment the numeric values in the given strings by k.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - invalid literal for int() with base 10: 'MSM'",
      "Test 2: FAIL - invalid literal for int() with base 10: 'Dart'",
      "Test 3: FAIL - invalid literal for int() with base 10: 'Flutter'"
    ],
    "generated_code": "def increment_numerics(strings_list, increment_value):\n    result = []\n    for string in strings_list:\n        new_string = ''\n        num = int(string)\n        if '.' in str(num):  # Check if the number contains decimal point\n            whole_part = num - int(num)  # Extract whole part of the number\n            fractional_part = float(str(num)[str(num).find('.') + 1:])  # Get fractional part after removing integer part\n            total_increment = increment_value * (1 + (num // 1))  # Calculate full value increase\n            fractional_increment = increment_value * fractional_part  # Calculate fractional value increase\n            incremented_whole = int(total_increment)  # Round up to the nearest integer\n            incremented_fractional = round(fractional_increment)  # Round fractional part\n            final_number = incremented_whole + incremented_fractional  # Combine both parts\n            new_string += str(final_number)\n        else:\n            new_string += str(int(num) + increment_value)  # Increment with no fractional part\n        result.append(new_string)\n    return result",
    "test_cases": [
      "assert increment_numerics([\"MSM\", \"234\", \"is\", \"98\", \"123\", \"best\", \"4\"] , 6) == ['MSM', '240', 'is', '104', '129', 'best', '10']",
      "assert increment_numerics([\"Dart\", \"356\", \"is\", \"88\", \"169\", \"Super\", \"6\"] , 12) == ['Dart', '368', 'is', '100', '181', 'Super', '18']",
      "assert increment_numerics([\"Flutter\", \"451\", \"is\", \"44\", \"96\", \"Magnificent\", \"12\"] , 33) == ['Flutter', '484', 'is', '77', '129', 'Magnificent', '45']"
    ]
  },
  {
    "mbpp_id": 622,
    "problem_statement": "Write a function to find the median of two sorted arrays of same size.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - get_median() takes 2 positional arguments but 3 were given",
      "Test 2: FAIL - get_median() takes 2 positional arguments but 3 were given",
      "Test 3: FAIL - get_median() takes 2 positional arguments but 3 were given"
    ],
    "generated_code": "import heapq\nfrom typing import List\n\ndef get_median(nums1: List[int], nums2: List[int]) -> float:\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, i = 0, min(m, n // 2 + 1)\n\n    # Find minimum and maximum elements\n    max_heap = []\n    for _ in range(i):\n        heapq.heappush(max_heap, -nums1[imin])\n        heapq.heappush(max_heap, -nums2[i-1])\n        imin += 1\n\n    while i < n and -max_heap[0] <= nums2[i]:\n        heapq.heappush(max_heap, -heapq.heappop(nums2))\n        heapq.heappush(max_heap, -heapq.heappop(nums2))\n        i += 1\n\n    return (-max_heap[0] + nums1[min(m, n)]) / 2",
    "test_cases": [
      "assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0",
      "assert get_median([2, 4, 8, 9], [7, 13, 19, 28], 4) == 8.5",
      "assert get_median([3, 6, 14, 23, 36, 42], [2, 18, 27, 39, 49, 55], 6) == 25.0"
    ]
  },
  {
    "mbpp_id": 623,
    "problem_statement": "Write a function to find the n-th power of individual elements in a list using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\nfrom typing import List\n\ndef nth_nums(nums: List[int], n: int) -> List[int]:\n    return [math.pow(num, n) for num in nums]\n\n# Check function with provided data points\nprint(nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2)) # Expected output: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nprint(nth_nums([10,20,30], 3)) # Expected output: ([1000, 8000, 27000])\nprint(nth_nums([12,15], 5)) # Expected output: ([248832, 759375])",
    "test_cases": [
      "assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2)==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]",
      "assert nth_nums([10,20,30],3)==([1000, 8000, 27000])",
      "assert nth_nums([12,15],5)==([248832, 759375])"
    ]
  },
  {
    "mbpp_id": 624,
    "problem_statement": "Write a python function to convert the given string to upper case.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_upper(s):\n    \"\"\"\n    Convert the input string s into uppercase.\n    \n    Parameters:\n    - s (str): The string to be converted.\n    \n    Returns:\n    - str: The uppercase version of the input string.\n    \"\"\"\n    return s.upper()",
    "test_cases": [
      "assert is_upper(\"person\") ==\"PERSON\"",
      "assert is_upper(\"final\") == \"FINAL\"",
      "assert is_upper(\"Valid\") == \"VALID\""
    ]
  },
  {
    "mbpp_id": 625,
    "problem_statement": "Write a python function to interchange first and last elements in a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def swap_List(lst):\n    # Swap the first element with the last element\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst\n\n# Test cases\nprint(swap_List([1,2,3]))  # Expected output: [3, 2, 1]\nprint(swap_List([1,2,3,4,4]))  # Expected output: [4, 2, 3, 4, 1]\nprint(swap_List([4,5,6]))  # Expected output: [6, 5, 4]",
    "test_cases": [
      "assert swap_List([1,2,3]) == [3,2,1]",
      "assert swap_List([1,2,3,4,4]) == [4,2,3,4,1]",
      "assert swap_List([4,5,6]) == [6,5,4]"
    ]
  },
  {
    "mbpp_id": 626,
    "problem_statement": "Write a python function to find the largest triangle that can be inscribed in the semicircle.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: Radius cannot be negative."
    ],
    "generated_code": "import math\n\ndef area_of_triangle(radius):\n    # If radius is negative, an error occurs because it's not possible to have a triangle with a negative radius.\n    if radius < 0:\n        raise ValueError(\"Radius cannot be negative.\")\n    \n    # The maximum area of a right-angled triangle inscribed in a circle with a given radius R\n    # is when the hypotenuse lies on the diameter of the circle and the height from the base to the vertex\n    # at the end of the diameter is equal to the radius itself.\n    max_height = radius\n    max_base = 2 * radius\n    \n    # Area of the triangle using the formula for the area of a right-angled triangle\n    max_area = 0.5 * max_base * max_height\n    return max_area\n\n# Example check function to verify the correctness of the generated function\ndef check_function():\n    assert abs(area_of_triangle(0) - 0) < 1e-9\n    assert abs(area_of_triangle(-1)) == -1\n    assert abs(area_of_triangle(2) - 4) < 1e-9\n\ncheck_function()",
    "test_cases": [
      "assert triangle_area(0) == 0",
      "assert triangle_area(-1) == -1",
      "assert triangle_area(2) == 4"
    ]
  },
  {
    "mbpp_id": 627,
    "problem_statement": "Write a python function to find the smallest missing number from the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - find_First_Missing() takes 2 positional arguments but 3 were given",
      "Test 2: FAIL - find_First_Missing() takes 2 positional arguments but 3 were given",
      "Test 3: FAIL - find_First_Missing() takes 2 positional arguments but 3 were given"
    ],
    "generated_code": "def find_First_Missing(arr, size): \n    i = 0\n    while i < size:\n        j = arr[i] - 1\n        if arr[i] != arr[j]:\n            arr[i], arr[j] = arr[j], arr[i]\n        else:\n            i += 1\n    for i in range(size):\n        if i + 1 != arr[i]:\n            return i + 1\n    return size + 1",
    "test_cases": [
      "assert find_First_Missing([0,1,2,3],0,3) == 4",
      "assert find_First_Missing([0,1,2,6,9],0,4) == 3",
      "assert find_First_Missing([2,3,5,8,9],0,4) == 0"
    ]
  },
  {
    "mbpp_id": 628,
    "problem_statement": "Write a function to replace all spaces in the given string with character * list item * list item * list item * list item '%20'.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def replace_spaces(input_string):\n    # Replace spaces in the input string with %20 and return the result\n    return input_string.replace(' ', '%20')\n\n# Test cases\nprint(replace_spaces(\"My Name is Dawood\"))  # Expected output: \"My%20Name%20is%20Dawood\"\nprint(replace_spaces(\"I am a Programmer\"))  # Expected output: \"I%20am%20a%20Programmer\"\nprint(replace_spaces(\"I love Coding\"))      # Expected output: \"I%20love%20Coding\"",
    "test_cases": [
      "assert replace_spaces(\"My Name is Dawood\") == 'My%20Name%20is%20Dawood'",
      "assert replace_spaces(\"I am a Programmer\") == 'I%20am%20a%20Programmer'",
      "assert replace_spaces(\"I love Coding\") == 'I%20love%20Coding'"
    ]
  },
  {
    "mbpp_id": 629,
    "problem_statement": "Write a python function to find even numbers from a mixed list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Split' is not defined",
      "Test 2: FAIL - name 'Split' is not defined",
      "Test 3: FAIL - name 'Split' is not defined"
    ],
    "generated_code": "def split(lst):\n    # Filter out odd numbers and collect the remaining elements in a new list\n    result = [num for num in lst if not num % 2]\n    return result\n\n# Test cases to verify the correctness of the solution\nassert split([1,2,3,4,5]) == [2,4], \"Test case 1 failed\"\nassert split([4,5,6,7,8,0,1]) == [4,6,8,0], \"Test case 2 failed\"\nassert split([8,12,15,19]) == [8,12], \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert Split([1,2,3,4,5]) == [2,4]",
      "assert Split([4,5,6,7,8,0,1]) == [4,6,8,0]",
      "assert Split ([8,12,15,19]) == [8,12]"
    ]
  },
  {
    "mbpp_id": 630,
    "problem_statement": "Write a function to extract all the adjacent coordinates of the given coordinate tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_coordinates(point):\n    x, y = point\n    result = []\n    for i in range(y-1, y+2):\n        if 0 <= i < 9:\n            result.append([x-1, i])\n    return result\n\n# Test cases\nprint(get_coordinates((3, 4)))  # Expected output: [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\nprint(get_coordinates((4, 5)))  # Expected output: [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\nprint(get_coordinates((5, 6)))  # Expected output: [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]",
    "test_cases": [
      "assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]",
      "assert get_coordinates((4, 5)) ==[[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]",
      "assert get_coordinates((5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]"
    ]
  },
  {
    "mbpp_id": 631,
    "problem_statement": "Write a function to replace whitespaces with an underscore and vice versa in a given string by using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef replace_spaces(input_string):\n    # Replace spaces with underscores and underscores with spaces\n    modified_string = re.sub(r' ', '_', input_string)\n    modified_string = re.sub(r'_', ' ', modified_string)\n    return modified_string.strip('_')\n\n# Test cases\nprint(replace_spaces('Jumanji The Jungle'))  # Expected output: \"Jumanji_The_Jungle\"\nprint(replace_spaces('The Avengers'))        # Expected output: \"The_Avengers\"\nprint(replace_spaces('Fast and Furious'))    # Expected output: \"Fast_and_Furious\"",
    "test_cases": [
      "assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'",
      "assert replace_spaces('The Avengers') == 'The_Avengers'",
      "assert replace_spaces('Fast and Furious') == 'Fast_and_Furious'"
    ]
  },
  {
    "mbpp_id": 632,
    "problem_statement": "Write a python function to move all zeroes to the end of the given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def move_zero(arr):\n    \"\"\"\n    This function takes a list 'arr' as input and returns a new list with all zeros moved to the end.\n    \n    Parameters:\n    arr (list): A list containing integers\n    \n    Returns:\n    list: A new list where all zeros have been moved to the end\n    \"\"\"\n    # Create a copy of the original list to avoid modifying it directly\n    result = arr[:]\n    zero_count = arr.count(0)\n    \n    # Iterate over the array\n    for i in range(len(result)):\n        if result[i] == 0:\n            # Move each zero found from its current position to the beginning of the result list\n            result.insert(i, result.pop())\n    \n    return result[:]\n\n# Test cases\nprint(move_zero([1,0,2,0,3,4]))  # Expected output: [1,2,3,4,0,0]\nprint(move_zero([2,3,2,0,0,4,0,5,0]))  # Expected output: [2,3,2,4,5,0,0,0,0]\nprint(move_zero([0,1,0,1,1]))  # Expected output: [1,1,1,0,0]",
    "test_cases": [
      "assert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]",
      "assert move_zero([2,3,2,0,0,4,0,5,0]) == [2,3,2,4,5,0,0,0,0]",
      "assert move_zero([0,1,0,1,1]) == [1,1,1,0,0]"
    ]
  },
  {
    "mbpp_id": 633,
    "problem_statement": "Write a python function to find the sum of xor of all pairs of numbers in the given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from itertools import combinations\n\ndef pair_OR_Sum(arr, n):\n    result = 0\n    for x, y in combinations(arr, 2):\n        result += x ^ y\n    return result",
    "test_cases": [
      "assert pair_OR_Sum([5,9,7,6],4) == 47",
      "assert pair_OR_Sum([7,3,5],3) == 12",
      "assert pair_OR_Sum([7,3],2) == 4"
    ]
  },
  {
    "mbpp_id": 634,
    "problem_statement": "Write a python function to find the sum of fourth power of first n even natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def even_Power_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            total += (i**4)\n    return total",
    "test_cases": [
      "assert even_Power_Sum(2) == 272",
      "assert even_Power_Sum(3) == 1568",
      "assert even_Power_Sum(4) == 5664"
    ]
  },
  {
    "mbpp_id": 635,
    "problem_statement": "Write a function to push all values into a heap and then pop off the smallest values one at a time.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import heapq\n\ndef heap_sort(arr):\n    \"\"\"\n    Sorts an array in ascending order using a max-heap.\n    \n    Args:\n        arr (list): The list of elements to be sorted.\n        \n    Returns:\n        list: A new list containing the sorted elements.\n    \"\"\"\n    # Create a max-heap from the array\n    heapq._heapify_max(arr)\n    # Pop the smallest element from the heap until it's empty\n    return [heapq._heappop_max(arr) for _ in range(len(arr))]\n\n# Check function with provided data points\nprint(heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]))  # Expected output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(heap_sort([25, 35, 22, 85, 14, 65, 75, 25, 58]))  # Expected output: [14, 22, 25, 25, 35, 58, 65, 75, 85]\nprint(heap_sort([7, 1, 9, 5]))  # Expected output: [1, 5, 7, 9]",
    "test_cases": [
      "assert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]",
      "assert heap_sort([25, 35, 22, 85, 14, 65, 75, 25, 58])==[14, 22, 25, 25, 35, 58, 65, 75, 85]",
      "assert heap_sort( [7, 1, 9, 5])==[1,5,7,9]"
    ]
  },
  {
    "mbpp_id": 636,
    "problem_statement": "Write a python function to check if roots of a quadratic equation are reciprocal of each other or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: math domain error"
    ],
    "generated_code": "import math\n\ndef check_solution(a, b, c):\n    discriminant = b**2 - 4*a*c\n    sqrt_discriminant = math.sqrt(discriminant)\n    \n    # Calculate two roots using the quadratic formula\n    root1 = (-b + sqrt_discriminant) / (2 * a)\n    root2 = (-b - sqrt_discriminant) / (2 * a)\n    \n    # Check if roots are reciprocal of each other\n    is_reciprocal = abs(root1 * root2 - 1) < 1e-9\n    \n    return 'Yes' if is_reciprocal else 'No'\n\n# Test cases\nprint(check_solution(2, 0, 2))  # Expected output: Yes\nprint(check_solution(2, -5, 2)) # Expected output: Yes\nprint(check_solution(1, 2, 3))  # Expected output: No",
    "test_cases": [
      "assert Check_Solution(2,0,2) == \"Yes\"",
      "assert Check_Solution(2,-5,2) == \"Yes\"",
      "assert Check_Solution(1,2,3) == \"No\""
    ]
  },
  {
    "mbpp_id": 637,
    "problem_statement": "Write a function to check whether the given amount has no profit and no loss",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def noprofit_noloss(amount1, amount2):\n    # Check if both amounts are equal\n    return amount1 == amount2",
    "test_cases": [
      "assert noprofit_noloss(1500,1200)==False",
      "assert noprofit_noloss(100,100)==True",
      "assert noprofit_noloss(2000,5000)==False"
    ]
  },
  {
    "mbpp_id": 638,
    "problem_statement": "Write a function to calculate wind chill index.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - SyntaxError: '(' was never closed"
    ],
    "generated_code": "def wind_chill(tempature,speed):\n    return round((tempature - 32) * 5/9 * ((35.74 + (0.6215*tempature)-(35.75*(speed**0.16))+(0.4275*tempature*(speed**0.16))),2)",
    "test_cases": [
      "assert wind_chill(120,35)==40",
      "assert wind_chill(40,70)==86",
      "assert wind_chill(10,100)==116"
    ]
  },
  {
    "mbpp_id": 639,
    "problem_statement": "Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'sample_nam' is not defined",
      "Test 2: FAIL - name 'sample_nam' is not defined",
      "Test 3: FAIL - name 'sample_nam' is not defined"
    ],
    "generated_code": "def remove_and_sum_names(names):\n    # Filter out names starting with a lowercase letter and calculate their lengths\n    filtered_names = [name for name in names if not name[0].islower()]\n    total_length = sum(len(name) for name in filtered_names)\n    return total_length\n\n# Test cases to verify the correctness of the solution\nassert remove_and_sum_names(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\nassert remove_and_sum_names([\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"]) == 10\nassert remove_and_sum_names([\"abcd\", \"Python\", \"abba\", \"aba\"]) == 6",
    "test_cases": [
      "assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith'])==16",
      "assert sample_nam([\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"])==10",
      "assert sample_nam([\"abcd\", \"Python\", \"abba\", \"aba\"])==6"
    ]
  },
  {
    "mbpp_id": 640,
    "problem_statement": "Write a function to remove the parenthesis area in a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_parenthesis(s):\n    return ''.join(c for c in s if not c.isdigit() and c != '(' and c != ')')\n\n# Test cases\nprint(remove_parenthesis([\"python (chrome)\"]))  # Expected output: \"python\"\nprint(remove_parenthesis([\"string(.abc)\"]))     # Expected output: \"string\"\nprint(remove_parenthesis([\"alpha(num)\"]))       # Expected output: \"alpha\"",
    "test_cases": [
      "assert remove_parenthesis([\"python (chrome)\"])==(\"python\")",
      "assert remove_parenthesis([\"string(.abc)\"])==(\"string\")",
      "assert remove_parenthesis([\"alpha(num)\"])==(\"alpha\")"
    ]
  },
  {
    "mbpp_id": 641,
    "problem_statement": "Write a function to find the nth nonagonal number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "def is_nonagonal(n):\n    \"\"\"\n    This function calculates the nth nonagonal number.\n    \n    Parameters:\n    n (int): The position of the nonagonal number to be found.\n    \n    Returns:\n    int: The nth nonagonal number.\n    \"\"\"\n    # Calculate the nth nonagonal number using the formula: n * (7*n - 5)\n    return n * (7*n - 5)\n\n# Test cases to verify the correctness of the function\nassert is_nonagonal(10) == 325, \"Test case 1 failed\"\nassert is_nonagonal(15) == 750, \"Test case 2 failed\"\nassert is_nonagonal(18) == 1089, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert is_nonagonal(10) == 325",
      "assert is_nonagonal(15) == 750",
      "assert is_nonagonal(18) == 1089"
    ]
  },
  {
    "mbpp_id": 642,
    "problem_statement": "Write a function to remove similar rows from the given tuple matrix.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "def remove_similar_row(matrix):\n    # Create an empty set to store unique tuples after removing duplicates\n    result = set()\n    \n    for row in matrix:\n        # Convert each inner list to a tuple and add it to the result set if not already present\n        result.add(tuple(row))\n    \n    # Convert the set back to a list of lists format\n    final_result = [list(x) for x in result]\n    \n    return final_result\n\n# Test cases\nassert remove_similar_row([[(4, 5), (3, 2)], [(2, 2), (4, 6)], [(3, 2), (4, 5)]]) == [[(2, 2), (4, 6)], [(3, 2), (4, 5)]], \"Test case 1 failed\"\nassert remove_similar_row([[(5, 6), (4, 3)], [(3, 3), (5, 7)], [(4, 3), (5, 6)]])\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert remove_similar_row([[(4, 5), (3, 2)], [(2, 2), (4, 6)], [(3, 2), (4, 5)]] ) == {((2, 2), (4, 6)), ((3, 2), (4, 5))}",
      "assert remove_similar_row([[(5, 6), (4, 3)], [(3, 3), (5, 7)], [(4, 3), (5, 6)]] ) == {((4, 3), (5, 6)), ((3, 3), (5, 7))}",
      "assert remove_similar_row([[(6, 7), (5, 4)], [(4, 4), (6, 8)], [(5, 4), (6, 7)]] ) =={((4, 4), (6, 8)), ((5, 4), (6, 7))}"
    ]
  },
  {
    "mbpp_id": 643,
    "problem_statement": "Write a function that matches a word containing 'z', not at the start or end of the word.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef text_match_wordz_middle(text):\n    # Use regex to find words starting with 'z' but not at the beginning or end\n    pattern = r'\\b[ze]nz\\b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "test_cases": [
      "assert text_match_wordz_middle(\"pythonzabc.\")==('Found a match!')",
      "assert text_match_wordz_middle(\"xyzabc.\")==('Found a match!')",
      "assert text_match_wordz_middle(\"  lang  .\")==('Not matched!')"
    ]
  },
  {
    "mbpp_id": 644,
    "problem_statement": "Write a python function to reverse an array upto a given position.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def reverse_Array_Upto_K(arr, k):\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    # Reverse the remaining part of the array up to index k-1\n    for i in range(k // 2):\n        arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n\n    return arr",
    "test_cases": [
      "assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6],4) == [4, 3, 2, 1, 5, 6]",
      "assert reverse_Array_Upto_K([4, 5, 6, 7], 2) == [5, 4, 6, 7]",
      "assert reverse_Array_Upto_K([9, 8, 7, 6, 5],3) == [7, 8, 9, 6, 5]"
    ]
  },
  {
    "mbpp_id": 645,
    "problem_statement": "Write a function to find the product of it’s kth index in the given tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'reduce' is not defined",
      "Test 2: FAIL - name 'reduce' is not defined",
      "Test 3: FAIL - name 'reduce' is not defined"
    ],
    "generated_code": "def find_k_product(tuples_list, k):\n    # Extracting elements from each tuple at index k and calculating their product.\n    return reduce(lambda x, y: x * y, [t[k] for t in tuples_list])",
    "test_cases": [
      "assert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665",
      "assert find_k_product([(6, 7, 8), (2, 4, 6), (9, 10, 20)], 1) == 280",
      "assert find_k_product([(7, 8, 9), (3, 5, 7), (10, 11, 21)], 0) == 210"
    ]
  },
  {
    "mbpp_id": 646,
    "problem_statement": "Write a python function to count number of cubes of size k in a cube of size n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'No_of_cubes' is not defined",
      "Test 2: FAIL - name 'No_of_cubes' is not defined",
      "Test 3: FAIL - name 'No_of_cubes' is not defined"
    ],
    "generated_code": "def no_of_cubes(n, k):\n    \"\"\"\n    Calculate the number of smaller k-cube that can fit inside an n-cube.\n    \n    Parameters:\n    - n (int): The side length of the larger n-cube.\n    - k (int): The edge length of the smaller k-cube.\n    \n    Returns:\n    - int: Number of smaller k-cubes fitting inside the larger n-cube.\n    \"\"\"\n    # Since each dimension of the smaller k-cube fits into n/c and we need all dimensions to be equal,\n    # we use floor division to find out how many such smaller k-cubes can fit along one dimension.\n    # Then multiply these values together for all three dimensions to get total number of smaller k-cubes.\n    result = (n // k)**3\n    return result",
    "test_cases": [
      "assert No_of_cubes(2,1) == 8",
      "assert No_of_cubes(5,2) == 64",
      "assert No_of_cubes(1,1) == 1"
    ]
  },
  {
    "mbpp_id": 647,
    "problem_statement": "Write a function to split a string at uppercase letters.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def split_upperstring(s):\n    return [s[i:i+1] for i in range(len(s)) if s[i].isupper()]",
    "test_cases": [
      "assert split_upperstring(\"PythonProgramLanguage\")==['Python','Program','Language']",
      "assert split_upperstring(\"PythonProgram\")==['Python','Program']",
      "assert split_upperstring(\"ProgrammingLanguage\")==['Programming','Language']"
    ]
  },
  {
    "mbpp_id": 648,
    "problem_statement": "Write a function to exchange the position of every n-th value with (n+1)th value and (n+1)th value with n-th value in a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - list index out of range",
      "Test 2: FAIL - list index out of range",
      "Test 3: FAIL - list index out of range"
    ],
    "generated_code": "def exchange_elements(lst):\n    return [lst[(i-1)*2] if i % 2 == 0 else lst[(i-1)*2 + 1] for i in range(1, len(lst), 2)]",
    "test_cases": [
      "assert exchange_elements([0,1,2,3,4,5])==[1, 0, 3, 2, 5, 4] ",
      "assert exchange_elements([5,6,7,8,9,10])==[6,5,8,7,10,9] ",
      "assert exchange_elements([25,35,45,55,75,95])==[35,25,55,45,95,75] "
    ]
  },
  {
    "mbpp_id": 649,
    "problem_statement": "Write a python function to calculate the sum of the numbers in a list between the indices of a specified range.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sum_Range_list(arr, start, end):\n    # Ensure the indices are within bounds and start is less than end\n    if not (0 <= start < len(arr)) or not (0 <= end < len(arr)):\n        raise ValueError(\"Invalid range\")\n    \n    # Sum the elements from index 'start' to 'end-1'\n    return sum(arr[start:end])",
    "test_cases": [
      "assert sum_Range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12],8,10) == 29",
      "assert sum_Range_list([1,2,3,4,5],1,2) == 5",
      "assert sum_Range_list([1,0,1,2,5,6],4,5) == 11"
    ]
  },
  {
    "mbpp_id": 650,
    "problem_statement": "Write a python function to check whether the given two arrays are equal or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def are_Equal(a, b, len_a, len_b):\n    if len_a != len_b:\n        return False\n    \n    for i in range(len_a):\n        if a[i] != b[i]:\n            return False\n            \n    return True",
    "test_cases": [
      "assert are_Equal([1,2,3],[3,2,1],3,3) == True",
      "assert are_Equal([1,1,1],[2,2,2],3,3) == False",
      "assert are_Equal([8,9],[4,5,6],2,3) == False"
    ]
  },
  {
    "mbpp_id": 651,
    "problem_statement": "Write a function to check if one tuple is a subset of another tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_subset(subset, superset):\n    # Convert both tuples into sets and use 'issubset' method to check if subset is a subset of superset.\n    return set(superset).issubset(set(subset))\n\n# Test cases\nprint(check_subset((10, 4, 5, 6), (5, 10)))  # Expected output: True\nprint(check_subset((1, 2, 3, 4), (5, 6)))   # Expected output: False\nprint(check_subset((7, 8, 9, 10), (10, 8))) # Expected output: True",
    "test_cases": [
      "assert check_subset((10, 4, 5, 6), (5, 10)) == True",
      "assert check_subset((1, 2, 3, 4), (5, 6)) == False",
      "assert check_subset((7, 8, 9, 10), (10, 8)) == True"
    ]
  },
  {
    "mbpp_id": 652,
    "problem_statement": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: 'int' object is not iterable"
    ],
    "generated_code": "def matrix_to_list(matrix):\n    flat_list = [item for sublist in matrix for item in sublist]\n    columns = zip(*flat_list)\n    result = '(' + ', '.join(map(str, x)) + ')'\n    return '[' + ','.join(result) + ']'\n\n# Test cases\nprint(matrix_to_list([[4, 5], [7, 8], [0, 4]]))\nprint(matrix_to_list([[5, 6], [11, 14], [23, 7]]))\nprint(matrix_to_list([[6, 7], [9, 10], [20, 21]]))",
    "test_cases": [
      "assert matrix_to_list([[(4, 5), (7, 8)], [(10, 13), (18, 17)], [(0, 4), (10, 1)]]) == '[(4, 7, 10, 18, 0, 10), (5, 8, 13, 17, 4, 1)]'",
      "assert matrix_to_list([[(5, 6), (8, 9)], [(11, 14), (19, 18)], [(1, 5), (11, 2)]]) == '[(5, 8, 11, 19, 1, 11), (6, 9, 14, 18, 5, 2)]'",
      "assert matrix_to_list([[(6, 7), (9, 10)], [(12, 15), (20, 21)], [(23, 7), (15, 8)]]) == '[(6, 9, 12, 20, 23, 15), (7, 10, 15, 21, 7, 8)]'"
    ]
  },
  {
    "mbpp_id": 653,
    "problem_statement": "Write a function to group a sequence of key-value pairs into a dictionary of lists using collections module.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import defaultdict\n\ndef grouping_dictionary(pairs):\n    # Initialize an empty defaultdict with lists as default factory\n    result = defaultdict(list)\n    \n    # Iterate through each pair in the input list\n    for key, value in pairs:\n        # Append the current value to the corresponding list in the defaultdict\n        result[key].append(value)\n    \n    return dict(result)  # Convert the defaultdict back to a regular dictionary before returning it",
    "test_cases": [
      "assert grouping_dictionary([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)])== ({'yellow': [1, 3], 'blue': [2, 4], 'red': [1]})",
      "assert grouping_dictionary([('yellow', 10), ('blue', 20), ('yellow', 30), ('blue', 40), ('red', 10)])== ({'yellow': [10, 30], 'blue': [20, 40], 'red': [10]})",
      "assert grouping_dictionary([('yellow', 15), ('blue', 25), ('yellow', 35), ('blue', 45), ('red', 15)])== ({'yellow': [15, 35], 'blue': [25, 45], 'red': [15]})"
    ]
  },
  {
    "mbpp_id": 654,
    "problem_statement": "Write a function to find the perimeter of a rectangle.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def rectangle_perimeter(length, width):\n    return 2 * (length + width)",
    "test_cases": [
      "assert rectangle_perimeter(10,20)==60",
      "assert rectangle_perimeter(10,5)==30",
      "assert rectangle_perimeter(4,2)==12"
    ]
  },
  {
    "mbpp_id": 655,
    "problem_statement": "Write a python function to find the sum of fifth power of n natural numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def fifth_Power_Sum(n):\n    # Calculate the sum of the fifth power of n natural numbers using list comprehension and sum function\n    result = sum([i**5 for i in range(1, n+1)])\n    return result",
    "test_cases": [
      "assert fifth_Power_Sum(2) == 33",
      "assert fifth_Power_Sum(4) == 1300",
      "assert fifth_Power_Sum(3) == 276"
    ]
  },
  {
    "mbpp_id": 656,
    "problem_statement": "Write a python function to find the minimum sum of absolute differences of two arrays.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\n\ndef find_Min_Sum(arr1: List[int], arr2: List[int], n: int) -> int:\n    # Sort both arrays in ascending order and calculate cumulative sums.\n    arr1.sort()\n    arr2.sort()\n\n    # Initialize variables to store the result and the maximum difference seen so far.\n    min_sum = float('inf')\n    max_diff = -float('inf')\n\n    # Iterate through each index up to n-1 for simplicity.\n    for i in range(n):\n        diff = abs(arr1[i] - arr2[n-i-1])\n        min_sum += diff * 2\n        if diff > max_diff:\n            max_diff = diff\n\n    # Subtract twice the maximum difference from the total sum found above.\n    return min_sum - 2 * max_diff",
    "test_cases": [
      "assert find_Min_Sum([3,2,1],[2,1,3],3) == 0",
      "assert find_Min_Sum([1,2,3],[4,5,6],3) == 9",
      "assert find_Min_Sum([4,1,8,7],[2,3,6,5],4) == 6"
    ]
  },
  {
    "mbpp_id": 657,
    "problem_statement": "Write a python function to find the first digit in factorial of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def first_Digit(n):\n    if n < 0:\n        raise ValueError(\"Number must be non-negative\")\n    \n    # Calculate factorial using math library\n    import math\n    fact = math.factorial(n)\n    \n    # Convert result to string and iterate from right to left to get the last digit\n    for i in range(len(str(fact)) - 1, -1, -1):\n        if str(fact)[i] != '0':\n            return int(str(fact)[i])\n    \n    # If all digits were zeros, return 0 as per the problem's expectation\n    return 0",
    "test_cases": [
      "assert first_Digit(5) == 1",
      "assert first_Digit(10) == 3",
      "assert first_Digit(7) == 5"
    ]
  },
  {
    "mbpp_id": 658,
    "problem_statement": "Write a function to find the item with maximum occurrences in a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import Counter\n\ndef max_occurrences(lst):\n    # Count the occurrences of each item in the list\n    counts = Counter(lst)\n    # Find the item with the highest occurrence count\n    return max(counts.items(), key=lambda x: x[1])[0]",
    "test_cases": [
      "assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,4,6,9,1,2])==2",
      "assert max_occurrences([1, 3,5, 7,1, 3,13, 15, 17,5, 7,9,1, 11])==1",
      "assert max_occurrences([1, 2, 3,2, 4, 5,1, 1, 1])==1"
    ]
  },
  {
    "mbpp_id": 659,
    "problem_statement": "Write a python function to print duplicants from a list of integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Repeat' is not defined",
      "Test 2: FAIL - name 'Repeat' is not defined",
      "Test 3: FAIL - name 'Repeat' is not defined"
    ],
    "generated_code": "def find_duplicates(numbers):\n    seen = set()\n    duplicates = []\n    \n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n        else:\n            duplicates.append(number)\n    \n    return duplicates\n\n# Test cases\nprint(find_duplicates([10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20]))  # Output: [20, 30, -20, 60]\nprint(find_duplicates([-1, 1, -1, 8]))  # Output: [-1]\nprint(find_duplicates([1, 2, 3, 1, 2,]))  # Output: [1, 2]",
    "test_cases": [
      "assert Repeat([10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20]) == [20, 30, -20, 60]",
      "assert Repeat([-1, 1, -1, 8]) == [-1]",
      "assert Repeat([1, 2, 3, 1, 2,]) == [1, 2]"
    ]
  },
  {
    "mbpp_id": 660,
    "problem_statement": "Write a python function to choose points from two ranges such that no point lies in both the ranges.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'range1' is not defined. Did you mean: 'range'?"
    ],
    "generated_code": "def find_Points(min_range1, max_range1, min_range2, max_range2):\n    # Find the maximum value between the minimum and maximum of both ranges\n    max_value = max(max_range1, max_range2)\n    \n    # Ensure the starting point is chosen from the smaller range's start\n    if max_value < max(range1, range2)[0]:\n        return (max_value, min(range1[0], range2[0]))\n    \n    # If max_value equals either of the larger range's end,\n    # adjust accordingly to ensure the second point is always greater than the first one\n    if max_value == max_range1:\n        return (min(range1[1], max_value), max_value)\n    else:\n        return (max_value, min(range1[0], range2[-1]))\n\n# Test Cases\nprint(find_Points(5, 10, 1, 5))  # Expected output: (1, 10)\nprint(find_Points(3, 5, 7, 9))   # Expected output: (3, 9)\nprint(find_Points(1, 5, 2, 8))   # Expected output: (1, 8)",
    "test_cases": [
      "assert find_Points(5,10,1,5) == (1,10)",
      "assert find_Points(3,5,7,9) == (3,9)",
      "assert find_Points(1,5,2,8) == (1,8)"
    ]
  },
  {
    "mbpp_id": 661,
    "problem_statement": "Write a function to find the maximum sum that can be formed which has no three consecutive elements present.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: invalid index to scalar variable."
    ],
    "generated_code": "from itertools import combinations_with_replacement\nimport numpy as np\n\ndef max_sum_of_three_consecutive(arr, n):\n    \"\"\"\n    Finds the maximum sum of an array where there is no sequence of exactly three consecutive numbers.\n    \n    :param arr: List[int] - The input list of integers.\n    :param n: int - The size of each subarray we want to form from the given array.\n    :return: int - The maximum possible sum of the specified subarray with no three consecutive numbers in it.\n    \"\"\"\n    # Calculate all possible subsequences of length n using combinations_with_replacement\n    subsequences = [np.array(c).sum() for c in combinations_with_replacement(arr, n)]\n    \n    # Filter out subsequences containing three consecutive numbers and keep track of their sums\n    filtered_subseqs = [(subsequence, sum(subsequence)) for subsequence in subsequences if len(set(subsequence[::n])) == n]\n    \n    # Return the maximum sum found among the filtered subsequences\n    return max(filtered_subseqs)[1]\n\n# Test cases\nprint(max_sum_of_three_consecutive([100, 1000, 100, 1000, 1], 5))\nprint(max_sum_of_three_consecutive([3000, 2000, 1000, 3, 10], 5))\nprint(max_sum_of_three_consecutive([1, 2, 3, 4, 5, 6, 7, 8], 8))",
    "test_cases": [
      "assert max_sum_of_three_consecutive([100, 1000, 100, 1000, 1], 5) == 2101",
      "assert max_sum_of_three_consecutive([3000, 2000, 1000, 3, 10], 5) == 5013",
      "assert max_sum_of_three_consecutive([1, 2, 3, 4, 5, 6, 7, 8], 8) == 27"
    ]
  },
  {
    "mbpp_id": 662,
    "problem_statement": "Write a function to sort a list in a dictionary.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sorted_dict(d):\n    return {k: sorted(v) for k, v in d.items()}",
    "test_cases": [
      "assert sorted_dict({'n1': [2, 3, 1], 'n2': [5, 1, 2], 'n3': [3, 2, 4]})=={'n1': [1, 2, 3], 'n2': [1, 2, 5], 'n3': [2, 3, 4]}",
      "assert sorted_dict({'n1': [25,37,41], 'n2': [41,54,63], 'n3': [29,38,93]})=={'n1': [25, 37, 41], 'n2': [41, 54, 63], 'n3': [29, 38, 93]}",
      "assert sorted_dict({'n1': [58,44,56], 'n2': [91,34,58], 'n3': [100,200,300]})=={'n1': [44, 56, 58], 'n2': [34, 58, 91], 'n3': [100, 200, 300]}"
    ]
  },
  {
    "mbpp_id": 663,
    "problem_statement": "Write a function to find the largest possible value of k such that k modulo x is y.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_max_val(x, y, z):\n    \"\"\"\n    Finds the maximum integer 'k' such that 'y % z = k' and 'x >= k'.\n\n    :param x: The upper limit for 'k'.\n    :param y: The divisor used in modulo operation.\n    :param z: The remainder to be achieved when dividing 'x' by 'z'.\n    :return: The maximum integer 'k' satisfying the conditions.\n    \"\"\"\n    # Start from the smallest possible value of k, which is greater than or equal to 0\n    k = max(0, x - z)\n    \n    while k < x:\n        if y % z == k:\n            return k\n        k += 1\n    \n    return None  # In case no valid 'k' is found within the range [0, x]\n\n# Test cases to verify the correctness of the function\nprint(find_max_val(15, 10, 5))  # Expected output: 15\nprint(find_max_val(187, 10, 5)) # Expected output: 185\nprint(find_max_val(16, 11, 1))  # Expected output: 12",
    "test_cases": [
      "assert find_max_val(15, 10, 5) == 15",
      "assert find_max_val(187, 10, 5) == 185",
      "assert find_max_val(16, 11, 1) == 12"
    ]
  },
  {
    "mbpp_id": 664,
    "problem_statement": "Write a python function to find the average of even numbers till a given even number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def average_Even(num):\n    sum_even = 0\n    count = 0\n    \n    for i in range(num + 1): # Loop from 0 to num+1 inclusive\n        if i % 2 == 0:\n            sum_even += i\n            count += 1\n            \n    if count > 0:\n        return sum_even / count\n    else:\n        return 0",
    "test_cases": [
      "assert average_Even(2) == 2",
      "assert average_Even(4) == 3",
      "assert average_Even(100) == 51"
    ]
  },
  {
    "mbpp_id": 665,
    "problem_statement": "Write a python function to shift first element to the end of given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def move_last(lst):\n    # Move the last item to the front of the list and return the modified list\n    lst.append(lst.pop(0))\n    return lst",
    "test_cases": [
      "assert move_last([1,2,3,4]) == [2,3,4,1]",
      "assert move_last([2,3,4,1,5,0]) == [3,4,1,5,0,2]",
      "assert move_last([5,4,3,2,1]) == [4,3,2,1,5]"
    ]
  },
  {
    "mbpp_id": 666,
    "problem_statement": "Write a function to count occurrence of a character in a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_char(s, c):\n    return s.count(c)",
    "test_cases": [
      "assert count_char(\"Python\",'o')==1",
      "assert count_char(\"little\",'t')==2",
      "assert count_char(\"assert\",'s')==2"
    ]
  },
  {
    "mbpp_id": 667,
    "problem_statement": "Write a python function to count number of vowels in the string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Check_Vow' is not defined",
      "Test 2: FAIL - name 'Check_Vow' is not defined",
      "Test 3: FAIL - name 'Check_Vow' is not defined"
    ],
    "generated_code": "def check_vowels(string, vowel_set):\n    \"\"\"\n    Counts the number of characters from the given 'vowel_set' within the input string.\n    \n    Args:\n        string (str): The input string to search through.\n        vowel_set (set): A set containing characters considered as vowels.\n        \n    Returns:\n        int: The number of characters found in the string that are also in the vowel set.\n    \"\"\"\n    count = sum(1 for char in string if char.lower() in vowel_set)\n    return count\n\n# Provided test cases\nprint(check_vowels(\"corner\", {'a', 'e', 'i', 'o', 'u'})) # Expected output: 2\nprint(check_vowels(\"valid\", {'a', 'e', 'i', 'o', 'u'})) # Expected output: 2\nprint(check_vowels(\"true\", {'a', 'e', 'i', 'o', 'u'})) # Expected output: 0",
    "test_cases": [
      "assert Check_Vow('corner','AaEeIiOoUu') == 2",
      "assert Check_Vow('valid','AaEeIiOoUu') == 2",
      "assert Check_Vow('true','AaEeIiOoUu') ==2"
    ]
  },
  {
    "mbpp_id": 668,
    "problem_statement": "Write a python function to replace multiple occurence of character by single.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'replace' is not defined",
      "Test 2: FAIL - name 'replace' is not defined",
      "Test 3: FAIL - name 'replace' is not defined"
    ],
    "generated_code": "def replace_char(s, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in s\n    return s.replace(old_char, new_char)",
    "test_cases": [
      "assert replace('peep','e') == 'pep'",
      "assert replace('Greek','e') == 'Grek'",
      "assert replace('Moon','o') == 'Mon'"
    ]
  },
  {
    "mbpp_id": 669,
    "problem_statement": "Write a function to check whether the given ip address is valid or not using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef check_IP(ip_address):\n    # Define the regular expression pattern for an IP address\n    ip_pattern = r'^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$'\n    \n    # Check if the input matches the pattern of an IPv4 address\n    if re.match(ip_pattern, ip_address) and len(ip_address.split('.')) == 4:\n        return 'Valid IP address'\n    else:\n        return 'Invalid IP address'\n\n# Test cases\nprint(check_IP(\"192.168.0.1\"))   # Expected output: \"Valid IP address\"\nprint(check_IP(\"110.234.52.124\")) # Expected output: \"Valid IP address\"\nprint(check_IP(\"366.1.2.2\"))     # Expected output: \"Invalid IP address\"",
    "test_cases": [
      "assert check_IP(\"192.168.0.1\") == 'Valid IP address'",
      "assert check_IP(\"110.234.52.124\") == 'Valid IP address'",
      "assert check_IP(\"366.1.2.2\") == 'Invalid IP address'"
    ]
  },
  {
    "mbpp_id": 670,
    "problem_statement": "Write a python function to check whether a sequence of numbers has a decreasing trend or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'decreasing_trend' is not defined",
      "Test 2: FAIL - name 'decreasing_trend' is not defined",
      "Test 3: FAIL - name 'decreasing_trend' is not defined"
    ],
    "generated_code": "def is_decreasing(arr):\n    for i in range(len(arr) - 1):\n        if arr[i] < arr[i + 1]:\n            continue\n        else:\n            return False\n    return True\n\n# Test cases\nprint(is_decreasing([-4, -3, -2, -1]))  # Expected output: True\nprint(is_decreasing([1, 2, 3]))         # Expected output: True\nprint(is_decreasing([3, 2, 1]))         # Expected output: False",
    "test_cases": [
      "assert decreasing_trend([-4,-3,-2,-1]) == True",
      "assert decreasing_trend([1,2,3]) == True",
      "assert decreasing_trend([3,2,1]) == False"
    ]
  },
  {
    "mbpp_id": 671,
    "problem_statement": "Write a python function to set the right most unset bit.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def set_Right_most_Unset_Bit(n):\n    \"\"\"\n    Set the rightmost unset bit of n and return the new value.\n    \n    :param n: Integer number whose rightmost unset bit needs to be set.\n    :return: New integer with the rightmost unset bit set.\n    \"\"\"\n    mask = ~(n & -n)\n    return n | mask",
    "test_cases": [
      "assert set_Right_most_Unset_Bit(21) == 23",
      "assert set_Right_most_Unset_Bit(11) == 15",
      "assert set_Right_most_Unset_Bit(15) == 15"
    ]
  },
  {
    "mbpp_id": 672,
    "problem_statement": "Write a function to find maximum of three numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_of_three(a, b, c):\n    return max(a, b, c)",
    "test_cases": [
      "assert max_of_three(10,20,30)==30",
      "assert max_of_three(55,47,39)==55",
      "assert max_of_three(10,49,30)==49"
    ]
  },
  {
    "mbpp_id": 673,
    "problem_statement": "Write a python function to convert a list of multiple integers into a single integer.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def convert(numbers):\n    # Convert each number in the list to a string and join them together\n    result = ''.join(map(str, numbers))\n    return int(result)\n\n# Test cases\nassert convert([1,2,3]) == 123\nassert convert([4,5,6]) == 456\nassert convert([7,8,9]) == 789",
    "test_cases": [
      "assert convert([1,2,3]) == 123",
      "assert convert([4,5,6]) == 456",
      "assert convert([7,8,9]) == 789"
    ]
  },
  {
    "mbpp_id": 674,
    "problem_statement": "Write a function to remove duplicate words from a given string using collections module.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed. Expected Python Exercises Practice Solution, got python exercises practice solution."
    ],
    "generated_code": "from collections import OrderedDict\n\ndef remove_duplicate(input_string):\n    \"\"\"\n    Removes duplicate words from the input_string.\n    \n    Args:\n        input_string (str): The input string with possible duplicate words.\n        \n    Returns:\n        str: A new string with all duplicate words removed.\n    \"\"\"\n    # Splitting the input string into words and converting them to lowercase for case-insensitive comparison\n    word_list = input_string.lower().split()\n    unique_words = list(OrderedDict.fromkeys(word_list))\n    return ' '.join(unique_words)\n\n# Example usage\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"Python Exercises Practice Solution Exercises\"),\n        (\"Python Exercises Practice Solution Python\"),\n        (\"Python Exercises Practice Solution Practice\")\n    ]\n    expected_outputs = [\n        \"Python Exercises Practice Solution\",\n        \"Python Exercises Practice Solution\",\n        \"Python Exercises Practice Solution\"\n    ]\n    \n    for i in range(len(test_cases)):\n        result = remove_duplicate(test_cases[i])\n        assert result == expected_outputs[i], f\"Test case {i+1} failed. Expected {expected_outputs[i]}, got {result}.\"\n        print(f\"Test case {i+1} passed.\")",
    "test_cases": [
      "assert remove_duplicate(\"Python Exercises Practice Solution Exercises\")==(\"Python Exercises Practice Solution\")",
      "assert remove_duplicate(\"Python Exercises Practice Solution Python\")==(\"Python Exercises Practice Solution\")",
      "assert remove_duplicate(\"Python Exercises Practice Solution Practice\")==(\"Python Exercises Practice Solution\")"
    ]
  },
  {
    "mbpp_id": 675,
    "problem_statement": "Write a function to add two integers. however, if the sum is between the given range it will return 20.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_nums(a, b, c, d):\n    \"\"\"\n    Add two integers and return 20 if the sum falls within the range of [c, d]\n    \n    Parameters:\n    a (int): First integer to be added.\n    b (int): Second integer to be added.\n    c (int): The lower bound of the desired sum range.\n    d (int): The upper bound of the desired sum range.\n    \n    Returns:\n    int: The sum of a and b, with 20 returned if the sum is between c and d.\n    \"\"\"\n    total = a + b\n    if c <= total <= d:\n        return 20\n    else:\n        return total",
    "test_cases": [
      "assert sum_nums(2,10,11,20)==20",
      "assert sum_nums(15,17,1,10)==32",
      "assert sum_nums(10,15,5,30)==20"
    ]
  },
  {
    "mbpp_id": 676,
    "problem_statement": "Write a function to remove everything except alphanumeric characters from the given string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef remove_extra_char(input_str):\n    # Use regular expression to replace all non-alphanumeric characters with an empty string\n    clean_string = re.sub('[\\W_]+', '', input_str)\n    return clean_string",
    "test_cases": [
      "assert remove_extra_char('**//Google Android// - 12. ') == 'GoogleAndroid12'",
      "assert remove_extra_char('****//Google Flutter//*** - 36. ') == 'GoogleFlutter36'",
      "assert remove_extra_char('**//Google Firebase// - 478. ') == 'GoogleFirebase478'"
    ]
  },
  {
    "mbpp_id": 677,
    "problem_statement": "Write a function to check if the triangle is valid or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def validity_triangle(a, b, c):\n    # Check if all sides satisfy the triangle inequality theorem\n    return a + b > c and a + c > b and b + c > a",
    "test_cases": [
      "assert validity_triangle(60,50,90)==False",
      "assert validity_triangle(45,75,60)==True",
      "assert validity_triangle(30,50,100)==True"
    ]
  },
  {
    "mbpp_id": 678,
    "problem_statement": "Write a python function to remove spaces from a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_spaces(s):\n    # Remove all spaces from the input string and return the result\n    return ''.join(char for char in s if char != ' ')\n\n# Test the function with provided data points\nprint(remove_spaces(\"a b c\"))  # Expected output: \"abc\"\nprint(remove_spaces(\"1 2 3\"))  # Expected output: \"123\"\nprint(remove_spaces(\" b c\"))   # Expected output: \"bc\"",
    "test_cases": [
      "assert remove_spaces(\"a b c\") == \"abc\"",
      "assert remove_spaces(\"1 2 3\") == \"123\"",
      "assert remove_spaces(\" b c\") == \"bc\""
    ]
  },
  {
    "mbpp_id": 679,
    "problem_statement": "Write a function to access dictionary key’s element by index.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def access_key(dictionary, index):\n    return list(dictionary.keys())[index]",
    "test_cases": [
      "assert access_key({'physics': 80, 'math': 90, 'chemistry': 86},0)== 'physics'",
      "assert access_key({'python':10, 'java': 20, 'C++':30},2)== 'C++'",
      "assert access_key({'program':15,'computer':45},1)== 'computer'"
    ]
  },
  {
    "mbpp_id": 680,
    "problem_statement": "Write a python function to check whether a sequence of numbers has an increasing trend or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'increasing_trend' is not defined",
      "Test 2: FAIL - name 'increasing_trend' is not defined",
      "Test 3: FAIL - name 'increasing_trend' is not defined"
    ],
    "generated_code": "def is_increasing(arr):\n    \"\"\"\n    Check if all elements in the array arr are in strictly increasing order.\n    \n    Args:\n    arr : List[int] -- A list of integers\n    \n    Returns:\n    bool -- True if the list is in strictly increasing order, otherwise False.\n    \"\"\"\n    for i in range(len(arr) - 1):\n        if arr[i] >= arr[i + 1]:\n            return False\n    return True\n\n# Test cases\nprint(is_increasing([1,2,3,4]))  # Expected output: True\nprint(is_increasing([4,3,2,1]))  # Expected output: False\nprint(is_increasing([0,1,4,9]))  # Expected output: True",
    "test_cases": [
      "assert increasing_trend([1,2,3,4]) == True",
      "assert increasing_trend([4,3,2,1]) == False",
      "assert increasing_trend([0,1,4,9]) == True"
    ]
  },
  {
    "mbpp_id": 681,
    "problem_statement": "Write a python function to find the smallest prime divisor of a number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def smallest_Divisor(n):\n    # Iterate through all possible divisors starting from 2\n    for i in range(2, n + 1):\n        if n % i == 0:\n            return i\n    return n\n\n# Test cases\nprint(smallest_Divisor(10))  # Expected output: 2\nprint(smallest_Divisor(25))  # Expected output: 5\nprint(smallest_Divisor(31))  # Expected output: 31",
    "test_cases": [
      "assert smallest_Divisor(10) == 2",
      "assert smallest_Divisor(25) == 5",
      "assert smallest_Divisor(31) == 31"
    ]
  },
  {
    "mbpp_id": 682,
    "problem_statement": "Write a function to multiply two lists using map and lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def mul_list(list1, list2):\n    return list(map(lambda x, y: x * y, list1, list2))",
    "test_cases": [
      "assert mul_list([1, 2, 3],[4,5,6])==[4,10,18]",
      "assert mul_list([1,2],[3,4])==[3,8]",
      "assert mul_list([90,120],[50,70])==[4500,8400]"
    ]
  },
  {
    "mbpp_id": 683,
    "problem_statement": "Write a python function to check whether the given number can be represented by sum of two squares or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef sum_Square(n):\n    # Your task is to implement the logic here\n    for i in range(int(math.sqrt(n)) + 1):\n        j = int(math.sqrt(n - i**2))\n        if i*i + j*j == n:\n            return True\n    return False",
    "test_cases": [
      "assert sum_Square(25) == True",
      "assert sum_Square(24) == False",
      "assert sum_Square(17) == True"
    ]
  },
  {
    "mbpp_id": 684,
    "problem_statement": "Write a python function to count occurences of a character in a repeated string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Char(repeated_str, char):\n    length = len(repeated_str)\n    total_occurrences = int(length / len(char))\n    remaining_characters = length % len(char)\n    \n    total_count = 0\n    for i in range(remaining_characters):\n        if repeated_str[i] == char:\n            total_count += 1\n            \n    if remaining_characters > 0:\n        for _ in range(total_occurrences - 1):\n            total_count += int(remaining_characters / len(char))\n            if repeated_str[total_count % len(char)] == char:\n                total_count += 1\n                \n    return total_count\n\n# Test cases\nprint(count_Char(\"abcac\", 'a')) # Output: 4\nprint(count_Char(\"abca\", 'c')) # Output: 2\nprint(count_Char(\"aba\", 'a')) # Output: 7",
    "test_cases": [
      "assert count_Char(\"abcac\",'a') == 4",
      "assert count_Char(\"abca\",'c') == 2",
      "assert count_Char(\"aba\",'a') == 7"
    ]
  },
  {
    "mbpp_id": 685,
    "problem_statement": "Write a python function to find sum of prime numbers between 1 to n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'sum_Of_Primes' is not defined",
      "Test 2: FAIL - name 'sum_Of_Primes' is not defined",
      "Test 3: FAIL - name 'sum_Of_Primes' is not defined"
    ],
    "generated_code": "def is_prime(num):\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef sum_of_primes(n):\n    \"\"\"Calculate the sum of all prime numbers up to and including n.\"\"\"\n    primes_sum = 0\n    for i in range(2, n+1):\n        if is_prime(i):\n            primes_sum += i\n    return primes_sum\n\n# Test cases\nprint(sum_of_primes(10))   # Expected output: 17\nprint(sum_of_primes(20))   # Expected output: 77\nprint(sum_of_primes(5))    # Expected output: 10",
    "test_cases": [
      "assert sum_Of_Primes(10) == 17",
      "assert sum_Of_Primes(20) == 77",
      "assert sum_Of_Primes(5) == 10"
    ]
  },
  {
    "mbpp_id": 686,
    "problem_statement": "Write a function to find the frequency of each element in the given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def freq_element(lst):\n    from collections import Counter\n    result = Counter(lst)\n    return str(result)\n\n# Test cases\nprint(freq_element([4, 5, 4, 5, 6, 6, 5, 5, 4])) # {'4': 3, '5': 4, '6': 2}\nprint(freq_element([7, 8, 8, 9, 4, 7, 6, 5, 4])) # {'7': 2, '8': 2, '9': 1, '4': 2, '6': 1, '5': 1}\nprint(freq_element([1, 4, 3, 1, 4, 5, 2, 6, 2, 7])) # {'1': 2, '4': 2, '3': 1, '5': 1, '2': 2, '6': 1, '7': 1})",
    "test_cases": [
      "assert freq_element((4, 5, 4, 5, 6, 6, 5, 5, 4) ) == '{4: 3, 5: 4, 6: 2}'",
      "assert freq_element((7, 8, 8, 9, 4, 7, 6, 5, 4) ) == '{7: 2, 8: 2, 9: 1, 4: 2, 6: 1, 5: 1}'",
      "assert freq_element((1, 4, 3, 1, 4, 5, 2, 6, 2, 7) ) == '{1: 2, 4: 2, 3: 1, 5: 1, 2: 2, 6: 1, 7: 1}'"
    ]
  },
  {
    "mbpp_id": 687,
    "problem_statement": "Write a function to find the greatest common divisor (gcd) of two integers by using recursion.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def recur_gcd(a, b):\n    if b == 0:\n        return abs(a)\n    else:\n        return recur_gcd(b, a % b)\n\n# Test cases\nprint(recur_gcd(12, 14)) # Expected output: 2\nprint(recur_gcd(13, 17)) # Expected output: 1\nprint(recur_gcd(9, 3))   # Expected output: 3",
    "test_cases": [
      "assert recur_gcd(12,14) == 2",
      "assert recur_gcd(13,17) == 1",
      "assert recur_gcd(9, 3) == 3"
    ]
  },
  {
    "mbpp_id": 688,
    "problem_statement": "Write a function to get the length of a complex number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef len_complex(real, imaginary):\n    \"\"\"\n    Calculate the magnitude of a complex number given its real and imaginary parts.\n    \n    Args:\n    real (float): The real part of the complex number.\n    imaginary (float): The imaginary part of the complex number.\n    \n    Returns:\n    float: The length of the complex number as per its magnitude.\n    \"\"\"\n    return math.sqrt(real**2 + imaginary**2)\n\n# Test Cases\nprint(len_complex(3,4))  # Expected output: 5.0\nprint(round(len_complex(9,10), 5))  # Expected output: 13.45362\nprint(round(len_complex(7,9), 3))  # Expected output: 11.402",
    "test_cases": [
      "assert len_complex(3,4)==5.0",
      "assert len_complex(9,10)==13.45362404707371",
      "assert len_complex(7,9)==11.40175425099138"
    ]
  },
  {
    "mbpp_id": 689,
    "problem_statement": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_jumps(arr, n): \n    dp = [float('inf')] * n  \n    dp[0] = 0\n  \n    for i in range(n): \n        if (i > arr[i]): \n            break\n        else: \n            dp[i] = dp[i - arr[i]] + 1\n          \n    return min(dp)\n\n# Example usage:\nprint(min_jumps([1, 3, 6, 1, 0, 9], 6))  # Output: 3\nprint(min_jumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9], 11))  # Output: 3\nprint(min_jumps([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 11))  # Output: 10",
    "test_cases": [
      "assert min_jumps([1, 3, 6, 1, 0, 9], 6) == 3",
      "assert min_jumps([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9], 11) == 3",
      "assert min_jumps([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 11) == 10"
    ]
  },
  {
    "mbpp_id": 690,
    "problem_statement": "Write a function to multiply consecutive numbers of a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def mul_consecutive_nums(lst):\n    return [lst[i] * lst[i+1] if i < len(lst) - 1 else None for i in range(len(lst)-1)]",
    "test_cases": [
      "assert mul_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7])==[1, 3, 12, 16, 20, 30, 42]",
      "assert mul_consecutive_nums([4, 5, 8, 9, 6, 10])==[20, 40, 72, 54, 60]",
      "assert mul_consecutive_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 6, 12, 20, 30, 42, 56, 72, 90]"
    ]
  },
  {
    "mbpp_id": 691,
    "problem_statement": "Write a function to group the 1st elements on the basis of 2nd elements in the given tuple list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def group_element(lst):\n    result = {}\n    for x, y in lst:\n        if y not in result:\n            result[y] = []\n        result[y].append(x)\n    return result\n\n# Test cases\nprint(group_element([(6, 5), (2, 7), (2, 5), (8, 7), (9, 8), (3, 7)]))  # Should return {5: [6, 2], 7: [2, 8, 3], 8: [9]}\nprint(group_element([(7, 6), (3, 8), (3, 6), (9, 8), (10, 9), (4, 8)]))  # Should return {6: [7, 3], 8: [3, 9, 4], 9: [10]}\nprint(group_element([(8, 7), (4, 9), (4, 7), (10, 9), (11, 10), (5, 9)]))  # Should return {7: [8, 4], 9: [4, 10, 5], 10: [11]}",
    "test_cases": [
      "assert group_element([(6, 5), (2, 7), (2, 5), (8, 7), (9, 8), (3, 7)]) == {5: [6, 2], 7: [2, 8, 3], 8: [9]}",
      "assert group_element([(7, 6), (3, 8), (3, 6), (9, 8), (10, 9), (4, 8)]) == {6: [7, 3], 8: [3, 9, 4], 9: [10]}",
      "assert group_element([(8, 7), (4, 9), (4, 7), (10, 9), (11, 10), (5, 9)]) == {7: [8, 4], 9: [4, 10, 5], 10: [11]}"
    ]
  },
  {
    "mbpp_id": 692,
    "problem_statement": "Write a python function to find the last two digits in factorial of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def last_Two_Digits(n):\n    \"\"\"\n    Calculate and return the last two digits of n! (n factorial).\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The last two digits of n!\n    \"\"\"\n    # Base case for recursion where n is less than 5\n    if n < 5:\n        result = 1\n        while n > 0:\n            result *= n\n            n -= 1\n        return str(result)[-2:]  # Return the last two digits as a string\n    else:\n        # Recursive call to calculate (n-5)! * 10^k\n        k = 5 - n % 5  # Determine how many times we need to multiply by 10\n        result = (factorial(n - 5) * pow(10, k)) % 100\n        return str(result)[-2:]\n\n# Helper function to calculate factorial recursively\ndef factorial(x):\n    if x == 0 or x == 1:\n        return 1\n    else:\n        return x * factorial(x - 1)",
    "test_cases": [
      "assert last_Two_Digits(7) == 40",
      "assert last_Two_Digits(5) == 20",
      "assert last_Two_Digits(2) == 2"
    ]
  },
  {
    "mbpp_id": 693,
    "problem_statement": "Write a function to remove multiple spaces in a string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef remove_multiple_spaces(input_string):\n    # Use regular expression to replace one or more whitespace characters with a single space\n    cleaned_string = re.sub(r'\\s+', ' ', input_string).strip()\n    return cleaned_string\n\n# Test cases\nprint(remove_multiple_spaces('Google      Assistant'))  # Expected output: Google Assistant\nprint(remove_multiple_spaces('Quad      Core'))         # Expected output: Quad Core\nprint(remove_multiple_spaces('ChromeCast      Built-in'))  # Expected output: ChromeCast Built-in",
    "test_cases": [
      "assert remove_multiple_spaces('Google      Assistant') == 'Google Assistant'",
      "assert remove_multiple_spaces('Quad      Core') == 'Quad Core'",
      "assert remove_multiple_spaces('ChromeCast      Built-in') == 'ChromeCast Built-in'"
    ]
  },
  {
    "mbpp_id": 694,
    "problem_statement": "Write a function to extract unique values from the given dictionary values.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def extract_unique(dict_values):\n    # Convert list of lists into a set to remove duplicates and then convert back to list\n    return list(set([item for sublist in dict_values.values() for item in sublist]))\n\n# Test cases\nprint(extract_unique({'msm' : [5, 6, 7, 8],'is' : [10, 11, 7, 5],'best' : [6, 12, 10, 8],'for' : [1, 2, 5]}))\nprint(extract_unique({'Built' : [7, 1, 9, 4],'for' : [11, 21, 36, 14, 9],'ISP' : [4, 1, 21, 39, 47],'TV' : [1, 32, 38]}))\nprint(extract_unique({'F' : [11, 13, 14, 17],'A' : [12, 11, 15, 18],'N' : [19, 21, 15, 36],'G' : [37, 36, 35]}))",
    "test_cases": [
      "assert extract_unique({'msm' : [5, 6, 7, 8],'is' : [10, 11, 7, 5],'best' : [6, 12, 10, 8],'for' : [1, 2, 5]} ) == [1, 2, 5, 6, 7, 8, 10, 11, 12]",
      "assert extract_unique({'Built' : [7, 1, 9, 4],'for' : [11, 21, 36, 14, 9],'ISP' : [4, 1, 21, 39, 47],'TV' : [1, 32, 38]} ) == [1, 4, 7, 9, 11, 14, 21, 32, 36, 38, 39, 47]",
      "assert extract_unique({'F' : [11, 13, 14, 17],'A' : [12, 11, 15, 18],'N' : [19, 21, 15, 36],'G' : [37, 36, 35]}) == [11, 12, 13, 14, 15, 17, 18, 19, 21, 35, 36, 37]"
    ]
  },
  {
    "mbpp_id": 695,
    "problem_statement": "Write a function to check if each element of the second tuple is greater than its corresponding index in the first tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_greater(tup1, tup2):\n    # Check if lengths of tuples match and ensure not empty\n    if len(tup1) != len(tup2) or len(tup1) == 0:\n        return False\n    \n    # Compare elements from both tuples\n    for i in range(len(tup1)):\n        if tup1[i] <= tup2[i]:\n            return False\n            \n    return True",
    "test_cases": [
      "assert check_greater((10, 4, 5), (13, 5, 18)) == True",
      "assert check_greater((1, 2, 3), (2, 1, 4)) == False",
      "assert check_greater((4, 5, 6), (5, 6, 7)) == True"
    ]
  },
  {
    "mbpp_id": 696,
    "problem_statement": "Write a function to zip two given lists of lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'zip_list' is not defined",
      "Test 2: FAIL - name 'zip_list' is not defined",
      "Test 3: FAIL - name 'zip_list' is not defined"
    ],
    "generated_code": "def zip_lists(list1, list2):\n    return list(zip(list1, list2))\n\n# Test cases\nprint(zip_lists([[1, 3], [5, 7], [9, 11]], [[2, 4], [6, 8], [10, 12, 14]])) # [[1, 3, 2, 4], [5, 7, 6, 8], [9, 11, 10, 12, 14]]\nprint(zip_lists([[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11, 12]])) # [[1, 2, 7, 8], [3, 4, 9, 10], [5, 6, 11, 12]]\nprint(zip_lists([['a', 'b'], ['c', 'd']], [['e', 'f'], ['g', 'h']])) # [['a', 'b', 'e', 'f'], ['c', 'd', 'g', 'h']]",
    "test_cases": [
      "assert zip_list([[1, 3], [5, 7], [9, 11]] ,[[2, 4], [6, 8], [10, 12, 14]] )==[[1, 3, 2, 4], [5, 7, 6, 8], [9, 11, 10, 12, 14]]",
      "assert zip_list([[1, 2], [3, 4], [5, 6]] ,[[7, 8], [9, 10], [11, 12]] )==[[1, 2, 7, 8], [3, 4, 9, 10], [5, 6, 11, 12]]",
      "assert zip_list([['a','b'],['c','d']] , [['e','f'],['g','h']] )==[['a','b','e','f'],['c','d','g','h']]"
    ]
  },
  {
    "mbpp_id": 697,
    "problem_statement": "Write a function to find number of even elements in the given list using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_even(numbers):\n    # Use a lambda function to filter even numbers and return their count\n    return len(list(filter(lambda x: x % 2 == 0, numbers)))\n\n# Test cases\nprint(count_even([1, 2, 3, 5, 7, 8, 9, 10]))  # Expected output: 3\nprint(count_even([10, 15, 14, 13, -18, 12, -20]))  # Expected output: 5\nprint(count_even([1, 2, 4, 8, 9]))  # Expected output: 3",
    "test_cases": [
      "assert count_even([1, 2, 3, 5, 7, 8, 9, 10])==3",
      "assert count_even([10,15,14,13,-18,12,-20])==5",
      "assert count_even([1, 2, 4, 8, 9])==3"
    ]
  },
  {
    "mbpp_id": 698,
    "problem_statement": "Write a function to sort dictionary items by tuple product of keys for the given dictionary with tuple keys.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sort_dict_item(d):\n    # Sort dictionary items by the tuple product of keys in descending order.\n    sorted_items = sorted(d.items(), key=lambda item: item[0][0]*item[0][1], reverse=True)\n    # Create a new dictionary from sorted items.\n    result_dict = {key: value for key, value in sorted_items}\n    return result_dict\n\n# Test cases\nprint(sort_dict_item({(5, 6): 3, (2, 3): 9, (8, 4): 10, (6, 4): 12}))\nprint(sort_dict_item({(6, 7): 4, (3, 4): 10, (9, 5): 11, (7, 5): 13}))\nprint(sort_dict_item({(7, 8): 5, (4, 5): 11, (10, 6): 12, (8, 6): 14}))",
    "test_cases": [
      "assert sort_dict_item({(5, 6) : 3, (2, 3) : 9, (8, 4): 10, (6, 4): 12} ) == {(2, 3): 9, (6, 4): 12, (5, 6): 3, (8, 4): 10}",
      "assert sort_dict_item({(6, 7) : 4, (3, 4) : 10, (9, 5): 11, (7, 5): 13} ) == {(3, 4): 10, (7, 5): 13, (6, 7): 4, (9, 5): 11}",
      "assert sort_dict_item({(7, 8) : 5, (4, 5) : 11, (10, 6): 12, (8, 6): 14} ) == {(4, 5): 11, (8, 6): 14, (7, 8): 5, (10, 6): 12}"
    ]
  },
  {
    "mbpp_id": 699,
    "problem_statement": "Write a python function to find the minimum number of swaps required to convert one binary string to another.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_Swaps(s1, s2):\n    count = 0\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            count += 1\n    return count - 1",
    "test_cases": [
      "assert min_Swaps(\"1101\",\"1110\") == 1",
      "assert min_Swaps(\"1111\",\"0100\") == \"Not Possible\"",
      "assert min_Swaps(\"1110000\",\"0001101\") == 3"
    ]
  },
  {
    "mbpp_id": 700,
    "problem_statement": "Write a function to count the number of elements in a list which are within a specific range.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def count_range_in_list(lst, start, end):\n    \"\"\"\n    Counts how many elements in the given list fall within the specified range [start, end).\n    \n    Parameters:\n        lst (list): The list of integers to search through.\n        start (int): The starting value of the range.\n        end (int): The ending value exclusive of the upper bound.\n        \n    Returns:\n        int: The count of numbers within the specified range.\n    \"\"\"\n    return sum(1 for x in lst if start <= x < end)\n\n# Check function with provided data points\nassert count_range_in_list([10,20,30,40,40,40,70,80,99],40,100) == 6\nassert count_range_in_list(['a','b','c','d','e','f'], 'a', 'e') == 5\nassert count_range_in_list([7,8,9,15,17,19,45], 15, 20) == 3\nprint(\"All tests passed.\")",
    "test_cases": [
      "assert count_range_in_list([10,20,30,40,40,40,70,80,99],40,100)==6",
      "assert count_range_in_list(['a','b','c','d','e','f'],'a','e')==5",
      "assert count_range_in_list([7,8,9,15,17,19,45],15,20)==3"
    ]
  },
  {
    "mbpp_id": 701,
    "problem_statement": "Write a function to find the equilibrium index of the given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def equilibrium_index(arr):\n    total_sum = sum(arr)\n    left_sum = 0\n    \n    for i in range(len(arr)):\n        # Subtracting current element from total sum to get right sum\n        if left_sum == (total_sum - left_sum - arr[i]):\n            return i\n        left_sum += arr[i]\n    \n    return -1",
    "test_cases": [
      "assert equilibrium_index([1, 2, 3, 4, 1, 2, 3]) == 3",
      "assert equilibrium_index([-7, 1, 5, 2, -4, 3, 0]) == 3",
      "assert equilibrium_index([1, 2, 3]) == -1"
    ]
  },
  {
    "mbpp_id": 702,
    "problem_statement": "Write a function to find the minimum number of elements that should be removed such that amax-amin<=k.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def removals(nums, k, max_diff):\n    nums.sort()\n    min_removals = float('inf')\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            current_sum = sum(nums[i:j])\n            if abs(current_sum - 2 * k) <= max_diff:\n                min_removals = min(min_removals, j - i)\n                \n    return min_removals\n\n# Test cases\nprint(removals([1, 3, 4, 9, 10,11, 12, 17, 20], 9, 4))  # Output: 5\nprint(removals([1, 5, 6, 2, 8], 5, 2))                  # Output: 3\nprint(removals([1, 2, 3 ,4, 5, 6], 6, 3))               # Output: 2",
    "test_cases": [
      "assert removals([1, 3, 4, 9, 10,11, 12, 17, 20], 9, 4) == 5",
      "assert removals([1, 5, 6, 2, 8], 5, 2) == 3",
      "assert removals([1, 2, 3 ,4, 5, 6], 6, 3) == 2"
    ]
  },
  {
    "mbpp_id": 703,
    "problem_statement": "Write a function to check whether the given key is present in the dictionary or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_key_present(dictionary, key):\n    return key in dictionary.keys()",
    "test_cases": [
      "assert is_key_present({1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60},5)==True",
      "assert is_key_present({1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60},6)==True",
      "assert is_key_present({1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60},10)==False"
    ]
  },
  {
    "mbpp_id": 704,
    "problem_statement": "Write a function to calculate the harmonic sum of n-1.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef harmonic_sum(n):\n    total = 0\n    for i in range(1, n+1):\n        total += 1/i\n    return total",
    "test_cases": [
      "assert harmonic_sum(10)==2.9289682539682538",
      "assert harmonic_sum(4)==2.083333333333333",
      "assert harmonic_sum(7)==2.5928571428571425 "
    ]
  },
  {
    "mbpp_id": 705,
    "problem_statement": "Write a function to sort a list of lists by length and value.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sort_sublists(lists):\n    return sorted(lists, key=lambda x: (len(x), x))",
    "test_cases": [
      "assert sort_sublists([[2], [0], [1, 3], [0, 7], [9, 11], [13, 15, 17]])==[[0], [2], [0, 7], [1, 3], [9, 11], [13, 15, 17]]",
      "assert sort_sublists([[1], [2, 3], [4, 5, 6], [7], [10, 11]])==[[1], [7], [2, 3], [10, 11], [4, 5, 6]]",
      "assert sort_sublists([[\"python\"],[\"java\",\"C\",\"C++\"],[\"DBMS\"],[\"SQL\",\"HTML\"]])==[['DBMS'], ['python'], ['SQL', 'HTML'], ['java', 'C', 'C++']]"
    ]
  },
  {
    "mbpp_id": 706,
    "problem_statement": "Write a function to find whether an array is subset of another array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_subset(arr1, size1, arr2, size2):\n    for i in range(size1):\n        if arr2.count(arr1[i]) == 0:\n            return False\n    return True\n\n# Test Cases\nprint(is_subset([11, 1, 13, 21, 3, 7], 6, [11, 3, 7, 1], 4))  # Expected output: True\nprint(is_subset([1, 2, 3, 4, 5, 6], 6, [1, 2, 4], 3))         # Expected output: True\nprint(is_subset([10, 5, 2, 23, 19], 5, [19, 5, 3], 3))        # Expected output: False",
    "test_cases": [
      "assert is_subset([11, 1, 13, 21, 3, 7], 6, [11, 3, 7, 1], 4) == True",
      "assert is_subset([1, 2, 3, 4, 5, 6], 6, [1, 2, 4], 3) == True",
      "assert is_subset([10, 5, 2, 23, 19], 5, [19, 5, 3], 3) == False"
    ]
  },
  {
    "mbpp_id": 707,
    "problem_statement": "Write a python function to count the total set bits from 1 to n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Set_Bits(n):\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') > 0:\n            count += 1\n    return count\n\n# Test cases\nprint(count_Set_Bits(16))  # Expected output: 33\nprint(count_Set_Bits(2))   # Expected output: 2\nprint(count_Set_Bits(14))  # Expected output: 28",
    "test_cases": [
      "assert count_Set_Bits(16) == 33",
      "assert count_Set_Bits(2) == 2",
      "assert count_Set_Bits(14) == 28"
    ]
  },
  {
    "mbpp_id": 708,
    "problem_statement": "Write a python function to convert a string to a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Convert' is not defined",
      "Test 2: FAIL - name 'Convert' is not defined",
      "Test 3: FAIL - name 'Convert' is not defined"
    ],
    "generated_code": "def convert_to_list(s):\n    # Split the input string into a list of words based on spaces and empty strings.\n    return s.split()",
    "test_cases": [
      "assert Convert('python program') == ['python','program']",
      "assert Convert('Data Analysis') ==['Data','Analysis']",
      "assert Convert('Hadoop Training') == ['Hadoop','Training']"
    ]
  },
  {
    "mbpp_id": 709,
    "problem_statement": "Write a function to count unique keys for each value present in the tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: sequence item 0: expected str instance, int found"
    ],
    "generated_code": "def get_unique(tuples_list):\n    # Create an empty dictionary to store counts of each value\n    value_counts = {}\n    \n    # Iterate through each tuple in the list\n    for tuple_element in tuples_list:\n        value = tuple_element[1]  # Get the second element as it represents the value\n        \n        if value not in value_counts:\n            value_counts[value] = 0  # Initialize count for new values\n        \n        value_counts[value] += 1  # Increment count for the found value\n    \n    # Sort the dictionary by key and convert to string format\n    result_dict = {k: str(v) for k, v in sorted(value_counts.items())}\n    \n    return '{{' + ', '.join(result_dict.keys()) + '}}'\n\n# Test cases\nprint(get_unique([(3, 4), (1, 2), (2, 4), (8, 2), (7, 2), (8, 1), (9, 1), (8, 4), (10, 4)]))  # Should return '{4: 4, 2: 3, 1: 2}'\nprint(get_unique([(4, 5), (2, 3), (3, 5), (9, 3), (8, 3), (9, 2), (10, 2), (9, 5), (11, 5)]))   # Should return '{5: 4, 3: 3, 2: 2}'\nprint(get_unique([(6, 5), (3, 4), (2, 6), (11, 1), (8, 22), (8, 11), (4, 3), (14, 3), (11, 6)])) # Should return '{5: 1, 4: 1, 6: 2, 1: 1, 22: 1, 11: 1, 3: 2}'",
    "test_cases": [
      "assert get_unique([(3, 4), (1, 2), (2, 4), (8, 2), (7, 2), (8, 1), (9, 1), (8, 4), (10, 4)] ) == '{4: 4, 2: 3, 1: 2}'",
      "assert get_unique([(4, 5), (2, 3), (3, 5), (9, 3), (8, 3), (9, 2), (10, 2), (9, 5), (11, 5)] ) == '{5: 4, 3: 3, 2: 2}'",
      "assert get_unique([(6, 5), (3, 4), (2, 6), (11, 1), (8, 22), (8, 11), (4, 3), (14, 3), (11, 6)] ) == '{5: 1, 4: 1, 6: 2, 1: 1, 22: 1, 11: 1, 3: 2}'"
    ]
  },
  {
    "mbpp_id": 710,
    "problem_statement": "Write a function to access the initial and last data of the given tuple record.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def front_and_rear(tpl):\n    # Extracting the first element from the tuple as 'front' \n    front = tpl[0]\n    # Extracting the second-last element from the tuple as 'rear'\n    rear = tpl[-2]\n    return (front, rear)\n\n# Test cases\nprint(front_and_rear((10, 4, 5, 6, 7)))  # Expected output: (10, 7)\nprint(front_and_rear((1, 2, 3, 4, 5)))   # Expected output: (1, 5)\nprint(front_and_rear((6, 7, 8, 9, 10)))  # Expected output: (6, 10)",
    "test_cases": [
      "assert front_and_rear((10, 4, 5, 6, 7)) == (10, 7)",
      "assert front_and_rear((1, 2, 3, 4, 5)) == (1, 5)",
      "assert front_and_rear((6, 7, 8, 9, 10)) == (6, 10)"
    ]
  },
  {
    "mbpp_id": 711,
    "problem_statement": "Write a python function to check whether the product of digits of a number at even and odd places is equal or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def product_Equal(num):\n    \"\"\"\n    This function checks if the product of the digits in the even positions of a number \n    is equal to the product of the digits in the odd positions.\n    \n    Parameters:\n    num (int): The input number\n    \n    Returns:\n    bool: True if the products are equal, False otherwise\n    \"\"\"\n    # Convert the number to string to easily access each digit\n    num_str = str(num)\n    \n    # Initialize products for even and odd position digits\n    even_product = 1\n    odd_product = 1\n    \n    # Calculate the product for even and odd position digits\n    for i in range(len(num_str)):\n        if i % 2 == 0:\n            even_product *= int(num_str[i])\n        else:\n            odd_product *= int(num_str[i])\n    \n    # Compare the two products\n    return even_product == odd_product",
    "test_cases": [
      "assert product_Equal(2841) == True",
      "assert product_Equal(1234) == False",
      "assert product_Equal(1212) == False"
    ]
  },
  {
    "mbpp_id": 712,
    "problem_statement": "Write a function to remove duplicates from a list of lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - 'int' object is not iterable"
    ],
    "generated_code": "def remove_duplicate(lists):\n    return list(set(tuple(item) for item in lists))",
    "test_cases": [
      "assert remove_duplicate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[[10, 20], [30, 56, 25], [33], [40]] ",
      "assert remove_duplicate([\"a\", \"b\", \"a\", \"c\", \"c\"] )==[\"a\", \"b\", \"c\"]",
      "assert remove_duplicate([1, 3, 5, 6, 3, 5, 6, 1] )==[1, 3, 5, 6]"
    ]
  },
  {
    "mbpp_id": 713,
    "problem_statement": "Write a function to check if the given tuple contains all valid values or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_valid(test_tuple):\n    # Check if there is an element in the tuple which is of type bool and its value is True.\n    for item in test_tuple:\n        if isinstance(item, bool) and item == True:\n            continue\n        else:\n            return False\n    return True",
    "test_cases": [
      "assert check_valid((True, True, True, True) ) == True",
      "assert check_valid((True, False, True, True) ) == False",
      "assert check_valid((True, True, True, True) ) == True"
    ]
  },
  {
    "mbpp_id": 714,
    "problem_statement": "Write a python function to count the number of distinct power of prime factor of given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Fac(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def get_primes_factors(n):\n        primes = []\n        while n > 1:\n            for j in range(2, n + 1):\n                if n % j == 0 and is_prime(j):\n                    primes.append(j)\n                    n //= j\n                    break\n        return primes\n    \n    fac_count = 0\n    factors = get_primes_factors(n)\n    unique_factors = set(factors)\n    \n    for factor in unique_factors:\n        exponent = 0\n        while n % factor == 0:\n            n //= factor\n            exponent += 1\n        fac_count += exponent\n    \n    return fac_count",
    "test_cases": [
      "assert count_Fac(24) == 3",
      "assert count_Fac(12) == 2",
      "assert count_Fac(4) == 1"
    ]
  },
  {
    "mbpp_id": 715,
    "problem_statement": "Write a function to convert the given string of integers into a tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def str_to_tuple(input_str):\n    # Split the input string by comma and convert each element to an integer\n    elements = map(int, input_str.split(\", \"))\n    # Convert the list of integers into a tuple\n    result_tuple = tuple(elements)\n    return result_tuple",
    "test_cases": [
      "assert str_to_tuple(\"1, -5, 4, 6, 7\") == (1, -5, 4, 6, 7)",
      "assert str_to_tuple(\"1, 2, 3, 4, 5\") == (1, 2, 3, 4, 5)",
      "assert str_to_tuple(\"4, 6, 9, 11, 13, 14\") == (4, 6, 9, 11, 13, 14)"
    ]
  },
  {
    "mbpp_id": 716,
    "problem_statement": "Write a function to find the perimeter of a rombus.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def rombus_perimeter(sidelength):\n    # The perimeter of a rhombus is four times the length of one side.\n    return 4 * sidelength",
    "test_cases": [
      "assert rombus_perimeter(10)==40",
      "assert rombus_perimeter(5)==20",
      "assert rombus_perimeter(4)==16"
    ]
  },
  {
    "mbpp_id": 717,
    "problem_statement": "Write a function to calculate the standard deviation.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef sd_calc(numbers):\n    mean = sum(numbers) / len(numbers)\n    variance = sum((x - mean)**2 for x in numbers) / len(numbers)\n    return round(math.sqrt(variance), 3)\n\n# Test cases\nprint(sd_calc([4, 2, 5, 8, 6])) # Expected output: 2.236\nprint(sd_calc([1,2,3,4,5,6,7])) # Expected output: 2.16\nprint(sd_calc([5,9,10,15,6,4])) # Expected output: 4.07",
    "test_cases": [
      "assert sd_calc([4, 2, 5, 8, 6])== 2.23606797749979",
      "assert sd_calc([1,2,3,4,5,6,7])==2.160246899469287",
      "assert sd_calc([5,9,10,15,6,4])==4.070217029430577"
    ]
  },
  {
    "mbpp_id": 718,
    "problem_statement": "Write a function to create a list taking alternate elements from another given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def alternate_elements(lst):\n    return [lst[i] for i in range(0, len(lst), 2)]",
    "test_cases": [
      "assert alternate_elements([\"red\", \"black\", \"white\", \"green\", \"orange\"])==['red', 'white', 'orange']",
      "assert alternate_elements([2, 0, 3, 4, 0, 2, 8, 3, 4, 2])==[2, 3, 0, 8, 4]",
      "assert alternate_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]"
    ]
  },
  {
    "mbpp_id": 719,
    "problem_statement": "Write a function that matches a string that has an a followed by zero or more b's.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def text_match(text):\n    if text.startswith('a') and text[1:].endswith('b*'):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "test_cases": [
      "assert text_match(\"ac\")==('Found a match!')",
      "assert text_match(\"dc\")==('Not matched!')",
      "assert text_match(\"abba\")==('Found a match!')"
    ]
  },
  {
    "mbpp_id": 720,
    "problem_statement": "Write a function to add a dictionary to the tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def add_dict_to_tuple(tup, new_item):\n    # Add the new item as a list of key-value pairs at the end of the tuple\n    updated_tup = list(tup) + [(new_item)]\n    return tuple(updated_tup)",
    "test_cases": [
      "assert add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3} ) == (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})",
      "assert add_dict_to_tuple((1, 2, 3), {\"UTS\" : 2, \"is\" : 3, \"Worst\" : 4} ) == (1, 2, 3, {'UTS': 2, 'is': 3, 'Worst': 4})",
      "assert add_dict_to_tuple((8, 9, 10), {\"POS\" : 3, \"is\" : 4, \"Okay\" : 5} ) == (8, 9, 10, {'POS': 3, 'is': 4, 'Okay': 5})"
    ]
  },
  {
    "mbpp_id": 721,
    "problem_statement": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: list index out of range"
    ],
    "generated_code": "from typing import List\nimport numpy as np\n\ndef max_average_of_path(matrix: List[List[int]], n: int) -> float:\n    # Calculate the sum of each row and column\n    sums_row = np.sum(matrix, axis=1)\n    sums_col = np.sum(matrix, axis=0)\n    \n    # Convert lists to arrays if necessary\n    sums_row = np.array(sums_row)\n    sums_col = np.array(sums_col)\n    \n    # Find the index of the maximum value in the diagonal formed by sums of rows and columns\n    idx_max_sum = np.argmax(np.diag(sums_row + sums_col))\n    \n    # Return the average of the element at the found index\n    return np.mean(matrix[idx_max_sum])\n\n# Test cases\nprint(max_average_of_path([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3))  # Expected output: 5.2\nprint(max_average_of_path([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3))  # Expected output: 6.2\nprint(max_average_of_path([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3))  # Expected output: 7.2",
    "test_cases": [
      "assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2",
      "assert maxAverageOfPath([[2, 3, 4], [7, 6, 5], [8, 4, 10]], 3) == 6.2",
      "assert maxAverageOfPath([[3, 4, 5], [8, 7, 6], [9, 5, 11]], 3) == 7.2 "
    ]
  },
  {
    "mbpp_id": 722,
    "problem_statement": "Write a function to filter the height and width of students which are stored in a dictionary.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def filter_data(student_dict, min_height, max_width):\n    filtered_students = {student: height for student, (height, _) in student_dict.items() if min_height <= height <= max_width}\n    return filtered_students",
    "test_cases": [
      "assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},6.0,70)=={'Cierra Vega': (6.2, 70)}",
      "assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},5.9,67)=={'Cierra Vega': (6.2, 70),'Kierra Gentry': (6.0, 68)}",
      "assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},5.7,64)=={'Cierra Vega': (6.2, 70),'Alden Cantrell': (5.9, 65),'Kierra Gentry': (6.0, 68),'Pierre Cox': (5.8, 66)}"
    ]
  },
  {
    "mbpp_id": 723,
    "problem_statement": "Write a function to count the same pair in two given lists using map function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\n\ndef count_same_pair(list_1: List[int], list_2: List[int]) -> int:\n    # Using map to apply lambda function and convert result to set to remove duplicates,\n    # then len of set gives us the count of pairs\n    return len(set(map(lambda x, y: x == y, list_1, list_2)))",
    "test_cases": [
      "assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4",
      "assert count_same_pair([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==11",
      "assert count_same_pair([2, 4, -6, -9, 11, -12, 14, -5, 17],[2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==1"
    ]
  },
  {
    "mbpp_id": 724,
    "problem_statement": "Write a function to calculate the sum of all digits of the base to the specified power.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def power_base_sum(base, power):\n    # Initialize total to 0\n    total = 0\n    \n    # Loop through each digit in the string representation of the number base^power\n    for digit in str(base**power):\n        # Convert the current character from string to integer and add it to total\n        total += int(digit)\n    \n    return total",
    "test_cases": [
      "assert power_base_sum(2,100)==115",
      "assert power_base_sum(8,10)==37",
      "assert power_base_sum(8,15)==62"
    ]
  },
  {
    "mbpp_id": 725,
    "problem_statement": "Write a function to extract values between quotation marks of the given string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef extract_quotation(input_string):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, input_string)\n    return matches",
    "test_cases": [
      "assert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']",
      "assert extract_quotation('Cast your \"favorite\" entertainment \"apps\"') == ['favorite', 'apps']",
      "assert extract_quotation('Watch content \"4k Ultra HD\" resolution with \"HDR 10\" Support') == ['4k Ultra HD', 'HDR 10']"
    ]
  },
  {
    "mbpp_id": 726,
    "problem_statement": "Write a function to multiply the adjacent elements of the given tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def multiply_elements(tup):\n    if len(tup) < 2:\n        raise ValueError(\"Tuple must contain at least two elements\")\n    \n    result = ()\n    for i in range(1, len(tup)):\n        result += ((tup[i-1] * tup[i]), )\n    \n    return result",
    "test_cases": [
      "assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)",
      "assert multiply_elements((2, 4, 5, 6, 7)) == (8, 20, 30, 42)",
      "assert multiply_elements((12, 13, 14, 9, 15)) == (156, 182, 126, 135)"
    ]
  },
  {
    "mbpp_id": 727,
    "problem_statement": "Write a function to remove all characters except letters and numbers using regex",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef remove_char(input_string):\n    # Remove special characters except for letters and numbers\n    cleaned_string = re.sub('[^a-zA-Z0-9]', '', input_string)\n    return cleaned_string",
    "test_cases": [
      "assert remove_char(\"123abcjw:, .@! eiw\") == '123abcjweiw'",
      "assert remove_char(\"Hello1234:, ! Howare33u\") == 'Hello1234Howare33u'",
      "assert remove_char(\"Cool543Triks@:, Make@987Trips\") == 'Cool543TriksMake987Trips' "
    ]
  },
  {
    "mbpp_id": 728,
    "problem_statement": "Write a function to sum elements in two lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'zip_longest' is not defined"
    ],
    "generated_code": "def sum_list(list1, list2):\n    # Use zip_longest to pair elements from both lists and calculate their sums.\n    return [a + b for a, b in zip_longest(list1, list2, fillvalue=0)]\n\n# Example usage:\nprint(sum_list([10,20,30],[15,25,35]))  # Output: [25, 45, 65]\nprint(sum_list([1,2,3],[5,6,7]))        # Output: [6, 8, 10]\nprint(sum_list([15,20,30],[15,45,75]))  # Output: [30, 65, 105]",
    "test_cases": [
      "assert sum_list([10,20,30],[15,25,35])==[25,45,65]",
      "assert sum_list([1,2,3],[5,6,7])==[6,8,10]",
      "assert sum_list([15,20,30],[15,45,75])==[30,65,105]"
    ]
  },
  {
    "mbpp_id": 729,
    "problem_statement": "Write a function to add two lists using map and lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List\n\ndef add_list(lst1: List[int], lst2: List[int]) -> List[int]:\n    \"\"\"\n    Adds corresponding elements of two lists using map and lambda.\n    \n    Args:\n    lst1: A list of integers.\n    lst2: Another list of integers.\n    \n    Returns:\n    A new list containing the element-wise sum of lst1 and lst2.\n    \"\"\"\n    return list(map(lambda x, y: x + y, lst1, lst2))",
    "test_cases": [
      "assert add_list([1, 2, 3],[4,5,6])==[5, 7, 9]",
      "assert add_list([1,2],[3,4])==[4,6]",
      "assert add_list([10,20],[50,70])==[60,90]"
    ]
  },
  {
    "mbpp_id": 730,
    "problem_statement": "Write a function to remove consecutive duplicates of a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def consecutive_duplicates(lst):\n    return [lst[i] for i in range(len(lst)) if i == 0 or lst[i] != lst[i-1]]",
    "test_cases": [
      "assert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4 ])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]",
      "assert consecutive_duplicates([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10])==[10, 15, 19, 18, 17, 26, 17, 18, 10]",
      "assert consecutive_duplicates(['a', 'a', 'b', 'c', 'd', 'd'])==['a', 'b', 'c', 'd']"
    ]
  },
  {
    "mbpp_id": 731,
    "problem_statement": "Write a function to find the lateral surface area of a cone.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef lateralsurface_cone(radius, height):\n    slant_height = math.sqrt(radius**2 + height**2)\n    return round(math.pi * radius * slant_height, 3)\n\n# Example test cases\nprint(lateralsurface_cone(5, 12)) # Expected output: 204.204\nprint(lateralsurface_cone(10, 15)) # Expected output: 566.359\nprint(lateralsurface_cone(19, 17)) # Expected output: 1521.809",
    "test_cases": [
      "assert lateralsurface_cone(5,12)==204.20352248333654",
      "assert lateralsurface_cone(10,15)==566.3586699569488",
      "assert lateralsurface_cone(19,17)==1521.8090132193388"
    ]
  },
  {
    "mbpp_id": 732,
    "problem_statement": "Write a function to replace all occurrences of spaces, commas, or dots with a colon.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def replace_specialchar(input_str):\n    return input_str.replace(' ', ':').replace(',', ':').replace('.', ':')\n\n\n# Test cases\nprint(replace_specialchar('Python language, Programming language.')) # Output: 'Python:language::Programming:language:'\nprint(replace_specialchar('a b c,d e f')) # Output: 'a:b:c:d:e:f'\nprint(replace_specialchar('ram reshma,ram rahim')) # Output: 'ram:reshma:ram:rahim'",
    "test_cases": [
      "assert replace_specialchar('Python language, Programming language.')==('Python:language::Programming:language:')",
      "assert replace_specialchar('a b c,d e f')==('a:b:c:d:e:f')",
      "assert replace_specialchar('ram reshma,ram rahim')==('ram:reshma:ram:rahim')"
    ]
  },
  {
    "mbpp_id": 733,
    "problem_statement": "Write a function to find the index of the first occurrence of a given number in a sorted array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_first_occurrence(arr, num):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == num and (mid == 0 or arr[mid-1] < num):\n            return mid\n        elif arr[mid] >= num:\n            right = mid - 1\n        else:\n            left = mid + 1\n            \n    return -1",
    "test_cases": [
      "assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1",
      "assert find_first_occurrence([2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 2",
      "assert find_first_occurrence([2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6) == 4"
    ]
  },
  {
    "mbpp_id": 734,
    "problem_statement": "Write a python function to find sum of products of all possible subarrays.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sum_Of_Subarray_Prod(nums, n):\n    result = []\n    \n    for i in range(len(nums)):\n        product = 1\n        for j in range(i, len(nums)):\n            product *= nums[j]\n            if product == n:\n                result.append(product)\n                \n    return sum(result)\n\n# Test Cases\nprint(sum_Of_Subarray_Prod([1,2,3], 3)) # Expected output: 20\nprint(sum_Of_Subarray_Prod([1,2], 2)) # Expected output: 5\nprint(sum_Of_Subarray_Prod([1,2,3,4], 4)) # Expected output: 84",
    "test_cases": [
      "assert sum_Of_Subarray_Prod([1,2,3],3) == 20",
      "assert sum_Of_Subarray_Prod([1,2],2) == 5",
      "assert sum_Of_Subarray_Prod([1,2,3,4],4) == 84"
    ]
  },
  {
    "mbpp_id": 735,
    "problem_statement": "Write a python function to toggle bits of the number except the first and the last bit.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def toggle_middle_bits(n):\n    # Shift n right by 2 places to get rid of the first and last bit\n    left_shifted = n >> 2\n    \n    # XOR with itself shifted by 2 to toggle middle bits\n    result = left_shifted ^ (left_shifted << 2)\n    \n    return result\n\n# Test cases\nprint(toggle_middle_bits(9))  # Expected output: 15\nprint(toggle_middle_bits(10)) # Expected output: 12\nprint(toggle_middle_bits(11)) # Expected output: 13",
    "test_cases": [
      "assert toggle_middle_bits(9) == 15",
      "assert toggle_middle_bits(10) == 12",
      "assert toggle_middle_bits(11) == 13"
    ]
  },
  {
    "mbpp_id": 736,
    "problem_statement": "Write a function to locate the left insertion point for a specified value in sorted order.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def left_insertion(sorted_list, target):\n    low = 0\n    high = len(sorted_list) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n            \n    return low\n\n# Test cases\nprint(left_insertion([1,2,4,5], 6)) # Expected output: 4\nprint(left_insertion([1,2,4,5], 3)) # Expected output: 2\nprint(left_insertion([1,2,4,5], 7)) # Expected output: 4",
    "test_cases": [
      "assert left_insertion([1,2,4,5],6)==4",
      "assert left_insertion([1,2,4,5],3)==2",
      "assert left_insertion([1,2,4,5],7)==4"
    ]
  },
  {
    "mbpp_id": 737,
    "problem_statement": "Write a function to check whether the given string is starting with a vowel or not using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef check_str(string):\n    pattern = r'^[aeiouAEIOU]'\n    if re.match(pattern, string):\n        return 'Valid'\n    else:\n        return 'Invalid'\n\n# Test cases\nprint(check_str(\"annie\"))  # Expected output: 'Valid'\nprint(check_str(\"dawood\"))  # Expected output: 'Invalid'\nprint(check_str(\"Else\"))   # Expected output: 'Valid'",
    "test_cases": [
      "assert check_str(\"annie\") == 'Valid'",
      "assert check_str(\"dawood\") == 'Invalid'",
      "assert check_str(\"Else\") == 'Valid'"
    ]
  },
  {
    "mbpp_id": 738,
    "problem_statement": "Write a function to calculate the geometric sum of n-1.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def geometric_sum(n):\n    \"\"\"\n    Calculate the geometric sum of n-1.\n    \n    Args:\n    n : int - The number indicating the sequence index starting from 1 up to n-1\n    \n    Returns:\n    float - The geometric sum of n-1\n    \"\"\"\n    if n == 1:\n        return 1.0\n    else:\n        return (1/((n**2)-(n+1)) * geometric_sum(n-1))\n\n# Test cases to verify the correctness of the solution\nprint(geometric_sum(7))  # Expected output: 1.9921875\nprint(geometric_sum(4))  # Expected output: 1.9375\nprint(geometric_sum(8))  # Expected output: 1.99609375",
    "test_cases": [
      "assert geometric_sum(7) == 1.9921875",
      "assert geometric_sum(4) == 1.9375",
      "assert geometric_sum(8) == 1.99609375"
    ]
  },
  {
    "mbpp_id": 739,
    "problem_statement": "Write a python function to find the index of smallest triangular number with n digits.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_Index(n):\n    # Initialize variables\n    i = 1\n    num = i * (i + 1) // 2\n    \n    while len(str(num)) != n:\n        i += 1\n        num = i * (i + 1) // 2\n        \n    return i - 1",
    "test_cases": [
      "assert find_Index(2) == 4",
      "assert find_Index(3) == 14",
      "assert find_Index(4) == 45"
    ]
  },
  {
    "mbpp_id": 740,
    "problem_statement": "Write a function to convert the given tuple to a key-value dictionary using adjacent elements.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def tuple_to_dict(tup):\n    dict_result = {}\n    for i in range(0, len(tup), 2):\n        if i + 1 < len(tup):  # Ensure we don't go out of bounds when creating keys\n            dict_result[tup[i]] = tup[i+1]\n    return dict_result\n\n# Test cases\nprint(tuple_to_dict((1, 5, 7, 10, 13, 5)))  # Expected output: {1: 5, 7: 10, 13: 5}\nprint(tuple_to_dict((1, 2, 3, 4, 5, 6)))   # Expected output: {1: 2, 3: 4, 5: 6}\nprint(tuple_to_dict((7, 8, 9, 10, 11, 12))) # Expected output: {7: 8, 9: 10, 11: 12}",
    "test_cases": [
      "assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}",
      "assert tuple_to_dict((1, 2, 3, 4, 5, 6)) == {1: 2, 3: 4, 5: 6}",
      "assert tuple_to_dict((7, 8, 9, 10, 11, 12)) == {7: 8, 9: 10, 11: 12}"
    ]
  },
  {
    "mbpp_id": 741,
    "problem_statement": "Write a python function to check whether all the characters are same or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def all_Characters_Same(s):\n    # Convert the string into a set to remove duplicate characters and then compare its length with the original string's length.\n    return len(set(list(s))) <= 1",
    "test_cases": [
      "assert all_Characters_Same(\"python\") == False",
      "assert all_Characters_Same(\"aaa\") == True",
      "assert all_Characters_Same(\"data\") == False"
    ]
  },
  {
    "mbpp_id": 742,
    "problem_statement": "Write a function to caluclate the area of a tetrahedron.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef area_tetrahedron(side_length):\n    # The formula for the surface area of a regular tetrahedron is (sqrt(3) * s^2) / 4,\n    # where 's' is the side length.\n    return (math.sqrt(3) * pow(side_length, 2)) / 4",
    "test_cases": [
      "assert area_tetrahedron(3)==15.588457268119894",
      "assert area_tetrahedron(20)==692.8203230275509",
      "assert area_tetrahedron(10)==173.20508075688772"
    ]
  },
  {
    "mbpp_id": 743,
    "problem_statement": "Write a function to rotate a given list by specified number of items to the right direction.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: list index out of range"
    ],
    "generated_code": "def rotate_right(lst, n, k):\n    \"\"\"\n    Rotate lst by n elements to the right.\n    \n    :param lst: List of integers.\n    :param n: Number of positions to rotate the list.\n    :param k: Number of elements in each rotation.\n    :return: The rotated list.\n    \"\"\"\n    return [lst[(i - 1) % len(lst) + (k * i)] for i in range(len(lst))]\n\n# Test Cases\nprint(rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, 4))  # Expected output: [8, 9, 10, 1, 2, 3, 4, 5]\nprint(rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2, 2))  # Expected output: [9, 10, 1, 2, 3, 4, 5, 6]\nprint(rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5, 2))  # Expected output: [6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8]",
    "test_cases": [
      "assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3,4)==[8, 9, 10, 1, 2, 3, 4, 5, 6]",
      "assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2,2)==[9, 10, 1, 2, 3, 4, 5, 6, 7, 8]",
      "assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],5,2)==[6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8]"
    ]
  },
  {
    "mbpp_id": 744,
    "problem_statement": "Write a function to check if the given tuple has any none value or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_none(input_tuple):\n    # Check if any element in the tuple is None\n    for item in input_tuple:\n        if item is None:\n            return True\n    return False\n\n# Test cases\nprint(check_none((10, 4, 5, 6, None)))  # Expected output: True\nprint(check_none((7, 8, 9, 11, 14)))   # Expected output: False\nprint(check_none((1, 2, 3, 4, None)))  # Expected output: True",
    "test_cases": [
      "assert check_none((10, 4, 5, 6, None)) == True",
      "assert check_none((7, 8, 9, 11, 14)) == False",
      "assert check_none((1, 2, 3, 4, None)) == True"
    ]
  },
  {
    "mbpp_id": 745,
    "problem_statement": "Write a function to find numbers within a given range where every number is divisible by every digit it contains.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def divisible_by_digits(start, end):\n    result = []\n    for num in range(start, end + 1):\n        if all(int(digit) != 0 and int(num) % int(digit) == 0 for digit in str(num)):\n            result.append(num)\n    return result",
    "test_cases": [
      "assert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]",
      "assert divisible_by_digits(1,15)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]",
      "assert divisible_by_digits(20,25)==[22, 24]"
    ]
  },
  {
    "mbpp_id": 746,
    "problem_statement": "Write a function to find area of a sector.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef sector_area(radius, angle_in_degrees):\n    \"\"\"\n    Calculate the area of a sector given its radius and central angle in degrees.\n    \n    Parameters:\n        radius (float): The radius of the circle.\n        angle_in_degrees (float): The central angle of the sector in degrees.\n        \n    Returns:\n        float: The area of the sector if valid input is provided, otherwise None.\n    \"\"\"\n    if angle_in_degrees == 360:\n        return math.pi * radius ** 2\n    elif angle_in_degrees > 0 and angle_in_degrees <= 360:\n        return 0.5 * math.pi * radius ** 2 * (angle_in_degrees / 360)\n    else:\n        return None",
    "test_cases": [
      "assert sector_area(4,45)==6.285714285714286",
      "assert sector_area(9,45)==31.82142857142857",
      "assert sector_area(9,360)==None"
    ]
  },
  {
    "mbpp_id": 747,
    "problem_statement": "Write a function to find the longest common subsequence for the given three string sequence.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def lcs_of_three(s1, s2, s3, n, m, p):\n    # Initialize a matrix with dimensions (n+1) x (m+1)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Fill the matrix from bottom right corner to top left corner\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            for k in range(p - 1, -1, -1):\n                if s1[i] == s2[j] and s1[i] == s3[k]:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j + 1] + 1)\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j])\n                    dp[i][j] = max(dp[i][j], dp[i][j + 1])\n\n    # Return the value at position (0, 0), which represents the length of LCS\n    return dp[0][0]",
    "test_cases": [
      "assert lcs_of_three('AGGT12', '12TXAYB', '12XBA', 6, 7, 5) == 2",
      "assert lcs_of_three('Reels', 'Reelsfor', 'ReelsforReels', 5, 8, 13) == 5 ",
      "assert lcs_of_three('abcd1e2', 'bc12ea', 'bd1ea', 7, 6, 5) == 3"
    ]
  },
  {
    "mbpp_id": 748,
    "problem_statement": "Write a function to put spaces between words starting with capital letters in a given string by using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'capital_words_spaces' is not defined",
      "Test 2: FAIL - name 'capital_words_spaces' is not defined",
      "Test 3: FAIL - name 'capital_words_spaces' is not defined"
    ],
    "generated_code": "import re\n\ndef capitalize_and_space(string_input):\n    # Use regular expression to find all words that start with a capital letter and replace them with space.\n    result_string = re.sub(r'\\b[A-Z][a-z]*', r' \\g<0>', string_input)\n    # Replace consecutive spaces with a single space.\n    final_result = re.sub(r' {2,}', ' ', result_string).strip()\n    return final_result\n\n# Test cases\nprint(capitalize_and_space(\"Python\"))   # Expected output: \"Python\"\nprint(capitalize_and_space(\"PythonProgrammingExamples\"))  # Expected output: \"Python Programming Examples\"\nprint(capitalize_and_space(\"GetReadyToBeCodingFreak\"))   # Expected output: \"Get Ready To Be Coding Freak\"",
    "test_cases": [
      "assert capital_words_spaces(\"Python\") == 'Python'",
      "assert capital_words_spaces(\"PythonProgrammingExamples\") == 'Python Programming Examples'",
      "assert capital_words_spaces(\"GetReadyToBeCodingFreak\") == 'Get Ready To Be Coding Freak'"
    ]
  },
  {
    "mbpp_id": 749,
    "problem_statement": "Write a function to sort a given list of strings of numbers numerically.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sort_numeric_strings(arr):\n    # Convert each string in the array to an integer and then convert them back to strings for comparison\n    return sorted([str(i) for i in arr])\n\n# Test cases\nprint(sort_numeric_strings(['4','12','45','7','0','100','200','-12','-500']))  # [-500, -12, 0, 4, 7, 12, 45, 100, 200]\nprint(sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2']))  # [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]\nprint(sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11']))  # [1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]",
    "test_cases": [
      "assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]",
      "assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]",
      "assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]"
    ]
  },
  {
    "mbpp_id": 750,
    "problem_statement": "Write a function to add the given tuple to the given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def add_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst",
    "test_cases": [
      "assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]",
      "assert add_tuple([6, 7, 8], (10, 11)) == [6, 7, 8, 10, 11]",
      "assert add_tuple([7, 8, 9], (11, 12)) == [7, 8, 9, 11, 12]"
    ]
  },
  {
    "mbpp_id": 751,
    "problem_statement": "Write a function to check if the given array represents min heap or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'math' is not defined"
    ],
    "generated_code": "def is_min_heap(arr, index=0):\n    \"\"\"\n    Check if the binary tree represented by arr[] with root at index 'index' \n    follows Min Heap property.\n    \n    :param arr: List of integers representing the binary tree in level order form.\n    :param index: Current node's index in the array representation.\n    :return: Boolean value indicating whether the binary tree is a valid Min Heap.\n    \"\"\"\n    n = len(arr)\n    size_of_subtree = 1 << (int)(math.log(n - index, 2))\n    subtree_end = index + size_of_subtree - 1\n    \n    # Check left child\n    if index * 2 + 1 <= subtree_end and arr[index] > arr[index * 2 + 1]:\n        return False\n    \n    # Check right child\n    if index * 2 + 2 <= subtree_end and arr[index] > arr[index * 2 + 2]:\n        return False\n    \n    # If all checks pass, it's a valid Min Heap\n    if (index * 2 + 1 <= subtree_end and arr[index] <= arr[index * 2 + 1]) and \\\n       (index * 2 + 2 <= subtree_end and arr[index] <= arr[index * 2 + 2]):\n        return True\n    else:\n        return False\n\n# Example usage:\narr1 = [1, 2, 3, 4, 5, 6]\nprint(is_min_heap(arr1))  # Expected output: True\n\narr2 = [2, 3, 4, 5, 10, 15]\nprint(is_min_heap(arr2))  # Expected output: True\n\narr3 = [2, 10, 4, 5, 3, 15]\nprint(is_min_heap(arr3))  # Expected output: False",
    "test_cases": [
      "assert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True",
      "assert check_min_heap([2, 3, 4, 5, 10, 15], 0) == True",
      "assert check_min_heap([2, 10, 4, 5, 3, 15], 0) == False"
    ]
  },
  {
    "mbpp_id": 752,
    "problem_statement": "Write a function to find the nth jacobsthal number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def jacobsthal_num(n):\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n    \n    :param n: The position in the sequence of Jacobsthal numbers to calculate.\n    :return: The nth Jacobsthal number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        def helper(k):\n            if k == 0:\n                return 0\n            elif k == 1:\n                return 1\n            else:\n                return helper(k-1) + 2 * helper(k-2)\n        \n        return helper(n)\n\n# Test cases\nprint(jacobsthal_num(5))  # Expected output: 11\nprint(jacobsthal_num(2))  # Expected output: 1\nprint(jacobsthal_num(4))  # Expected output: 5",
    "test_cases": [
      "assert jacobsthal_num(5) == 11",
      "assert jacobsthal_num(2) == 1",
      "assert jacobsthal_num(4) == 5"
    ]
  },
  {
    "mbpp_id": 753,
    "problem_statement": "Write a function to find minimum k records from tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_k(tuples_list, k):\n    # Sort the tuples based on the second element in descending order and take the first 'k' elements\n    sorted_tuples = sorted(tuples_list, key=lambda x: (-x[1], x[0]))\n    return sorted_tuples[:k]",
    "test_cases": [
      "assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]",
      "assert min_k([('Sanjeev', 11), ('Angat', 5), ('Akash', 3), ('Nepin', 9)], 3) == [('Akash', 3), ('Angat', 5), ('Nepin', 9)]",
      "assert min_k([('tanmay', 14), ('Amer', 11), ('Ayesha', 9), ('SKD', 16)], 1) == [('Ayesha', 9)]"
    ]
  },
  {
    "mbpp_id": 754,
    "problem_statement": "Write a function to find common index elements from three lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def extract_index_list(list_a, list_b, list_c):\n    # Find indices where all lists have matching values\n    return [i for i in range(len(list_a)) if list_a[i] == list_b[i] and list_b[i] == list_c[i]]",
    "test_cases": [
      "assert extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])==[1, 7]",
      "assert extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 6, 5],[0, 1, 2, 3, 4, 6, 7])==[1, 6]",
      "assert extract_index_list([1, 1, 3, 4, 6, 5, 6],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])==[1, 5]"
    ]
  },
  {
    "mbpp_id": 755,
    "problem_statement": "Write a function to find the second smallest number in a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def second_smallest(numbers):\n    \"\"\"\n    Find and return the second smallest unique element in a given list.\n    \n    :param numbers: List of integers.\n    :return: The second smallest unique integer, or None if it doesn't exist.\n    \"\"\"\n    unique_numbers = set(numbers)  # Remove duplicates and sort them\n    sorted_unique_numbers = sorted(unique_numbers)\n    \n    if len(sorted_unique_numbers) < 2:\n        return None\n    \n    return sorted_unique_numbers[1]\n\n# Test cases\nprint(second_smallest([1, 2, -8, -2, 0, -2])) == -2\nprint(second_smallest([1, 1, -0.5, 0, 2, -2, -2])) == -0.5\nprint(second_smallest([2, 2])) is None",
    "test_cases": [
      "assert second_smallest([1, 2, -8, -2, 0, -2])==-2",
      "assert second_smallest([1, 1, -0.5, 0, 2, -2, -2])==-0.5",
      "assert second_smallest([2,2])==None"
    ]
  },
  {
    "mbpp_id": 756,
    "problem_statement": "Write a function that matches a string that has an a followed by zero or one 'b'.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 're' is not defined",
      "Test 2: FAIL - name 're' is not defined",
      "Test 3: FAIL - name 're' is not defined"
    ],
    "generated_code": "def text_match_zero_one(text):\n    # Regular expression to match a string with an a followed by zero or one b\n    pattern = r'^a(b?)*$'\n    \n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'",
    "test_cases": [
      "assert text_match_zero_one(\"ac\")==('Found a match!')",
      "assert text_match_zero_one(\"dc\")==('Not matched!')",
      "assert text_match_zero_one(\"abbbba\")==('Found a match!')"
    ]
  },
  {
    "mbpp_id": 757,
    "problem_statement": "Write a function to count the pairs of reverse strings in the given string list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_reverse_pairs(lst):\n    # Create a dictionary to store reverse pairs for faster lookup\n    reverse_dict = {}\n    \n    # Populate the dictionary with reversed string pairs from the list\n    for word in lst:\n        if word[::-1] not in reverse_dict:\n            reverse_dict[word[::-1]] = []\n        reverse_dict[word[::-1]].append(word)\n    \n    # Count and sum up all occurrences of each reverse pair\n    total_count = 0\n    for value in reverse_dict.values():\n        if len(value) > 1:\n            total_count += len(value)\n    \n    return total_count\n\n# Test cases\nprint(count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]))  # Output: 2\nprint(count_reverse_pairs([\"geeks\", \"best\", \"for\", \"skeeg\"]))  # Output: 1\nprint(count_reverse_pairs([\"makes\", \"best\", \"sekam\", \"for\", \"rof\"]))  # Output: 2",
    "test_cases": [
      "assert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])== '2'",
      "assert count_reverse_pairs([\"geeks\", \"best\", \"for\", \"skeeg\"]) == '1'",
      "assert count_reverse_pairs([\"makes\", \"best\", \"sekam\", \"for\", \"rof\"]) == '2' "
    ]
  },
  {
    "mbpp_id": 758,
    "problem_statement": "Write a function to count number of unique lists within a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def unique_sublists(lst):\n    from collections import defaultdict\n    result = defaultdict(set)\n    for sublist in lst:\n        result[tuple(sublist)].add(len(sublist))\n    return {k: v.pop() for k, v in result.items()}",
    "test_cases": [
      "assert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]] )=={(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}",
      "assert unique_sublists([['green', 'orange'], ['black'], ['green', 'orange'], ['white']])=={('green', 'orange'): 2, ('black',): 1, ('white',): 1}",
      "assert unique_sublists([[10, 20, 30, 40], [60, 70, 50, 50], [90, 100, 200]])=={(10, 20, 30, 40): 1, (60, 70, 50, 50): 1, (90, 100, 200): 1}"
    ]
  },
  {
    "mbpp_id": 759,
    "problem_statement": "Write a function to check a decimal with a precision of 2.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef is_decimal(decimal_str):\n    \"\"\"\n    This function checks if the provided string represents a valid number with exactly two digits after the decimal point.\n    \n    Parameters:\n        - decimal_str (str): The string to be checked.\n        \n    Returns:\n        - bool: True if the string is a valid number with two decimal places, False otherwise.\n    \"\"\"\n    # Regular expression to match a string with up to three characters before and after the decimal point,\n    # but not more than two digits after the decimal point.\n    pattern = r'^\\d+(\\.\\d{1,2})?$'\n    \n    # Check if the string matches the pattern\n    return bool(re.match(pattern, decimal_str))",
    "test_cases": [
      "assert is_decimal('123.11')==True",
      "assert is_decimal('e666.86')==False",
      "assert is_decimal('3.124587')==False"
    ]
  },
  {
    "mbpp_id": 760,
    "problem_statement": "Write a python function to check whether an array contains only one distinct element or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def unique_Element(arr, n):\n    # Convert the list to a set and compare its length with the original list's length.\n    if len(set(arr)) == n:\n        return 'YES'\n    else:\n        return 'NO'",
    "test_cases": [
      "assert unique_Element([1,1,1],3) == 'YES'",
      "assert unique_Element([1,2,1,2],4) == 'NO'",
      "assert unique_Element([1,2,3,4,5],5) == 'NO'"
    ]
  },
  {
    "mbpp_id": 761,
    "problem_statement": "Write a function to caluclate arc length of an angle.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'radius' is not defined. Did you mean: 'radian'?"
    ],
    "generated_code": "import math\n\ndef arc_length(angle, degree):\n    if degree == 360:\n        return None\n    else:\n        # Calculate the arc length based on radians\n        radian = math.radians(angle)\n        arc_len = radius * radian\n        return round(arc_len, 10)\n\n# Test the function with provided data points\nprint(arc_length(9, 45))   # Expected output: 3.535714285714285\nprint(arc_length(9, 480))  # Expected output: None\nprint(arc_length(5, 270))  # Expected output: 11.785714285714285",
    "test_cases": [
      "assert arc_length(9,45)==3.5357142857142856",
      "assert arc_length(9,480)==None",
      "assert arc_length(5,270)==11.785714285714285"
    ]
  },
  {
    "mbpp_id": 762,
    "problem_statement": "Write a function to check whether the given month number contains 30 days or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_monthnumber_number(month_number):\n    # Months with 30 days are February and June.\n    if month_number == 2:\n        return True\n    elif month_number in [4, 6, 9, 11]:\n        return True\n    else:\n        return False",
    "test_cases": [
      "assert check_monthnumber_number(6)==True",
      "assert check_monthnumber_number(2)==False",
      "assert check_monthnumber_number(12)==False"
    ]
  },
  {
    "mbpp_id": 763,
    "problem_statement": "Write a python function to find the minimum difference between any two elements in a given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - 'tuple' object has no attribute 'sort'",
      "Test 2: FAIL - 'tuple' object has no attribute 'sort'",
      "Test 3: FAIL - 'tuple' object has no attribute 'sort'"
    ],
    "generated_code": "def find_Min_Diff(arr, k):\n    arr.sort()\n    min_diff = float('inf')\n    \n    for i in range(len(arr) - 1):\n        diff = abs(arr[i] - arr[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff",
    "test_cases": [
      "assert find_Min_Diff((1,5,3,19,18,25),6) == 1",
      "assert find_Min_Diff((4,3,2,6),4) == 1",
      "assert find_Min_Diff((30,5,20,9),4) == 4"
    ]
  },
  {
    "mbpp_id": 764,
    "problem_statement": "Write a python function to count numeric values in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 're' is not defined",
      "Test 2: FAIL - name 're' is not defined",
      "Test 3: FAIL - name 're' is not defined"
    ],
    "generated_code": "def number_ctr(input_string):\n    # Count the occurrences of digits in the input string\n    return len(re.findall(r'\\d', input_string))",
    "test_cases": [
      "assert number_ctr('program2bedone') == 1",
      "assert number_ctr('3wonders') ==1",
      "assert number_ctr('123') == 3"
    ]
  },
  {
    "mbpp_id": 765,
    "problem_statement": "Write a function to find nth polite number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def is_polite(nth):\n    \"\"\"\n    Finds the nth polite number.\n    \n    A polite number is a positive integer that can be written as the sum of two or more consecutive positive integers.\n    \n    :param nth: The ordinal position of the polite number to find.\n    :return: The nth polite number.\n    \"\"\"\n    count = 0\n    num = 2\n    while True:\n        if all(num - x > 0 for x in range(1, num)):\n            count += 1\n            if count == nth:\n                return num\n        num += 1",
    "test_cases": [
      "assert is_polite(7) == 11",
      "assert is_polite(4) == 7",
      "assert is_polite(9) == 13"
    ]
  },
  {
    "mbpp_id": 766,
    "problem_statement": "Write a function to iterate over all pairs of consecutive items in a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))\n\n# Test cases\nprint(pair_wise([1,1,2,3,3,4,4,5]))  # [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\nprint(pair_wise([1,5,7,9,10]))      # [(1, 5), (5, 7), (7, 9), (9, 10)]\nprint(pair_wise([1,2,3,4,5,6,7,8,9,10]))  # [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]",
    "test_cases": [
      "assert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]",
      "assert pair_wise([1,5,7,9,10])==[(1, 5), (5, 7), (7, 9), (9, 10)]",
      "assert pair_wise([1,2,3,4,5,6,7,8,9,10])==[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]"
    ]
  },
  {
    "mbpp_id": 767,
    "problem_statement": "Write a python function to count the number of pairs whose sum is equal to ‘sum’.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import Counter\n\ndef get_Pairs_Count(arr, sum_value, target_sum):\n    \"\"\"\n    Counts the number of unique pairs in an array where the sum of each pair equals to 'target_sum'.\n    \n    :param arr: List[int] - The input list of integers.\n    :param sum_value: int - The target value for the sum of pairs.\n    :param target_sum: int - The desired sum of each pair.\n    :return: int - The total count of unique pairs with sum equal to 'target_sum'.\n    \"\"\"\n    # Count occurrences of each element in the array\n    counts = Counter(arr)\n    # Initialize result counter\n    count_pairs = 0\n    \n    # Check for each possible element if there exists another element such that their sum equals to 'target_sum'\n    for num in counts:\n        complement = target_sum - num\n        if complement in counts and counts[complement] > 0:\n            count_pairs += min(counts[num], counts[complement])\n            # If the same element can be part of multiple pairs, reduce its count in both sets\n            counts[num] -= 1\n            counts[complement] -= 1\n    \n    return count_pairs\n\n# Example checks (not part of the solution submission)\nprint(get_Pairs_Count([1,1,1,1], 4, 2))  # Expected output: 6\nprint(get_Pairs_Count([1,5,7,-1,5], 5, 6))  # Expected output: 3\nprint(get_Pairs_Count([1,-2,3], 3, 1))  # Expected output: 1",
    "test_cases": [
      "assert get_Pairs_Count([1,1,1,1],4,2) == 6",
      "assert get_Pairs_Count([1,5,7,-1,5],5,6) == 3",
      "assert get_Pairs_Count([1,-2,3],3,1) == 1"
    ]
  },
  {
    "mbpp_id": 768,
    "problem_statement": "Write a python function to check for odd parity of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_Odd_Parity(n):\n    # Initialize sum as 0\n    total = 0\n    \n    # Loop through each digit in n\n    while n != 0:\n        # Extract the last digit and add it to total\n        total += n % 10\n        \n        # Remove the last digit from n\n        n //= 10\n    \n    # If total is even, then there's an even number of odd digits; otherwise, there's an odd number of odd digits\n    return total % 2 == 1",
    "test_cases": [
      "assert check_Odd_Parity(13) == True",
      "assert check_Odd_Parity(21) == True",
      "assert check_Odd_Parity(18) == False"
    ]
  },
  {
    "mbpp_id": 769,
    "problem_statement": "Write a python function to get the difference between two lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def Diff(list_a, list_b):\n    diff_list = []\n    for item in list_a:\n        if item not in list_b:\n            diff_list.append(item)\n    for item in list_b:\n        if item not in list_a:\n            diff_list.append(item)\n    return diff_list",
    "test_cases": [
      "assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]",
      "assert (Diff([1,2,3,4,5], [6,7,1])) == [2,3,4,5,6,7]",
      "assert (Diff([1,2,3], [6,7,1])) == [2,3,6,7]"
    ]
  },
  {
    "mbpp_id": 770,
    "problem_statement": "Write a python function to find the sum of fourth power of first n odd natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def odd_Num_Sum(n):\n    # Initialize sum with 0\n    total_sum = 0\n    \n    # Loop through the first n odd numbers and calculate their fourth powers\n    for i in range(1, n + 1, 2):\n        total_sum += i ** 4\n    \n    return total_sum",
    "test_cases": [
      "assert odd_Num_Sum(2) == 82",
      "assert odd_Num_Sum(3) == 707",
      "assert odd_Num_Sum(4) == 3108"
    ]
  },
  {
    "mbpp_id": 771,
    "problem_statement": "Write a function to check if the given expression is balanced or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - SyntaxError: unmatched ')'"
    ],
    "generated_code": "def check_expression(expression):\n    \"\"\"\n    Check if the given expression is balanced.\n    \n    Args:\n        expression (str): The string containing the expression to be checked.\n        \n    Returns:\n        bool: True if the expression is balanced, False otherwise.\n    \"\"\"\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            # Ignore non-parentheses and non-brackets characters\n            continue\n    \n    return len(stack) == 0\n\n# Test cases\nprint(check_expression(\"{()}[{}]\"))  # Expected output: True\nprint(check_expression(\"{()}[{]\"))   # Expected output: False\nprint(check_expression(\"{()}[{}][]({}\")))  # Expected output: True",
    "test_cases": [
      "assert check_expression(\"{()}[{}]\") == True",
      "assert check_expression(\"{()}[{]\") == False",
      "assert check_expression(\"{()}[{}][]({})\") == True"
    ]
  },
  {
    "mbpp_id": 772,
    "problem_statement": "Write a function to remove all the words with k length in the given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_length(text, k):\n    # Split the text into words and filter out those longer than k characters\n    filtered_words = [word for word in text.split() if len(word) == k]\n    # Join the filtered words back into a single string\n    result = ' '.join(filtered_words)\n    return result\n\n# Test cases\nprint(remove_length('The person is most valuable', 3))  # Expected output: \"person is most val\"\nprint(remove_length('If you told me about this okay', 4))  # Expected output: \"If you me about ok\"\nprint(remove_length('Forces of darkness is coming into the play', 4))  # Expected output: \"Forces of darkness is the\"",
    "test_cases": [
      "assert remove_length('The person is most value tet', 3) == 'person is most value'",
      "assert remove_length('If you told me about this ok', 4) == 'If you me about ok'",
      "assert remove_length('Forces of darkeness is come into the play', 4) == 'Forces of darkeness is the'"
    ]
  },
  {
    "mbpp_id": 773,
    "problem_statement": "Write a function to find the occurrence and position of the substrings within a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 're' is not defined"
    ],
    "generated_code": "def occurance_substring(s, t):\n    # Find all start positions of each substring in s\n    pos = [m.start() for m in re.finditer(t, s)]\n    return tuple((t, i, i + len(t) - 1) for i in pos)\n\n# Test cases\nprint(occurance_substring('python programming, python language', 'python'))\nprint(occurance_substring('python programming,programming language', 'programming'))\nprint(occurance_substring('python programming,programming language', 'language'))",
    "test_cases": [
      "assert occurance_substring('python programming, python language','python')==('python', 0, 6)",
      "assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18)",
      "assert occurance_substring('python programming,programming language','language')==('language', 31, 39)"
    ]
  },
  {
    "mbpp_id": 774,
    "problem_statement": "Write a function to check if the string is a valid email address or not using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef check_email(email):\n    # Regular expression for validating an Email\n    regex = r'^[a-z0-9]+[\\._]?[a-z0-9]+[@]\\w+[.]\\w{2,3}$'\n    \n    # Compile the ReGex\n    pattern = re.compile(regex)\n    \n    # If the string is empty\n    if email == None:\n        return 'Invalid Email'\n    \n    # Matching the regex to the email\n    if pattern.match(email):\n        return 'Valid Email'\n    else:\n        return 'Invalid Email'\n\n# Test Cases\nprint(check_email(\"ankitrai326@gmail.com\"))  # Expected output: \"Valid Email\"\nprint(check_email(\"my.ownsite@ourearth.org\"))  # Expected output: \"Valid Email\"\nprint(check_email(\"ankitaoie326.com\"))  # Expected output: \"Invalid Email\"",
    "test_cases": [
      "assert check_email(\"ankitrai326@gmail.com\") == 'Valid Email'",
      "assert check_email(\"my.ownsite@ourearth.org\") == 'Valid Email'",
      "assert check_email(\"ankitaoie326.com\") == 'Invalid Email'"
    ]
  },
  {
    "mbpp_id": 775,
    "problem_statement": "Write a python function to check whether every odd index contains odd numbers of a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def odd_position(arr):\n    for i in range(1, len(arr), 2):  # Start from index 1 and step by 2 to get all odd indices\n        if arr[i] % 2 == 0:\n            return False\n    return True",
    "test_cases": [
      "assert odd_position([2,1,4,3,6,7,6,3]) == True",
      "assert odd_position([4,1,2]) == True",
      "assert odd_position([1,2,3]) == False"
    ]
  },
  {
    "mbpp_id": 776,
    "problem_statement": "Write a function to count those characters which have vowels as their neighbors in the given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'vowel' is not defined"
    ],
    "generated_code": "def count_vowels(s):\n    \"\"\"\n    Counts the number of characters in the string s whose neighboring characters are vowels.\n    \n    Parameters:\n    - s (str): The input string for which we want to find how many of its characters have vowels as their neighbors.\n    \n    Returns:\n    int: The count of characters with vowels as their neighbors.\n    \"\"\"\n    vowel_neighbors = {'a', 'e', 'i', 'o', 'u'}\n    count = sum(1 for char in s if all(vowel not in s[i-1:i+2] for i in range(len(s)) if i > 0 and i < len(s) - 1))\n    return count\n\nprint(count_vowels('bestinstareels')) # Expected output: 7\nprint(count_vowels('partofthejourneyistheend')) # Expected output: 12\nprint(count_vowels('amazonprime')) # Expected output: 5",
    "test_cases": [
      "assert count_vowels('bestinstareels') == 7",
      "assert count_vowels('partofthejourneyistheend') == 12",
      "assert count_vowels('amazonprime') == 5"
    ]
  },
  {
    "mbpp_id": 777,
    "problem_statement": "Write a python function to find the sum of non-repeated elements in a given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_Sum(arr, target_sum):\n    \"\"\"\n    Finds and returns the sum of all unique (non-repeating) numbers from an array.\n    \n    Parameters:\n        arr (list): The input list containing integers.\n        target_sum (int): The target sum for finding the non-repeating elements.\n        \n    Returns:\n        int: The sum of all unique (non-repeating) elements in the array that equals the target_sum.\n    \"\"\"\n    # Count occurrences of each number in the array\n    count = {}\n    for num in arr:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n    \n    # Calculate the sum of unique elements meeting the target_sum criteria\n    total_sum = 0\n    for key, value in count.items():\n        if key == target_sum - key:\n            total_sum += key * value\n            \n    return total_sum\n\n# Test Cases\nprint(find_Sum([1,2,3,1,1,4,5,6],8))  # Expected output: 21\nprint(find_Sum([1,10,9,4,2,10,10,45,4],9))  # Expected output: 71\nprint(find_Sum([12,10,9,45,2,10,10,45,10],9))  # Expected output: 78",
    "test_cases": [
      "assert find_Sum([1,2,3,1,1,4,5,6],8) == 21",
      "assert find_Sum([1,10,9,4,2,10,10,45,4],9) == 71",
      "assert find_Sum([12,10,9,45,2,10,10,45,10],9) == 78"
    ]
  },
  {
    "mbpp_id": 778,
    "problem_statement": "Write a function to pack consecutive duplicates of a given list elements into sublists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def pack_consecutive_duplicates(lst):\n    result = []\n    i = 0\n    while i < len(lst):\n        count = 1\n        while i + 1 < len(lst) and lst[i] == lst[i + 1]:\n            i += 1\n            count += 1\n        if count > 1:\n            result.append(lst[i:i + count])\n        else:\n            result.append([lst[i]])\n        i += 1\n    return result\n\n# Test cases\nprint(pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]))\nprint(pack_consecutive_duplicates([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]))\nprint(pack_consecutive_duplicates(['a', 'a', 'b', 'c', 'd', 'd']))",
    "test_cases": [
      "assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])==[[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]",
      "assert pack_consecutive_duplicates([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10])==[[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]",
      "assert pack_consecutive_duplicates(['a', 'a', 'b', 'c', 'd', 'd'])==[['a', 'a'], ['b'], ['c'], ['d', 'd']]"
    ]
  },
  {
    "mbpp_id": 779,
    "problem_statement": "Write a function to count the number of unique lists within a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: unhashable type: 'list'"
    ],
    "generated_code": "from typing import *\nfrom collections import defaultdict\nimport functools\n\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int], int]:\n    \"\"\"\n    Counts and returns the frequency of each unique sublist in the given list.\n    \n    Args:\n    lst (List[List[int]]): A list containing sublists as its elements.\n    \n    Returns:\n    Dict[Tuple[int], int]: A dictionary where keys are tuples representing unique sublists,\n                           and values are the counts of how many times each tuple appears in the input list.\n    \"\"\"\n    return functools.reduce(lambda acc, x: {**acc, **({tuple(sorted(x)): 1} if sorted(tuple(x)) not in acc else {})}, lst, defaultdict(int))\n\n# Test cases\nprint(unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]))\nprint(unique_sublists([['green', 'orange'], ['black'], ['green', 'orange'], ['white']]))\nprint(unique_sublists([[1, 2], [3, 4], [4, 5], [6, 7]]))",
    "test_cases": [
      "assert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])=={(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}",
      "assert unique_sublists([['green', 'orange'], ['black'], ['green', 'orange'], ['white']])=={('green', 'orange'): 2, ('black',): 1, ('white',): 1}",
      "assert unique_sublists([[1, 2], [3, 4], [4, 5], [6, 7]])=={(1, 2): 1, (3, 4): 1, (4, 5): 1, (6, 7): 1}"
    ]
  },
  {
    "mbpp_id": 780,
    "problem_statement": "Write a function to find the combinations of sums with tuples in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: unsupported operand type(s) for -: 'tuple' and 'tuple'"
    ],
    "generated_code": "def find_combinations(tuples_list):\n    result = []\n    for i in range(len(tuples_list)):\n        for j in range(i + 1, len(tuples_list)):\n            combination = sorted([tuples_list[i], tuples_list[j]])\n            if all(x not in tuples_list for x in [combination[0] - y for y in combination]):\n                result.append(combination)\n    return result\n\n# Test cases\nprint(find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)])) # Should return [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\nprint(find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)])) # Should return [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]\nprint(find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)])) # Should return [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]",
    "test_cases": [
      "assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]",
      "assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]",
      "assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]"
    ]
  },
  {
    "mbpp_id": 781,
    "problem_statement": "Write a python function to check whether the count of divisors is even or odd.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_Divisors(n):\n    # Initialize count to zero\n    count = 0\n    \n    # Iterate through all numbers from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n            \n    # Check if count is even or odd and return the result\n    if count % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n\n# Test cases\nprint(count_Divisors(10))  # Expected output: Even\nprint(count_Divisors(100)) # Expected output: Odd\nprint(count_Divisors(125)) # Expected output: Even",
    "test_cases": [
      "assert count_Divisors(10) == \"Even\"",
      "assert count_Divisors(100) == \"Odd\"",
      "assert count_Divisors(125) == \"Even\""
    ]
  },
  {
    "mbpp_id": 782,
    "problem_statement": "Write a python function to find the sum of all odd length subarrays.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def Odd_Length_Sum(arr):\n    total_sum = 0\n    n = len(arr)\n    \n    # Iterate over each possible starting point for an odd-length subarray\n    for i in range(n):\n        current_sum = 0\n        \n        # Add up elements from start to end considering every other element\n        for j in range(i, min(n, i + 2 * n) - 1, 2):\n            current_sum += arr[j]\n        \n        # Add current sum to the total sum if it's odd\n        if current_sum % 2 != 0:\n            total_sum += current_sum\n    \n    return total_sum\n\n# Test cases\nprint(Odd_Length_Sum([1,2,4]))  # Expected output: 14\nprint(Odd_Length_Sum([1,2,1,2]))  # Expected output: 15\nprint(Odd_Length_Sum([1,7]))  # Expected output: 8",
    "test_cases": [
      "assert Odd_Length_Sum([1,2,4]) == 14",
      "assert Odd_Length_Sum([1,2,1,2]) == 15",
      "assert Odd_Length_Sum([1,7]) == 8"
    ]
  },
  {
    "mbpp_id": 783,
    "problem_statement": "Write a function to convert rgb color to hsv color.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def rgb_to_hsv(r, g, b):\n    r /= 255\n    g /= 255\n    b /= 255\n    \n    max_color = max(r, g, b)\n    min_color = min(r, g, b)\n    \n    delta = max_color - min_color\n    \n    if max_color == min_color:\n        h = 0\n    elif max_color == r:\n        h = (60 * ((g - b) / delta) + 360) % 360\n    elif max_color == g:\n        h = (60 * ((b - r) / delta) + 120) % 360\n    else:\n        h = (60 * ((r - g) / delta) + 240) % 360\n    \n    if max_color == 0:\n        s = 0\n    else:\n        s = (delta / max_color) * 100\n    \n    v = max_color * 100\n    \n    return round(h), round(s), round(v)\n\n# Test cases\nprint(rgb_to_hsv(255, 255, 255)) # Expected output: (0, 0.0, 100.0)\nprint(rgb_to_hsv(0, 215, 0))     # Expected output: (120.0, 100.0, 84.31372549019608)\nprint(rgb_to_hsv(10, 215, 110))  # Expected output: (149.26829268292684, 95.34883720930233, 84.31372549019608)",
    "test_cases": [
      "assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0)",
      "assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608)",
      "assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608)"
    ]
  },
  {
    "mbpp_id": 784,
    "problem_statement": "Write a function to find the product of first even and odd number of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - AttributeError: 'list' object has no attribute 'sum'"
    ],
    "generated_code": "def mul_even_odd(lst):\n    # Calculate sum of elements at even indices multiplied with those at odd indices.\n    return lst[::2].sum() * lst[1::2].sum()\n\n# Test cases to verify the correctness of the function\nassert mul_even_odd([1,3,5,7,4,1,6,8]) == 4\nassert mul_even_odd([1,2,3,4,5,6,7,8,9,10]) == 2\nassert mul_even_odd([1,5,7,9,10]) == 10\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert mul_even_odd([1,3,5,7,4,1,6,8])==4",
      "assert mul_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
      "assert mul_even_odd([1,5,7,9,10])==10"
    ]
  },
  {
    "mbpp_id": 785,
    "problem_statement": "Write a function to convert tuple string to integer tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: invalid literal for int() with base 10: '(7'"
    ],
    "generated_code": "def tuple_str_int(tuple_str):\n    \"\"\"\n    Converts a tuple of comma-separated integers into an actual tuple of integers.\n    \n    Args:\n    tuple_str (str): A string representing a tuple of comma-separated integers.\n    \n    Returns:\n    tuple: A tuple containing the integers from the input string.\n    \"\"\"\n    # Split the string by commas and strip whitespace, then convert each element to int\n    return tuple(map(int, tuple_str.split(',')))\n\n# Check function with provided data points\nprint(tuple_str_int(\"(7, 8, 9)\"))  # Expected output: (7, 8, 9)\nprint(tuple_str_int(\"(1, 2, 3)\"))  # Expected output: (1, 2, 3)\nprint(tuple_str_int(\"(4, 5, 6)\"))  # Expected output: (4, 5, 6)",
    "test_cases": [
      "assert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)",
      "assert tuple_str_int(\"(1, 2, 3)\") == (1, 2, 3)",
      "assert tuple_str_int(\"(4, 5, 6)\") == (4, 5, 6)"
    ]
  },
  {
    "mbpp_id": 786,
    "problem_statement": "Write a function to locate the right insertion point for a specified value in sorted order.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def right_insertion(sorted_list, target):\n    left, right = 0, len(sorted_list)\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if sorted_list[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left",
    "test_cases": [
      "assert right_insertion([1,2,4,5],6)==4",
      "assert right_insertion([1,2,4,5],3)==2",
      "assert right_insertion([1,2,4,5],7)==4"
    ]
  },
  {
    "mbpp_id": 787,
    "problem_statement": "Write a function that matches a string that has an a followed by three 'b'.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def text_match_three(text):\n    if text[0] == 'a' and text[1:] == 'bbb':\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n# Test cases\nprint(text_match_three(\"ac\"))   # Should print: Not matched!\nprint(text_match_three(\"dc\"))   # Should print: Not matched!\nprint(text_match_three(\"abbbba\"))  # Should print: Found a match!",
    "test_cases": [
      "assert text_match_three(\"ac\")==('Not matched!')",
      "assert text_match_three(\"dc\")==('Not matched!')",
      "assert text_match_three(\"abbbba\")==('Found a match!')"
    ]
  },
  {
    "mbpp_id": 788,
    "problem_statement": "Write a function to create a new tuple from the given string and list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def new_tuple(str_list, input_str):\n    # Convert each item in str_list into a tuple and join them with the input_str\n    result = tuple(item for sublist in str_list for item in sublist) + tuple(input_str)\n    return result",
    "test_cases": [
      "assert new_tuple([\"WEB\", \"is\"], \"best\") == ('WEB', 'is', 'best')",
      "assert new_tuple([\"We\", \"are\"], \"Developers\") == ('We', 'are', 'Developers')",
      "assert new_tuple([\"Part\", \"is\"], \"Wrong\") == ('Part', 'is', 'Wrong')"
    ]
  },
  {
    "mbpp_id": 789,
    "problem_statement": "Write a function to calculate the perimeter of a regular polygon.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def perimeter_polygon(n, s):\n    return n * s",
    "test_cases": [
      "assert perimeter_polygon(4,20)==80",
      "assert perimeter_polygon(10,15)==150",
      "assert perimeter_polygon(9,7)==63"
    ]
  },
  {
    "mbpp_id": 790,
    "problem_statement": "Write a python function to check whether every even index contains even numbers of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'even_position' is not defined"
    ],
    "generated_code": "def is_even_position_even(lst):\n    \"\"\"\n    Check if every element at an even index in the list 'lst' has an even number.\n    \n    Args:\n        lst (list): A list of integers.\n        \n    Returns:\n        bool: True if all elements at even indices have even numbers, False otherwise.\n    \"\"\"\n    for i in range(0, len(lst), 2):  # Iterate through odd indices (even positions)\n        if lst[i] % 2 != 0:  # Check if it's not divisible by 2 (odd number)\n            return False\n    return True\n\n# Test Cases\nassert even_position([3, 2, 1]) == False\nassert even_position([1, 2, 3]) == False\nassert even_position([2, 1, 4]) == True",
    "test_cases": [
      "assert even_position([3,2,1]) == False",
      "assert even_position([1,2,3]) == False",
      "assert even_position([2,1,4]) == True"
    ]
  },
  {
    "mbpp_id": 791,
    "problem_statement": "Write a function to remove the nested record from the given tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_nested(test_tuple):\n    # Convert the tuple into a list for easier modification\n    test_list = list(test_tuple)\n    # Iterate through the list and check each element if it is another tuple\n    while True:\n        try:\n            # Try removing the first occurrence of a tuple starting at index 1\n            test_list.pop(1)\n            # If successful, convert the modified list back to a tuple\n            result = tuple(test_list)\n            break\n        except IndexError:\n            # If an IndexError occurs during conversion, there were no tuples in the original tuple\n            break\n    return result",
    "test_cases": [
      "assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)",
      "assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11)",
      "assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12)"
    ]
  },
  {
    "mbpp_id": 792,
    "problem_statement": "Write a python function to count the number of lists in a given number of lists.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_list(lists):\n    \"\"\"\n    Count the total number of lists within the given list of lists.\n    \n    Args:\n    lists (list): A list containing other lists as elements.\n    \n    Returns:\n    int: The total number of lists inside the provided list of lists.\n    \"\"\"\n    return len(lists)\n\n# Check function with provided data points\nassert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\nassert count_list([[1,2],[2,3],[4,5]]) == 3\nassert count_list([[1,0],[2,0]]) == 2\n\nprint(\"All tests passed!\")",
    "test_cases": [
      "assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4",
      "assert count_list([[1,2],[2,3],[4,5]]) == 3",
      "assert count_list([[1,0],[2,0]]) == 2"
    ]
  },
  {
    "mbpp_id": 793,
    "problem_statement": "Write a python function to find the last position of an element in a sorted array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def last(arr, key, n):\n    low = 0\n    high = n - 1\n    \n    while low <= high:\n        mid = low + ((high - low) // 2)\n        \n        if arr[mid] == key and (mid == n - 1 or arr[mid + 1] != key):\n            return mid\n        \n        elif arr[mid] < key:\n            low = mid + 1\n            \n        else:\n            high = mid - 1\n            \n    return -1",
    "test_cases": [
      "assert last([1,2,3],1,3) == 0",
      "assert last([1,1,1,2,3,4],1,6) == 2",
      "assert last([2,3,2,3,6,8,9],3,8) == 3"
    ]
  },
  {
    "mbpp_id": 794,
    "problem_statement": "Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'text_starta_endb' is not defined",
      "Test 2: FAIL - name 'text_starta_endb' is not defined",
      "Test 3: FAIL - name 'text_starta_endb' is not defined"
    ],
    "generated_code": "import re\n\ndef find_a_match(text):\n    # Regular expression pattern to match a string starting with 'a', followed by any character(s), and ending with 'b'\n    pattern = r'^a.*b$'\n    \n    # Search for the pattern in the given text\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n# Test cases\nprint(find_a_match(\"aabbbb\"))       # Should print: Found a match!\nprint(find_a_match(\"aabAbbbc\"))     # Should print: Not matched!\nprint(find_a_match(\"accddbbjjj\"))   # Should print: Not matched!",
    "test_cases": [
      "assert text_starta_endb(\"aabbbb\")==('Found a match!')",
      "assert text_starta_endb(\"aabAbbbc\")==('Not matched!')",
      "assert text_starta_endb(\"accddbbjjj\")==('Not matched!')"
    ]
  },
  {
    "mbpp_id": 795,
    "problem_statement": "Write a function to find the n - cheap price items from a given dataset using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from heapq import nlargest\nimport json\n\ndef cheap_items(items_list, n):\n    # Convert each item in list into JSON string for sorting\n    converted_items = [json.dumps(item) for item in items_list]\n    \n    # Use nlargest to get the first n smallest values based on 'price'\n    result = nlargest(n, converted_items, key=lambda x: float(json.loads(x)['price']))\n    \n    # Convert back from strings to dictionaries and return the results\n    return [json.loads(result[i]) for i in range(len(result))]\n\n# Test cases\nprint(cheap_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}], 1))\nprint(cheap_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}], 2))\nprint(cheap_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09},{'name': 'Item-4', 'price': 22.75}], 1))",
    "test_cases": [
      "assert cheap_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)==[{'name': 'Item-1', 'price': 101.1}]",
      "assert cheap_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],2)==[{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}]",
      "assert cheap_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09},{'name': 'Item-4', 'price': 22.75}],1)==[{'name': 'Item-4', 'price': 22.75}]"
    ]
  },
  {
    "mbpp_id": 796,
    "problem_statement": "Write function to find the sum of all items in the given dictionary.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def return_sum(dictionary):\n    # Calculate and return the sum of values in the dictionary\n    total = sum(dictionary.values())\n    return total",
    "test_cases": [
      "assert return_sum({'a': 100, 'b':200, 'c':300}) == 600",
      "assert return_sum({'a': 25, 'b':18, 'c':45}) == 88",
      "assert return_sum({'a': 36, 'b':39, 'c':49}) == 124"
    ]
  },
  {
    "mbpp_id": 797,
    "problem_statement": "Write a python function to find the sum of all odd natural numbers within the range l and r.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def sum_in_Range(l, r):\n    \"\"\"\n    Calculate the sum of all odd natural numbers within the given range [l, r].\n    \n    Parameters:\n    l (int): The lower bound of the range.\n    r (int): The upper bound of the range.\n    \n    Returns:\n    int: The sum of all odd natural numbers in the specified range.\n    \"\"\"\n    total_sum = 0\n    for num in range(max(l-1, 1), min(r+1, 2**31)):\n        if num % 2 != 0:\n            total_sum += num\n    return total_sum\n\n# Test Cases\nassert sum_in_Range(2, 5) == 8\nassert sum_in_Range(5, 7) == 12\nassert sum_in_Range(7, 13) == 40\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert sum_in_Range(2,5) == 8",
      "assert sum_in_Range(5,7) == 12",
      "assert sum_in_Range(7,13) == 40"
    ]
  },
  {
    "mbpp_id": 798,
    "problem_statement": "Write a python function to find the sum of an array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def _sum(arr):\n    # Calculate the sum of the array elements\n    total_sum = sum(arr)\n    return total_sum",
    "test_cases": [
      "assert _sum([1, 2, 3]) == 6",
      "assert _sum([15, 12, 13, 10]) == 50",
      "assert _sum([0, 1, 2]) == 3"
    ]
  },
  {
    "mbpp_id": 799,
    "problem_statement": "Write a python function to left rotate the bits of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def left_Rotate(num, positions):\n    # Convert the number into its binary representation and reverse it\n    reversed_binary = bin(num)[2:][::-1]\n    # Reverse again to get the rotated bits\n    rotated_bits = reversed_binary[::-1]\n    \n    # Format the reversed binary string back into an integer\n    rotated_number = int(rotated_bits, 2)\n    \n    return rotated_number\n\n# Test cases\nprint(left_Rotate(16,2))   # Expected output: 64\nprint(left_Rotate(10,2))   # Expected output: 40\nprint(left_Rotate(99,3))   # Expected output: 792",
    "test_cases": [
      "assert left_Rotate(16,2) == 64",
      "assert left_Rotate(10,2) == 40",
      "assert left_Rotate(99,3) == 792"
    ]
  },
  {
    "mbpp_id": 800,
    "problem_statement": "Write a function to remove all whitespaces from a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_all_spaces(input_str):\n    # Remove all spaces from the input string using str.replace method with space as replacement\n    return input_str.replace(\" \", \"\")",
    "test_cases": [
      "assert remove_all_spaces('python  program')==('pythonprogram')",
      "assert remove_all_spaces('python   programming    language')==('pythonprogramminglanguage')",
      "assert remove_all_spaces('python                     program')==('pythonprogram')"
    ]
  },
  {
    "mbpp_id": 801,
    "problem_statement": "Write a python function to count the number of equal numbers from three given integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def count_equal_numbers(x, y, z):\n    # Counting how many times each number appears and checking for equality\n    if x == y and y == z:\n        return 3\n    elif x == y or y == z or x == z:\n        return 2\n    else:\n        return 1\n\n# Test cases to verify the correctness of the function\nassert count_equal_numbers(1, 1, 1) == 3\nassert count_equal_numbers(-1, -2, -3) == 0\nassert count_equal_numbers(1, 2, 2) == 2\nprint(\"All tests passed!\")",
    "test_cases": [
      "assert test_three_equal(1,1,1) == 3",
      "assert test_three_equal(-1,-2,-3) == 0",
      "assert test_three_equal(1,2,2) == 2"
    ]
  },
  {
    "mbpp_id": 802,
    "problem_statement": "Write a python function to count the number of rotations required to generate a sorted array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Rotation(arr, n):\n    low = 0\n    high = n - 1\n    \n    while arr[low] >= arr[high]:\n        if high == low:\n            break\n        \n        mid = (low + high) // 2\n        \n        if arr[mid] <= arr[high]:\n            high = mid\n            \n        else:\n            low = mid + 1\n    \n    return low + 1\n\n# Test Cases\nprint(count_Rotation([3,2,1], 3))  # Expected output: 1\nprint(count_Rotation([4,5,1,2,3], 5))  # Expected output: 2\nprint(count_Rotation([7,8,9,1,2,3], 6))  # Expected output: 3",
    "test_cases": [
      "assert count_Rotation([3,2,1],3) == 1",
      "assert count_Rotation([4,5,1,2,3],5) == 2",
      "assert count_Rotation([7,8,9,1,2,3],6) == 3"
    ]
  },
  {
    "mbpp_id": 803,
    "problem_statement": "Write a python function to check whether the given number is a perfect square or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef is_Perfect_Square(number):\n    # Check if the square root of the number is an integer\n    sqrt = int(math.sqrt(number))\n    return sqrt * sqrt == number",
    "test_cases": [
      "assert is_Perfect_Square(10) == False",
      "assert is_Perfect_Square(36) == True",
      "assert is_Perfect_Square(14) == False"
    ]
  },
  {
    "mbpp_id": 804,
    "problem_statement": "Write a python function to check whether the product of numbers is even or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: is_Product_Even() takes 1 positional argument but 2 were given"
    ],
    "generated_code": "def is_Product_Even(nums):\n    # Check if the product of all elements in the list is even\n    product = 1\n    for num in nums:\n        product *= num\n    return product % 2 == 0\n\n# Test cases\nprint(is_Product_Even([1,2,3],3))   # Expected output: True\nprint(is_Product_Even([1,2,1,4],4)) # Expected output: True\nprint(is_Product_Even([1,1],2))     # Expected output: False",
    "test_cases": [
      "assert is_Product_Even([1,2,3],3) == True",
      "assert is_Product_Even([1,2,1,4],4) == True",
      "assert is_Product_Even([1,1],2) == False"
    ]
  },
  {
    "mbpp_id": 805,
    "problem_statement": "Write a function to find the list in a list of lists whose sum of elements is the highest.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_sum_list(lists):\n    # Calculate the sum for each sublist and return the one with the maximum sum\n    return max(lists, key=sum)",
    "test_cases": [
      "assert max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[10, 11, 12] ",
      "assert max_sum_list([[3,2,1], [6,5,4], [12,11,10]])==[12,11,10] ",
      "assert max_sum_list([[2,3,1]])==[2,3,1] "
    ]
  },
  {
    "mbpp_id": 806,
    "problem_statement": "Write a function to find maximum run of uppercase characters in the given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_run_uppercase(s):\n    # Initialize variables\n    max_length = 0\n    current_length = 0\n    \n    for char in s:\n        if char.isupper():\n            # Increment current length if character is uppercase\n            current_length += 1\n            # Update max length if current length is greater\n            if current_length > max_length:\n                max_length = current_length\n        else:\n            # Reset current length when lowercase character is encountered\n            current_length = 0\n            \n    return max_length",
    "test_cases": [
      "assert max_run_uppercase('GeMKSForGERksISBESt') == 5",
      "assert max_run_uppercase('PrECIOusMOVemENTSYT') == 6",
      "assert max_run_uppercase('GooGLEFluTTER') == 4"
    ]
  },
  {
    "mbpp_id": 807,
    "problem_statement": "Write a python function to find the first odd number in a given list of numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None\n\n# Test cases\nprint(first_odd([1, 3, 5]))  # Expected output: 1\nprint(first_odd([2, 4, 1, 3]))  # Expected output: 1\nprint(first_odd([8, 9, 1]))  # Expected output: 9",
    "test_cases": [
      "assert first_odd([1,3,5]) == 1",
      "assert first_odd([2,4,1,3]) == 1",
      "assert first_odd ([8,9,1]) == 9"
    ]
  },
  {
    "mbpp_id": 808,
    "problem_statement": "Write a function to check if the given tuples contain the k or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_K(tup, k):\n    # Check if 'k' is present in the tuple\n    return k in tup",
    "test_cases": [
      "assert check_K((10, 4, 5, 6, 8), 6) == True",
      "assert check_K((1, 2, 3, 4, 5, 6), 7) == False",
      "assert check_K((7, 8, 9, 44, 11, 12), 11) == True"
    ]
  },
  {
    "mbpp_id": 809,
    "problem_statement": "Write a function to check if each element of second tuple is smaller than its corresponding index in first tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_smaller(tup1, tup2):\n    for i in range(len(tup1)):\n        if tup1[i] >= tup2[i]:\n            return False\n    return True",
    "test_cases": [
      "assert check_smaller((1, 2, 3), (2, 3, 4)) == False",
      "assert check_smaller((4, 5, 6), (3, 4, 5)) == True",
      "assert check_smaller((11, 12, 13), (10, 11, 12)) == True"
    ]
  },
  {
    "mbpp_id": 810,
    "problem_statement": "Write a function to iterate over elements repeating each as many times as its count.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - unsupported operand type(s) for -: 'str' and 'str'",
      "Test 2: FAIL - unsupported operand type(s) for -: 'str' and 'str'",
      "Test 3: FAIL - unsupported operand type(s) for -: 'str' and 'str'"
    ],
    "generated_code": "def count_variable(*args):\n    result = []\n    for i in args:\n        for _ in range(i):\n            result.append(chr(ord('a') + ord('a' - 'a')))\n    return result",
    "test_cases": [
      "assert count_variable(4,2,0,-2)==['p', 'p', 'p', 'p', 'q', 'q'] ",
      "assert count_variable(0,1,2,3)==['q', 'r', 'r', 's', 's', 's'] ",
      "assert count_variable(11,15,12,23)==['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'q', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's', 's']"
    ]
  },
  {
    "mbpp_id": 811,
    "problem_statement": "Write a function to check if two lists of tuples are identical or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_identical(list1, list2):\n    # Check if both lists have the same number of elements and each corresponding element pair is equal\n    return len(list1) == len(list2) and all(x == y for x, y in zip(list1, list2))",
    "test_cases": [
      "assert check_identical([(10, 4), (2, 5)], [(10, 4), (2, 5)]) == True",
      "assert check_identical([(1, 2), (3, 7)], [(12, 14), (12, 45)]) == False",
      "assert check_identical([(2, 14), (12, 25)], [(2, 14), (12, 25)]) == True"
    ]
  },
  {
    "mbpp_id": 812,
    "problem_statement": "Write a function to abbreviate 'road' as 'rd.' in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def road_rd(text):\n    if text.endswith('Road'):\n        return text[:-4] + ' Rd.'\n    else:\n        return text",
    "test_cases": [
      "assert road_rd(\"ravipadu Road\")==('ravipadu Rd.')",
      "assert road_rd(\"palnadu Road\")==('palnadu Rd.')",
      "assert road_rd(\"eshwar enclave Road\")==('eshwar enclave Rd.')"
    ]
  },
  {
    "mbpp_id": 813,
    "problem_statement": "Write a function to find length of the string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def string_length(input_string):\n    return len(input_string)",
    "test_cases": [
      "assert string_length('python')==6",
      "assert string_length('program')==7",
      "assert string_length('language')==8"
    ]
  },
  {
    "mbpp_id": 814,
    "problem_statement": "Write a function to find the area of a rombus.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def rombus_area(side_a, side_b):\n    return side_a * side_b / 2",
    "test_cases": [
      "assert rombus_area(10,20)==100",
      "assert rombus_area(10,5)==25",
      "assert rombus_area(4,2)==4"
    ]
  },
  {
    "mbpp_id": 815,
    "problem_statement": "Write a function to sort the given array without using any sorting algorithm. the given array consists of only 0, 1, and 2.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - sort_by_dnf() takes 1 positional argument but 2 were given",
      "Test 2: FAIL - sort_by_dnf() takes 1 positional argument but 2 were given",
      "Test 3: FAIL - sort_by_dnf() takes 1 positional argument but 2 were given"
    ],
    "generated_code": "def sort_by_dnf(arr):\n    def partition(low, high):\n        i = low - 1\n        pivot = arr[high]\n        for j in range(low, high):\n            if arr[j] < pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def quicksort(start, end):\n        if start >= end:\n            return\n        pivot_index = partition(start, end)\n        quicksort(start, pivot_index - 1)\n        quicksort(pivot_index + 1, end)\n\n    n = len(arr)\n    quicksort(0, n - 1)\n    return arr\n\n\n# Test Cases\nprint(sort_by_dnf([1,2,0,1,0,1,2,1,1])) # Expected output: [0, 0, 1, 1, 1, 1, 1, 2, 2]\nprint(sort_by_dnf([1,0,0,1,2,1,2,2,1,0])) # Expected output: [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]\nprint(sort_by_dnf([2,2,1,0,0,0,1,1,2,1])) # Expected output: [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]",
    "test_cases": [
      "assert sort_by_dnf([1,2,0,1,0,1,2,1,1], 9) == [0, 0, 1, 1, 1, 1, 1, 2, 2]",
      "assert sort_by_dnf([1,0,0,1,2,1,2,2,1,0], 10) == [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]",
      "assert sort_by_dnf([2,2,1,0,0,0,1,1,2,1], 10) == [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]"
    ]
  },
  {
    "mbpp_id": 816,
    "problem_statement": "Write a function to clear the values of the given tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test failed for input (1, 5, 3, 6, 8). Expected () but got (None, None, None, None, None)",
      "Test failed for input (2, 1, 4, 5, 6). Expected () but got (None, None, None, None, None)",
      "Test failed for input (3, 2, 5, 6, 8). Expected () but got (None, None, None, None, None)",
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def clear_tuple(tup):\n    \"\"\"\n    This function takes a tuple as input and returns a new tuple with all elements set to None.\n    \n    Parameters:\n        tup (tuple): The input tuple containing any type of elements.\n        \n    Returns:\n        tuple: A new tuple where all elements from the original tuple have been set to None.\n    \"\"\"\n    # Using list comprehension to create a new tuple with all elements set to None\n    return tuple(None for _ in tup)\n\n# Check function to verify the correctness of the solution\ndef check_solution():\n    test_cases = [\n        ((1, 5, 3, 6, 8), tuple()),\n        ((2, 1, 4 ,5 ,6), tuple()),\n        ((3, 2, 5, 6, 8), tuple())\n    ]\n    \n    pass_tests = True\n    \n    for inputs, expected_output in test_cases:\n        output = clear_tuple(inputs)\n        if output != expected_output:\n            print(f\"Test failed for input {inputs}. Expected {expected_output} but got {output}\")\n            pass_tests = False\n            \n    if pass_tests:\n        print(\"All tests passed!\")\n    else:\n        print(\"Some tests failed.\")\n\n# Run the check function to validate the solution\ncheck_solution()",
    "test_cases": [
      "assert clear_tuple((1, 5, 3, 6, 8)) == ()",
      "assert clear_tuple((2, 1, 4 ,5 ,6)) == ()",
      "assert clear_tuple((3, 2, 5, 6, 8)) == ()"
    ]
  },
  {
    "mbpp_id": 817,
    "problem_statement": "Write a function to find numbers divisible by m or n from a list of numbers using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "div_of_nums = lambda nums, m, n: [num for num in nums if num % m == 0 or num % n == 0]",
    "test_cases": [
      "assert div_of_nums([19, 65, 57, 39, 152, 639, 121, 44, 90, 190],19,13)==[19, 65, 57, 39, 152, 190]",
      "assert div_of_nums([1, 2, 3, 5, 7, 8, 10],2,5)==[2, 5, 8, 10]",
      "assert div_of_nums([10,15,14,13,18,12,20],10,5)==[10, 15, 20]"
    ]
  },
  {
    "mbpp_id": 818,
    "problem_statement": "Write a python function to count lower case letters in a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def lower_ctr(s):\n    # Initialize counter for lowercase characters\n    lower_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        if 'a' <= char <= 'z':\n            lower_count += 1\n            \n    # Return the total count of lowercase letters\n    return lower_count",
    "test_cases": [
      "assert lower_ctr('abc') == 3",
      "assert lower_ctr('string') == 6",
      "assert lower_ctr('Python') == 5"
    ]
  },
  {
    "mbpp_id": 819,
    "problem_statement": "Write a function to count the frequency of consecutive duplicate elements in a given list of numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from collections import defaultdict\nfrom typing import List, Tuple\n\ndef count_duplic(numbers: List[int]) -> Tuple[List[int], List[int]]:\n    # Count the occurrences of each number and store them in a dictionary.\n    counts = defaultdict(int)\n    for num in numbers:\n        counts[num] += 1\n    \n    # Separate the unique numbers from their respective counts.\n    unique_numbers = []\n    duplicates_counts = []\n    \n    for key, value in counts.items():\n        if value == 1:\n            unique_numbers.append(key)\n        else:\n            duplicates_counts.append(value)\n            \n    return unique_numbers, duplicates_counts",
    "test_cases": [
      "assert count_duplic([1,2,2,2,4,4,4,5,5,5,5])==([1, 2, 4, 5], [1, 3, 3, 4])",
      "assert count_duplic([2,2,3,1,2,6,7,9])==([2, 3, 1, 2, 6, 7, 9], [2, 1, 1, 1, 1, 1, 1])",
      "assert count_duplic([2,1,5,6,8,3,4,9,10,11,8,12])==([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])"
    ]
  },
  {
    "mbpp_id": 820,
    "problem_statement": "Write a function to check whether the given month number contains 28 days or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_monthnum_number(month_num):\n    # January and February of non-leap years have 28 days\n    if month_num in [1, 2]:\n        return True\n    else:\n        return False",
    "test_cases": [
      "assert check_monthnum_number(2)==True",
      "assert check_monthnum_number(1)==False",
      "assert check_monthnum_number(3)==False"
    ]
  },
  {
    "mbpp_id": 821,
    "problem_statement": "Write a function to merge two dictionaries into a single expression.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def merge_dictionaries(dict1, dict2):\n    # Merge the two dictionaries and return the result as a new dictionary\n    return {**dict1, **dict2}",
    "test_cases": [
      "assert merge_dictionaries({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White'}",
      "assert merge_dictionaries({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'O': 'Orange', 'P': 'Pink', 'B': 'Black', 'W': 'White', 'R': 'Red'}",
      "assert merge_dictionaries({ \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'W': 'White', 'O': 'Orange', 'G': 'Green', 'B': 'Black'}"
    ]
  },
  {
    "mbpp_id": 822,
    "problem_statement": "Write a function to return true if the password is valid.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'pass_validity' is not defined",
      "Test 2: FAIL - name 'pass_validity' is not defined",
      "Test 3: FAIL - name 'pass_validity' is not defined"
    ],
    "generated_code": "import re\n\ndef validate_password(password):\n    # Check length of the password\n    if len(password) < 8:\n        return False\n    \n    # Check for uppercase letter\n    if not re.search(\"[A-Z]\", password):\n        return False\n    \n    # Check for lowercase letter\n    if not re.search(\"[a-z]\", password):\n        return False\n    \n    # Check for digit\n    if not re.search(\"[0-9]\", password):\n        return False\n    \n    # Check for special character\n    if not re.search(\"[!@#$%^&*(),.?\\\":{}|<>]\", password):\n        return False\n    \n    return True",
    "test_cases": [
      "assert pass_validity(\"password\")==False",
      "assert pass_validity(\"Password@10\")==True",
      "assert pass_validity(\"password@10\")==False"
    ]
  },
  {
    "mbpp_id": 823,
    "problem_statement": "Write a function to check if the given string starts with a substring using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef check_substring(input_string, substring):\n    # Use regular expression to match whether the input string starts with the substring\n    if re.match(r'^.*' + re.escape(substring), input_string):\n        return f\"string starts with the given substring\"\n    else:\n        return f'string doesnt start with the given substring'\n\n# Test cases\nprint(check_substring(\"dreams for dreams makes life fun\", \"makes\"))\nprint(check_substring(\"Hi there how are you Hi alex\", \"Hi\"))\nprint(check_substring(\"Its been a long day\", \"been\"))",
    "test_cases": [
      "assert check_substring(\"dreams for dreams makes life fun\", \"makes\") == 'string doesnt start with the given substring'",
      "assert check_substring(\"Hi there how are you Hi alex\", \"Hi\") == 'string starts with the given substring'",
      "assert check_substring(\"Its been a long day\", \"been\") == 'string doesnt start with the given substring'"
    ]
  },
  {
    "mbpp_id": 824,
    "problem_statement": "Write a python function to remove even numbers from a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_even(nums):\n    # Use list comprehension to filter out even numbers\n    return [num for num in nums if num % 2 != 0]\n\n# Test cases\nprint(remove_even([1,3,5,2]))  # Expected output: [1,3,5]\nprint(remove_even([5,6,7]))   # Expected output: [5,7]\nprint(remove_even([1,2,3,4])) # Expected output: [1,3]",
    "test_cases": [
      "assert remove_even([1,3,5,2]) == [1,3,5]",
      "assert remove_even([5,6,7]) == [5,7]",
      "assert remove_even([1,2,3,4]) == [1,3]"
    ]
  },
  {
    "mbpp_id": 825,
    "problem_statement": "Write a python function to access multiple elements of specified index from a given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def access_elements(lst, indices):\n    \"\"\"\n    Accesses multiple elements at specified indexes from the given list.\n    \n    Args:\n        lst (list): The input list from which elements will be accessed.\n        indices (tuple): A tuple containing the indexes of the elements to be accessed.\n        \n    Returns:\n        list: A list containing the elements accessed from the original list based on provided indices.\n    \"\"\"\n    # Extracting elements using indexing and appending them to result_list\n    result_list = [lst[index] for index in indices]\n    return result_list",
    "test_cases": [
      "assert access_elements([2,3,8,4,7,9],[0,3,5]) == [2, 4, 9]",
      "assert access_elements([1, 2, 3, 4, 5],[1,2]) == [2,3]",
      "assert access_elements([1,0,2,3],[0,1]) == [1,0]"
    ]
  },
  {
    "mbpp_id": 826,
    "problem_statement": "Write a python function to find the type of triangle from the given sides.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_Type_Of_Triangle(a, b, c):\n    # Sort the lengths of the sides to ensure the longest side is compared correctly\n    sides = sorted([a, b, c])\n    \n    # Check if the triangle is obtuse, right, or acute based on the relationship between the squares of its sides\n    if sides[2]**2 > sides[0]**2 + sides[1]**2:\n        return \"Obtuse-angled Triangle\"\n    elif sides[2]**2 == sides[0]**2 + sides[1]**2:\n        return \"Right-angled Triangle\"\n    else:\n        return \"Acute-angled Triangle\"\n\n# Test cases\nprint(check_Type_Of_Triangle(1, 2, 3))  # Expected output: \"Obtuse-angled Triangle\"\nprint(check_Type_Of_Triangle(2, 2, 2))  # Expected output: \"Acute-angled Triangle\"\nprint(check_Type_Of_Triangle(1, 0, 1))  # Expected output: \"Right-angled Triangle\"",
    "test_cases": [
      "assert check_Type_Of_Triangle(1,2,3) == \"Obtuse-angled Triangle\"",
      "assert check_Type_Of_Triangle(2,2,2) == \"Acute-angled Triangle\"",
      "assert check_Type_Of_Triangle(1,0,1) == \"Right-angled Triangle\""
    ]
  },
  {
    "mbpp_id": 827,
    "problem_statement": "Write a function to sum a specific column of a list in a given list of lists.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_column(lst, col_index):\n    return sum(row[col_index] for row in lst)",
    "test_cases": [
      "assert sum_column( [[1,2,3,2],[4,5,6,2],[7,8,9,5],],0)==12",
      "assert sum_column( [[1,2,3,2],[4,5,6,2],[7,8,9,5],],1)==15",
      "assert sum_column( [[1,2,3,2],[4,5,6,2],[7,8,9,5],],3)==9"
    ]
  },
  {
    "mbpp_id": 828,
    "problem_statement": "Write a function to count alphabets,digits and special charactes in a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_alpha_dig_spl(input_string):\n    alpha_count = 0\n    dig_count = 0\n    spl_count = 0\n    \n    for char in input_string:\n        if char.isalpha():\n            alpha_count += 1\n        elif char.isdigit():\n            dig_count += 1\n        else:\n            spl_count += 1\n            \n    return alpha_count, dig_count, spl_count",
    "test_cases": [
      "assert count_alpha_dig_spl(\"abc!@#123\")==(3,3,3)",
      "assert count_alpha_dig_spl(\"dgsuy@#$%&1255\")==(5,4,5)",
      "assert count_alpha_dig_spl(\"fjdsif627348#%$^&\")==(6,6,5)"
    ]
  },
  {
    "mbpp_id": 829,
    "problem_statement": "Write a function to find out the second most repeated (or frequent) string in the given sequence.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import Counter\n\ndef second_frequent(sequence):\n    # Count the frequency of each element in the sequence\n    freq = Counter(sequence)\n    # Get the list of frequencies\n    freq_list = sorted(freq.values(), reverse=True)\n    \n    # If there's less than two unique elements, return None\n    if len(freq_list) < 2:\n        return None\n    \n    # Return the second largest frequency element\n    return next(k for k, v in freq.items() if v == freq_list[1])\n\n# Test cases\nprint(second_frequent(['aaa','bbb','ccc','bbb','aaa','aaa']))  # Should return 'bbb'\nprint(second_frequent(['abc','bcd','abc','bcd','bcd','bcd']))  # Should return 'abc'\nprint(second_frequent(['cdma','gsm','hspa','gsm','cdma','cdma']))  # Should return 'gsm'",
    "test_cases": [
      "assert second_frequent(['aaa','bbb','ccc','bbb','aaa','aaa']) == 'bbb'",
      "assert second_frequent(['abc','bcd','abc','bcd','bcd','bcd']) == 'abc'",
      "assert second_frequent(['cdma','gsm','hspa','gsm','cdma','cdma']) == 'gsm'"
    ]
  },
  {
    "mbpp_id": 830,
    "problem_statement": "Write a function to round up a number to specific digits.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - invalid literal for int() with base 10: '123.0'",
      "Test 2: FAIL - invalid literal for int() with base 10: '123.01'",
      "Test 3: FAIL - invalid literal for int() with base 10: '123.012'"
    ],
    "generated_code": "def round_up(number, ndigits):\n    return int('%.{}f'.format(ndigits + 1) % number)",
    "test_cases": [
      "assert round_up(123.01247,0)==124",
      "assert round_up(123.01247,1)==123.1",
      "assert round_up(123.01247,2)==123.02"
    ]
  },
  {
    "mbpp_id": 831,
    "problem_statement": "Write a python function to count equal element pairs from the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_Pairs(arr, n):\n    # Initialize counter for number of equal element pairs\n    pair_count = 0\n    \n    # Sort the array to make it easier to find pairs\n    arr.sort()\n    \n    i = 0\n    j = len(arr)-1\n    \n    while i < j:\n        if arr[i] == arr[j]:\n            # Count both occurrences in current pair\n            pair_count += 1 + ((j - i) // 2)\n            i += 1\n            j -= 1\n        elif arr[i] > arr[j]:\n            j -= 1\n        else:\n            i += 1\n            \n    return pair_count",
    "test_cases": [
      "assert count_Pairs([1,1,1,1],4) == 6",
      "assert count_Pairs([1,5,1],3) == 1",
      "assert count_Pairs([3,2,1,7,8,9],6) == 0"
    ]
  },
  {
    "mbpp_id": 832,
    "problem_statement": "Write a function to extract the maximum numeric value from a string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef extract_max(s):\n    # Extract all numbers in the string using regex and find the max\n    num_list = re.findall(r'\\d+', s)\n    if not num_list:\n        return None\n    return int(max(num_list))",
    "test_cases": [
      "assert extract_max('100klh564abc365bg') == 564",
      "assert extract_max('hello300how546mer231') == 546",
      "assert extract_max('its233beenalong343journey234') == 343"
    ]
  },
  {
    "mbpp_id": 833,
    "problem_statement": "Write a function to get dictionary keys as a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_key(dict_):\n    return [*dict_.keys()]",
    "test_cases": [
      "assert get_key({1:'python',2:'java'})==[1,2]",
      "assert get_key({10:'red',20:'blue',30:'black'})==[10,20,30]",
      "assert get_key({27:'language',39:'java',44:'little'})==[27,39,44]"
    ]
  },
  {
    "mbpp_id": 834,
    "problem_statement": "Write a function to generate a square matrix filled with elements from 1 to n raised to the power of 2 in spiral order.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import numpy as np\n\ndef generate_matrix(n):\n    # Initialize an empty list to store the matrix\n    result = []\n    \n    # Iterate over each layer starting from the outermost layer and going inward\n    for i in range((n + 1) // 2):  # Calculate the number of layers (half of n)\n        # Determine the boundaries for the current layer\n        left = i  # Left boundary\n        right = n - i - 1  # Right boundary\n        top = i  # Top boundary\n        bottom = n - i - 1  # Bottom boundary\n        \n        # Create a sublist for the current row based on the layer boundaries\n        current_row = [int(pow(j + 1, 2)) for j in range(left, right + 1)]\n        \n        # Append the current row to the result list\n        result.append(current_row)\n    \n    return result",
    "test_cases": [
      "assert generate_matrix(3)==[[1, 2, 3], [8, 9, 4], [7, 6, 5]] ",
      "assert generate_matrix(2)==[[1,2],[4,3]]",
      "assert generate_matrix(7)==[[1, 2, 3, 4, 5, 6, 7], [24, 25, 26, 27, 28, 29, 8], [23, 40, 41, 42, 43, 30, 9], [22, 39, 48, 49, 44, 31, 10], [21, 38, 47, 46, 45, 32, 11], [20, 37, 36, 35, 34, 33, 12], [19, 18, 17, 16, 15, 14, 13]]"
    ]
  },
  {
    "mbpp_id": 835,
    "problem_statement": "Write a python function to find the slope of a line.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def slope(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the slope of a line given two points.\n    \n    Parameters:\n    x1, y1 : int/float -- coordinates of point 1\n    x2, y2 : int/float -- coordinates of point 2\n    \n    Returns:\n    float -- The slope of the line between the two points.\n    \"\"\"\n    if x2 == x1: # If the lines is vertical\n        return None\n    else:\n        m = (y2 - y1) / (x2 - x1)\n        return m\n\n# Test Cases\nprint(slope(4, 2, 2, 5))  # Expected output: -1.5\nprint(slope(2, 4, 4, 6))  # Expected output: 1\nprint(slope(1, 2, 4, 2))  # Expected output: 0",
    "test_cases": [
      "assert slope(4,2,2,5) == -1.5",
      "assert slope(2,4,4,6) == 1",
      "assert slope(1,2,4,2) == 0"
    ]
  },
  {
    "mbpp_id": 836,
    "problem_statement": "Write a function to find length of the subarray having maximum sum.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - max_sub_array_sum() takes 1 positional argument but 2 were given",
      "Test 2: FAIL - max_sub_array_sum() takes 1 positional argument but 2 were given",
      "Test 3: FAIL - max_sub_array_sum() takes 1 positional argument but 2 were given"
    ],
    "generated_code": "def max_sub_array_sum(nums):\n    \"\"\"\n    Finds the length of the subarray with the maximum sum.\n    \n    :param nums: List[int] - The list of integers.\n    :return: int - Length of the longest subarray with the maximum sum.\n    \"\"\"\n    current_sum = max_sum = float('-inf')\n    start = end = s = 0\n    \n    for e in range(len(nums)):\n        current_sum += nums[e]\n        \n        if current_sum > max_sum:\n            max_sum = current_sum\n            end = e\n        \n        while current_sum <= 0 and s < len(nums):\n            current_sum -= nums[s]\n            s += 1\n            \n    return end - start + 1",
    "test_cases": [
      "assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3],8) == 5",
      "assert max_sub_array_sum([1, -2, 1, 1, -2, 1],6) == 2",
      "assert max_sub_array_sum([-1, -2, 3, 4, 5],5) == 3"
    ]
  },
  {
    "mbpp_id": 837,
    "problem_statement": "Write a python function to find the cube sum of first n odd natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'cube_Sum' is not defined",
      "Test 2: FAIL - name 'cube_Sum' is not defined",
      "Test 3: FAIL - name 'cube_Sum' is not defined"
    ],
    "generated_code": "def cube_sum(n):\n    total = 0\n    for i in range(n * 2 - 1, 0, -2):\n        total += i ** 3\n    return total",
    "test_cases": [
      "assert cube_Sum(2) == 28",
      "assert cube_Sum(3) == 153",
      "assert cube_Sum(4) == 496"
    ]
  },
  {
    "mbpp_id": 838,
    "problem_statement": "Write a python function to find minimum number swaps required to make two binary strings equal.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: list indices must be integers or slices, not str"
    ],
    "generated_code": "def min_Swaps(s1, s2):\n    \"\"\"\n    This function takes in two binary strings and returns the minimum number of swaps required \n    to make them equal.\n    \n    Parameters:\n    s1 (str): The first binary string.\n    s2 (str): The second binary string.\n    \n    Returns:\n    int: The minimum number of swaps required to make the two strings equal.\n    \"\"\"\n    # Initialize counters for each character in both strings\n    count_a = [0] * len(s1)\n    count_b = [0] * len(s2)\n\n    # Count occurrences of each character in both strings\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            count_a[s1[i]] += 1\n            count_b[s2[i]] += 1\n    \n    # Calculate the minimum number of swaps needed\n    swap_count = sum(min(count_a[char], count_b[char]) for char in set(count_a) | set(count_b))\n    return swap_count\n\n# Test cases\nprint(min_Swaps(\"0011\", \"1111\"))  # Expected output: 1\nprint(min_Swaps(\"00011\", \"01001\"))  # Expected output: 2\nprint(min_Swaps(\"111\", \"111\"))  # Expected output: 0",
    "test_cases": [
      "assert min_Swaps(\"0011\",\"1111\") == 1",
      "assert min_Swaps(\"00011\",\"01001\") == 2",
      "assert min_Swaps(\"111\",\"111\") == 0"
    ]
  },
  {
    "mbpp_id": 839,
    "problem_statement": "Write a function to sort the tuples alphabetically by the first item of each tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sort_tuple(tuples_list):\n    # Sort the list of tuples using key=lambda x: x[0]\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[0])\n    return sorted_tuples",
    "test_cases": [
      "assert sort_tuple([(\"Amana\", 28), (\"Zenat\", 30), (\"Abhishek\", 29),(\"Nikhil\", 21), (\"B\", \"C\")]) == [('Abhishek', 29), ('Amana', 28), ('B', 'C'), ('Nikhil', 21), ('Zenat', 30)]",
      "assert sort_tuple([(\"aaaa\", 28), (\"aa\", 30), (\"bab\", 29), (\"bb\", 21), (\"csa\", \"C\")]) == [('aa', 30), ('aaaa', 28), ('bab', 29), ('bb', 21), ('csa', 'C')]",
      "assert sort_tuple([(\"Sarala\", 28), (\"Ayesha\", 30), (\"Suman\", 29),(\"Sai\", 21), (\"G\", \"H\")]) == [('Ayesha', 30), ('G', 'H'), ('Sai', 21), ('Sarala', 28), ('Suman', 29)]"
    ]
  },
  {
    "mbpp_id": 840,
    "problem_statement": "Write a python function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def Check_Solution(a, b, c):\n    discriminant = (b**2) - (4*a*c)\n    if discriminant == 0:\n        root = (-b + discriminant ** 0.5) / (2 * a)\n        return \"Yes\" if abs(root - root) < 1e-9 else \"No\"\n    elif discriminant > 0:\n        sqrt_discriminant = (discriminant) ** 0.5\n        root1 = (-b + sqrt_discriminant) / (2 * a)\n        root2 = (-b - sqrt_discriminant) / (2 * a)\n        return \"Yes\" if (root1-root2) < 1e-9 and (root1-root2) > -1e-9 else \"No\"\n    else:\n        return \"No\"\n\n# Test cases\nprint(Check_Solution(2,0,-1))  # Expected output: Yes\nprint(Check_Solution(1,-5,6))  # Expected output: No\nprint(Check_Solution(2,0,2))   # Expected output: Yes",
    "test_cases": [
      "assert Check_Solution(2,0,-1) == \"Yes\"",
      "assert Check_Solution(1,-5,6) == \"No\"",
      "assert Check_Solution(2,0,2) == \"Yes\""
    ]
  },
  {
    "mbpp_id": 841,
    "problem_statement": "Write a function to count the number of inversions in the given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_inv_count(arr, n): \n    inversion_count = 0\n    for i in range(n - 1): \n        for j in range(i + 1, n): \n            if arr[i] > arr[j]: \n                inversion_count += 1\n    return inversion_count",
    "test_cases": [
      "assert get_inv_count([1, 20, 6, 4, 5], 5) == 5",
      "assert get_inv_count([8, 4, 2, 1], 4) == 6",
      "assert get_inv_count([3, 1, 2], 3) == 2"
    ]
  },
  {
    "mbpp_id": 842,
    "problem_statement": "Write a function to find the number which occurs for odd number of times in the given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_odd_occurence(arr, n):\n    count = [0] * n\n    for num in arr:\n        index = abs(num) - 1\n        if count[index] == 0:\n            count[index] += 1\n        else:\n            count[index] -= 1\n    \n    result = None\n    for i in range(n):\n        if count[i] > 0:\n            result = i + 1\n            break\n    \n    return result",
    "test_cases": [
      "assert get_odd_occurence([2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2], 13) == 5",
      "assert get_odd_occurence([1, 2, 3, 2, 3, 1, 3], 7) == 3",
      "assert get_odd_occurence([5, 7, 2, 7, 5, 2, 5], 7) == 5"
    ]
  },
  {
    "mbpp_id": 843,
    "problem_statement": "Write a function to find the nth super ugly number from a given prime list of size k using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: free variable 'p' referenced before assignment in enclosing scope"
    ],
    "generated_code": "import heapq\n\ndef nth_super_ugly_number(n, primes):\n    # Initialize a min heap with the first n elements of the prime numbers multiplied by 1.\n    min_heap = [(p * i, p * i) for i in range(n)]\n    # Create an array to store the nth super ugly number found so far.\n    ugly_nums = [x[0] for x in min_heap]\n    \n    while len(min_heap) > 0:\n        val, num = heapq.heappop(min_heap)\n        if val == ugly_nums[-1]:\n            break\n        for p in primes:\n            new_val = num * p\n            if new_val not in ugly_nums:\n                heapq.heappush(min_heap, (new_val, new_val))\n                ugly_nums.append(new_val)\n                \n    return ugly_nums[n-1]\n\n# Example usage\nprint(nth_super_ugly_number(12, [2, 7, 13, 19]))  # Output should be 32\nprint(nth_super_ugly_number(10, [2, 7, 13, 19]))  # Output should be 26\nprint(nth_super_ugly_number(100, [2, 7, 13, 19]))  # Output should be 5408",
    "test_cases": [
      "assert nth_super_ugly_number(12,[2,7,13,19])==32",
      "assert nth_super_ugly_number(10,[2,7,13,19])==26",
      "assert nth_super_ugly_number(100,[2,7,13,19])==5408"
    ]
  },
  {
    "mbpp_id": 844,
    "problem_statement": "Write a python function to find the kth element in an array containing odd elements first and then even elements.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'get_Number' is not defined",
      "Test 2: FAIL - name 'get_Number' is not defined",
      "Test 3: FAIL - name 'get_Number' is not defined"
    ],
    "generated_code": "def get_number(k, n):\n    # Check if n is greater than k\n    if n > k:\n        # Return kth number from the start of the list which alternates between odd and even numbers\n        return n - ((n-k-1)//2)\n    else:\n        # Return kth number from the end of the list starting with the last odd/even number based on the parity of n\n        return n + ((k+1)//2)\n\n# Test cases\nprint(get_number(8, 5))  # Expected output: 2\nprint(get_number(7, 2))  # Expected output: 3\nprint(get_number(5, 2))  # Expected output: 3",
    "test_cases": [
      "assert get_Number(8,5) == 2",
      "assert get_Number(7,2) == 3",
      "assert get_Number(5,2) == 3"
    ]
  },
  {
    "mbpp_id": 845,
    "problem_statement": "Write a python function to count the number of digits in factorial of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'math' is not defined",
      "Test 2: FAIL - name 'math' is not defined",
      "Test 3: FAIL - name 'math' is not defined"
    ],
    "generated_code": "def find_Digits(n):\n    # Initialize a counter for the digit count\n    digit_count = 0\n    \n    # Compute the factorial and store it in temp variable\n    temp = math.factorial(n)\n    \n    # Loop until temp becomes zero\n    while temp > 0:\n        digit_count += 1  # Increment the digit count each time we process a digit\n        temp //= 10      # Remove the last digit from temp\n        \n    return digit_count",
    "test_cases": [
      "assert find_Digits(7) == 4",
      "assert find_Digits(5) == 3",
      "assert find_Digits(4) == 2"
    ]
  },
  {
    "mbpp_id": 846,
    "problem_statement": "Write a function to find the minimum number of platforms required for a railway/bus station.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_platform(arrival_time, departure_time, n):\n    arrival_time.sort()\n    departure_time.sort()\n\n    max_platforms = 1\n    current_platforms = 1\n    i, j = 1, 0\n\n    while i < n and j < n:\n        if arrival_time[i] < departure_time[j]:\n            current_platforms += 1\n            i += 1\n            max_platforms = max(max_platforms, current_platforms)\n        else:\n            current_platforms -= 1\n            j += 1\n\n    return max_platforms",
    "test_cases": [
      "assert find_platform([900, 940, 950, 1100, 1500, 1800],[910, 1200, 1120, 1130, 1900, 2000],6)==3",
      "assert find_platform([100,200,300,400],[700,800,900,1000],4)==4",
      "assert find_platform([5,6,7,8],[4,3,2,1],4)==1"
    ]
  },
  {
    "mbpp_id": 847,
    "problem_statement": "Write a python function to copy a list from a singleton tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def lcopy(l):\n    \"\"\"\n    This function takes a list and returns a new list with the same elements as the input.\n    \n    Parameters:\n    l (list): The input list to be copied.\n    \n    Returns:\n    list: A new list containing the same elements as the input list.\n    \"\"\"\n    return l[:]\n\n# Check function with provided data points to verify correctness\ndef check_solution():\n    assert lcopy([1, 2, 3]) == [1, 2, 3], \"Test case 1 failed\"\n    assert lcopy([4, 8, 2, 10, 15, 18]) == [4, 8, 2, 10, 15, 18], \"Test case 2 failed\"\n    assert lcopy([4, 5, 6]) == [4, 5, 6], \"Test case 3 failed\"\n    print(\"All test cases passed!\")\n\ncheck_solution()",
    "test_cases": [
      "assert lcopy([1, 2, 3]) == [1, 2, 3]",
      "assert lcopy([4, 8, 2, 10, 15, 18]) == [4, 8, 2, 10, 15, 18]",
      "assert lcopy([4, 5, 6]) == [4, 5, 6]\n"
    ]
  },
  {
    "mbpp_id": 848,
    "problem_statement": "Write a function to find the area of a trapezium.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def area_trapezium(a,b,c):\n    # Calculate and return the area of the trapezium\n    return ((a + b) * c) / 2",
    "test_cases": [
      "assert area_trapezium(6,9,4)==30",
      "assert area_trapezium(10,20,30)==450",
      "assert area_trapezium(15,25,35)==700"
    ]
  },
  {
    "mbpp_id": 849,
    "problem_statement": "Write a python function to find sum of all prime divisors of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Sum' is not defined",
      "Test 2: FAIL - name 'Sum' is not defined",
      "Test 3: FAIL - name 'Sum' is not defined"
    ],
    "generated_code": "def sum_of_prime_divisors(n):\n    total_sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            total_sum += i\n    return total_sum\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
    "test_cases": [
      "assert Sum(60) == 10",
      "assert Sum(39) == 16",
      "assert Sum(40) == 7"
    ]
  },
  {
    "mbpp_id": 850,
    "problem_statement": "Write a function to check if a triangle of positive area is possible with the given angles.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_triangleexists(a, b, c):\n    # Check if the sum of any two sides is greater than the third side.\n    return a + b > c and a + c > b and b + c > a",
    "test_cases": [
      "assert is_triangleexists(50,60,70)==True",
      "assert is_triangleexists(90,45,45)==True",
      "assert is_triangleexists(150,30,70)==False"
    ]
  },
  {
    "mbpp_id": 851,
    "problem_statement": "Write a python function to find sum of inverse of divisors.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef Sum_of_Inverse_Divisors(n, m):\n    divisor_sum = 0\n    for i in range(1, min(m+1, n)+1):\n        if n % i == 0:\n            divisor_sum += 1/i\n    return round(divisor_sum, 2)\n\n# Test cases\nprint(Sum_of_Inverse_Divisors(6, 12)) # Expected output: 2\nprint(Sum_of_Inverse_Divisors(9, 13)) # Expected output: 1.44\nprint(Sum_of_Inverse_Divisors(1, 4))  # Expected output: 4",
    "test_cases": [
      "assert Sum_of_Inverse_Divisors(6,12) == 2",
      "assert Sum_of_Inverse_Divisors(9,13) == 1.44",
      "assert Sum_of_Inverse_Divisors(1,4) == 4"
    ]
  },
  {
    "mbpp_id": 852,
    "problem_statement": "Write a python function to remove negative numbers from a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_negs(lst):\n    return [x for x in lst if x >= 0]\n\n# Test cases\nprint(remove_negs([1,-2,3,-4]))  # Output: [1, 3]\nprint(remove_negs([1,2,3,-4]))   # Output: [1, 2, 3]\nprint(remove_negs([4,5,-6,7,-8]))# Output: [4, 5, 7]",
    "test_cases": [
      "assert remove_negs([1,-2,3,-4]) == [1,3]",
      "assert remove_negs([1,2,3,-4]) == [1,2,3]",
      "assert remove_negs([4,5,-6,7,-8]) == [4,5,7]"
    ]
  },
  {
    "mbpp_id": 853,
    "problem_statement": "Write a python function to find sum of odd factors of a number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'sum_of_odd_Factors' is not defined",
      "Test 2: FAIL - name 'sum_of_odd_Factors' is not defined",
      "Test 3: FAIL - name 'sum_of_odd_Factors' is not defined"
    ],
    "generated_code": "def sum_of_odd_factors(number):\n    total_sum = 0\n    for i in range(1, int(number**0.5) + 1):\n        if number % i == 0:\n            # Check if both factors are odd\n            if i % 2 != 0 and number // i % 2 != 0:\n                total_sum += i\n            elif i % 2 != 0 and number // i > 1:\n                total_sum += number // i\n    return total_sum",
    "test_cases": [
      "assert sum_of_odd_Factors(30) == 24",
      "assert sum_of_odd_Factors(18) == 13",
      "assert sum_of_odd_Factors(2) == 1"
    ]
  },
  {
    "mbpp_id": 854,
    "problem_statement": "Write a function which accepts an arbitrary list and converts it to a heap using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import heapq\n\ndef raw_heap(list_data):\n    return sorted(list_data)\n\n# Test Cases\nprint(raw_heap([25, 44, 68, 21, 39, 23, 89]))  # Expected output: [21, 25, 23, 44, 39, 68, 89]\nprint(raw_heap([25, 35, 22, 85, 14, 65, 75, 25, 58]))  # Expected output: [14, 25, 22, 25, 35, 65, 75, 85, 58]\nprint(raw_heap([4, 5, 6, 2]))  # Expected output: [2, 4, 6, 5]",
    "test_cases": [
      "assert raw_heap([25, 44, 68, 21, 39, 23, 89])==[21, 25, 23, 44, 39, 68, 89]",
      "assert raw_heap([25, 35, 22, 85, 14, 65, 75, 25, 58])== [14, 25, 22, 25, 35, 65, 75, 85, 58]",
      "assert raw_heap([4, 5, 6, 2])==[2, 4, 6, 5]"
    ]
  },
  {
    "mbpp_id": 855,
    "problem_statement": "Write a python function to check for even parity of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_Even_Parity(n):\n    # Initialize a flag variable as False\n    has_even = False\n    \n    # Iterate through each bit position from most significant to least significant\n    for i in range(32):  # Assuming we are dealing with a 32-bit integer\n        # Check if the current bit is set (i.e., not zero)\n        if n & (1 << i):\n            # If an odd number of bits were set so far, set the flag to True and break out of the loop\n            if has_even:\n                return False\n            has_even = True\n            \n    # If no odd number of bits was set, the parity is even\n    return has_even",
    "test_cases": [
      "assert check_Even_Parity(10) == True",
      "assert check_Even_Parity(11) == False",
      "assert check_Even_Parity(18) == True"
    ]
  },
  {
    "mbpp_id": 856,
    "problem_statement": "Write a python function to find minimum adjacent swaps required to sort binary array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_Min_Swaps(arr, n):\n    # Count number of inversions where left is greater than right\n    count = sum(a > b for a, b in zip(arr, arr[1:]))\n\n    # Calculate total possible permutations minus inversions\n    return (n * (n + 1)) // 2 - count",
    "test_cases": [
      "assert find_Min_Swaps([1,0,1,0],4) == 3",
      "assert find_Min_Swaps([0,1,0],3) == 1",
      "assert find_Min_Swaps([0,0,1,1,0],5) == 2"
    ]
  },
  {
    "mbpp_id": 857,
    "problem_statement": "Write a function to list out the list of given strings individually using map function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def listify_list(lst):\n    return [list(s) for s in lst]",
    "test_cases": [
      "assert listify_list(['Red', 'Blue', 'Black', 'White', 'Pink'])==[['R', 'e', 'd'], ['B', 'l', 'u', 'e'], ['B', 'l', 'a', 'c', 'k'], ['W', 'h', 'i', 't', 'e'], ['P', 'i', 'n', 'k']]",
      "assert listify_list(['python'])==[['p', 'y', 't', 'h', 'o', 'n']]",
      "assert listify_list([' red ', 'green',' black', 'blue ',' orange', 'brown'])==[[' ', 'r', 'e', 'd', ' '], ['g', 'r', 'e', 'e', 'n'], [' ', 'b', 'l', 'a', 'c', 'k'], ['b', 'l', 'u', 'e', ' '], [' ', 'o', 'r', 'a', 'n', 'g', 'e'], ['b', 'r', 'o', 'w', 'n']]"
    ]
  },
  {
    "mbpp_id": 858,
    "problem_statement": "Write a function to count number of lists in a given list of lists and square the count.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_list(lst):\n    return len(lst) ** 2",
    "test_cases": [
      "assert count_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==25",
      "assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]] )==16",
      "assert count_list([[2, 4], [[6,8], [4,5,8]], [10, 12, 14]])==9"
    ]
  },
  {
    "mbpp_id": 859,
    "problem_statement": "Write a function to generate all sublists of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - maximum recursion depth exceeded",
      "Test 2: FAIL - maximum recursion depth exceeded",
      "Test 3: FAIL - maximum recursion depth exceeded"
    ],
    "generated_code": "def sub_lists(lst):\n    return [[i] + sublist for i in lst for sublist in sub_lists(lst) if len(sublist) < len(lst)]",
    "test_cases": [
      "assert sub_lists([10, 20, 30, 40])==[[], [10], [20], [30], [40], [10, 20], [10, 30], [10, 40], [20, 30], [20, 40], [30, 40], [10, 20, 30], [10, 20, 40], [10, 30, 40], [20, 30, 40], [10, 20, 30, 40]]",
      "assert sub_lists(['X', 'Y', 'Z'])==[[], ['X'], ['Y'], ['Z'], ['X', 'Y'], ['X', 'Z'], ['Y', 'Z'], ['X', 'Y', 'Z']]",
      "assert sub_lists([1,2,3])==[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]"
    ]
  },
  {
    "mbpp_id": 860,
    "problem_statement": "Write a function to check whether the given string is ending with only alphanumeric characters or not using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef check_alphanumeric(string):\n    \"\"\"\n    This function checks if the last word of a string is ending with only alphanumeric characters.\n    \n    Args:\n        string (str): The input string to be checked.\n        \n    Returns:\n        str: 'Accept' if the last word ends with an alphanumeric character, otherwise 'Discard'.\n    \"\"\"\n    # Extracting words from the input string and checking if the last one ends with alphanumeric characters\n    words = string.split()\n    if len(words) < 2:\n        return \"Discard\"\n    else:\n        last_word = words[-1]\n        if re.match(r'^[a-zA-Z0-9]+$', last_word):\n            return \"Accept\"\n        else:\n            return \"Discard\"\n\n# Test cases\nprint(check_alphanumeric(\"dawood@\"))   # Should return 'Discard'\nprint(check_alphanumeric(\"skdmsam326\"))   # Should return 'Accept'\nprint(check_alphanumeric(\"cooltricks@\"))   # Should return 'Discard'",
    "test_cases": [
      "assert check_alphanumeric(\"dawood@\") == 'Discard'",
      "assert check_alphanumeric(\"skdmsam326\") == 'Accept'",
      "assert check_alphanumeric(\"cooltricks@\") == 'Discard'"
    ]
  },
  {
    "mbpp_id": 861,
    "problem_statement": "Write a function to find all anagrams of a string in a given list of strings using lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from collections import defaultdict\n\ndef anagram_lambda(strings, target_string):\n    \"\"\"\n    Find and return all anagrams from the given list of strings for the target string.\n    \n    :param strings: List[str] - A list of candidate strings to check against the target string.\n    :param target_string: str - The string whose anagrams we're looking for.\n    :return: List[str] - A list of strings that are anagrams of the target string.\n    \"\"\"\n    result = []\n    # Lambda expression to group anagrams together based on sorted character sequences\n    grouped_anagrams = {tuple(sorted(s)): s for s in strings}\n    for char_sequence in set(map(tuple, sorted(target_string))):\n        if char_sequence in grouped_anagrams:\n            result.append(grouped_anagrams[char_sequence])\n    return result",
    "test_cases": [
      "assert anagram_lambda([\"bcda\", \"abce\", \"cbda\", \"cbea\", \"adcb\"],\"abcd\")==['bcda', 'cbda', 'adcb']",
      "assert anagram_lambda([\"recitals\",\" python\"], \"articles\" )==[\"recitals\"]",
      "assert anagram_lambda([\" keep\",\" abcdef\",\" xyz\"],\" peek\")==[\" keep\"]"
    ]
  },
  {
    "mbpp_id": 862,
    "problem_statement": "Write a function to find the occurrences of n most common words in a given text.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import collections\nimport operator\n\ndef n_common_words(text,n=10):\n    # Splitting the text into words and counting their occurrences\n    word_count = collections.Counter(text.split())\n    \n    # Sorting the words by frequency and returning the top n\n    sorted_word_count = sorted(word_count.items(), key=operator.itemgetter(1), reverse=True)\n    return sorted_word_count[:n]\n\n# Test cases\nprint(n_common_words(\"python is a programming language\"))  # Expected output: [('python', 1), ('is', 1), ('a', 1), ('programming', 1), ('language', 1)]\nprint(n_common_words(\"the quick brown fox jumps over the lazy dog multiple times\",2))  # Expected output: [('multiple', 1), ('times', 1)]",
    "test_cases": [
      "assert n_common_words(\"python is a programming language\",1)==[('python', 1)]",
      "assert n_common_words(\"python is a programming language\",1)==[('python', 1)]",
      "assert n_common_words(\"python is a programming language\",5)==[('python', 1),('is', 1), ('a', 1), ('programming', 1), ('language', 1)]"
    ]
  },
  {
    "mbpp_id": 863,
    "problem_statement": "Write a function to find the length of the longest sub-sequence such that elements in the subsequences are consecutive integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: object of type 'int' has no len()"
    ],
    "generated_code": "def find_longest_conseq_subseq(arr, n): \n    # Initialize an empty list for tracking sequences and the max sequence length found so far.\n    sequences = []\n    \n    for i in range(n):\n        if arr[i] not in sequences:\n            current_sequence = [arr[i]]\n            \n            while (i + 1 < n and arr[i + 1] == arr[i] + 1):\n                current_sequence.append(arr[i+1])\n                i += 1\n            \n            sequences.extend(current_sequence)\n    \n    # Return the maximum length among all unique sequences.\n    return len(max(sequences))\n\n# Example usage:\nprint(find_longest_conseq_subseq([1, 2, 2, 3], 4))  # Expected output: 3\nprint(find_longest_conseq_subseq([1, 9, 3, 10, 4, 20, 2], 7))  # Expected output: 4\nprint(find_longest_conseq_subseq([36, 41, 56, 35, 44, 33, 34, 92, 43, 32, 42], 11))  # Expected output: 5",
    "test_cases": [
      "assert find_longest_conseq_subseq([1, 2, 2, 3], 4) == 3",
      "assert find_longest_conseq_subseq([1, 9, 3, 10, 4, 20, 2], 7) == 4",
      "assert find_longest_conseq_subseq([36, 41, 56, 35, 44, 33, 34, 92, 43, 32, 42], 11) == 5"
    ]
  },
  {
    "mbpp_id": 864,
    "problem_statement": "Write a function to find palindromes in a given list of strings using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "palindrome_lambda = lambda lst: [word for word in lst if word == word[::-1]]",
    "test_cases": [
      "assert palindrome_lambda([\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"])==['php', 'aaa']",
      "assert palindrome_lambda([\"abcd\", \"Python\", \"abba\", \"aba\"])==['abba', 'aba']",
      "assert palindrome_lambda([\"abcd\", \"abbccbba\", \"abba\", \"aba\"])==['abbccbba', 'abba', 'aba']"
    ]
  },
  {
    "mbpp_id": 865,
    "problem_statement": "Write a function to print n-times a list using map function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def ntimes_list(lst, n):\n    return list(map(lambda x: x * n, lst))",
    "test_cases": [
      "assert ntimes_list([1, 2, 3, 4, 5, 6, 7],3)==[3, 6, 9, 12, 15, 18, 21]",
      "assert ntimes_list([1, 2, 3, 4, 5, 6, 7],4)==[4, 8, 12, 16, 20, 24, 28]",
      "assert ntimes_list([1, 2, 3, 4, 5, 6, 7],10)==[10, 20, 30, 40, 50, 60, 70]"
    ]
  },
  {
    "mbpp_id": 866,
    "problem_statement": "Write a function to check whether the given month name contains 31 days or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_monthnumb(month_name):\n    # List of months with 31 days\n    thirty_one_days_months = [\"January\", \"March\", \"May\", \"July\", \"August\",\n                               \"October\", \"December\"]\n    \n    # Check if the input month name is in the list of months with 31 days\n    return month_name in thirty_one_days_months",
    "test_cases": [
      "assert check_monthnumb(\"February\")==False",
      "assert check_monthnumb(\"January\")==True",
      "assert check_monthnumb(\"March\")==True"
    ]
  },
  {
    "mbpp_id": 867,
    "problem_statement": "Write a python function to add a minimum number such that the sum of array becomes even.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_Num(arr, n):\n    # Calculate the remainder when n is divided by 2\n    remainder = n % 2\n    \n    # If remainder is 0, add 1 to make the total count odd\n    if remainder == 0:\n        return n + 1\n    \n    # Otherwise, no adjustment needed as the count will remain even\n    else:\n        return n",
    "test_cases": [
      "assert min_Num([1,2,3,4,5,6,7,8,9],9) == 1",
      "assert min_Num([1,2,3,4,5,6,7,8],8) == 2",
      "assert min_Num([1,2,3],3) == 2"
    ]
  },
  {
    "mbpp_id": 868,
    "problem_statement": "Write a python function to find the length of the last word in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'length_Of_Last_Word' is not defined",
      "Test 2: FAIL - name 'length_Of_Last_Word' is not defined",
      "Test 3: FAIL - name 'length_Of_Last_Word' is not defined"
    ],
    "generated_code": "def length_of_last_word(s):\n    # Split the string into words and reverse it for easier calculation\n    reversed_words = s.split()[::-1]\n    # Join the words with spaces to form one long word and count its length\n    last_word_length = len(' '.join(reversed_words))\n    return last_word_length\n\n# Test the function\nprint(length_of_last_word(\"python language\"))  # Expected output: 8\nprint(length_of_last_word(\"PHP\"))              # Expected output: 3\nprint(length_of_last_word(\"\"))                 # Expected output: 0",
    "test_cases": [
      "assert length_Of_Last_Word(\"python language\") == 8",
      "assert length_Of_Last_Word(\"PHP\") == 3",
      "assert length_Of_Last_Word(\"\") == 0"
    ]
  },
  {
    "mbpp_id": 869,
    "problem_statement": "Write a function to remove sublists from a given list of lists, which are outside a given range.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_list_range(lst, start, end):\n    return [sublist for sublist in lst if start <= len(sublist) <= end]",
    "test_cases": [
      "assert remove_list_range([[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]],13,17)==[[13, 14, 15, 17]]",
      "assert remove_list_range([[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]],1,3)==[[2], [1, 2, 3]]",
      "assert remove_list_range([[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]],0,7)==[[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7]]"
    ]
  },
  {
    "mbpp_id": 870,
    "problem_statement": "Write a function to calculate the sum of the positive numbers of a given list of numbers using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_positivenum(numbers):\n    return sum(x for x in numbers if x > 0)",
    "test_cases": [
      "assert sum_positivenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==48",
      "assert sum_positivenum([10,15,-14,13,-18,12,-20])==50",
      "assert sum_positivenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==522"
    ]
  },
  {
    "mbpp_id": 871,
    "problem_statement": "Write a python function to check whether the given strings are rotations of each other or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def are_Rotations(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    \n    # Concatenate string1 with itself and then compare with str2\n    concatenated = str1 + str1\n    return str2 in concatenated",
    "test_cases": [
      "assert are_Rotations(\"abc\",\"cba\") == False",
      "assert are_Rotations(\"abcd\",\"cdba\") == False",
      "assert are_Rotations(\"abacd\",\"cdaba\") == True"
    ]
  },
  {
    "mbpp_id": 872,
    "problem_statement": "Write a function to check if a nested list is a subset of another nested list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'reduce' is not defined",
      "Test 2: FAIL - name 'reduce' is not defined",
      "Test 3: FAIL - name 'reduce' is not defined"
    ],
    "generated_code": "def check_subset(subset, superset):\n    # Convert both lists into sets for comparison\n    return set(reduce(lambda x, y: x + y, subset)) == set(superset)",
    "test_cases": [
      "assert check_subset([[1, 3], [5, 7], [9, 11], [13, 15, 17]] ,[[1, 3],[13,15,17]])==True",
      "assert check_subset([[1, 2], [2, 3], [3, 4], [5, 6]],[[3, 4], [5, 6]])==True",
      "assert check_subset([[[1, 2], [2, 3]], [[3, 4], [5, 7]]],[[[3, 4], [5, 6]]])==False"
    ]
  },
  {
    "mbpp_id": 873,
    "problem_statement": "Write a function to solve the fibonacci sequence using recursion.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def fibonacci(n):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
    "test_cases": [
      "assert fibonacci(7) == 13",
      "assert fibonacci(8) == 21",
      "assert fibonacci(9) == 34"
    ]
  },
  {
    "mbpp_id": 874,
    "problem_statement": "Write a python function to check if the string is a concatenation of another string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_Concat(str1, str2):\n    # Concatenate str1 with itself to get a potential match for str2\n    concatenated = str1 * 2\n    \n    # Check if str2 can be found as a substring in the concatenated version of str1\n    if str2 in concatenated:\n        return True\n    else:\n        return False",
    "test_cases": [
      "assert check_Concat(\"abcabcabc\",\"abc\") == True",
      "assert check_Concat(\"abcab\",\"abc\") == False",
      "assert check_Concat(\"aba\",\"ab\") == False"
    ]
  },
  {
    "mbpp_id": 875,
    "problem_statement": "Write a function to find the minimum difference in the tuple pairs of given tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def min_difference(pairs):\n    # Find the minimum difference between elements in each pair\n    return min([abs(pair[0] - pair[1]) for pair in pairs])\n\n# Test cases\nassert min_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 1\nassert min_difference([(4, 6), (12, 8), (11, 4), (2, 13)]) == 2\nassert min_difference([(5, 17), (3, 9), (12, 5), (3, 24)]) == 6",
    "test_cases": [
      "assert min_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 1",
      "assert min_difference([(4, 6), (12, 8), (11, 4), (2, 13)]) == 2",
      "assert min_difference([(5, 17), (3, 9), (12, 5), (3, 24)]) == 6"
    ]
  },
  {
    "mbpp_id": 876,
    "problem_statement": "Write a python function to find lcm of two positive integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def lcm(x, y):\n    z = x * y\n    while(True):\n        if((z % x == 0) and (z % y == 0)):\n            lcm = z\n            break\n        z += 1\n    return lcm\n\n# Test cases\nprint(lcm(4,6))   # Expected output: 12\nprint(lcm(15,17)) # Expected output: 255\nprint(lcm(2,6))   # Expected output: 6",
    "test_cases": [
      "assert lcm(4,6) == 12",
      "assert lcm(15,17) == 255",
      "assert lcm(2,6) == 6"
    ]
  },
  {
    "mbpp_id": 877,
    "problem_statement": "Write a python function to sort the given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sort_String(input_string):\n    # Convert the input string into a list of characters\n    char_list = list(input_string)\n    \n    # Sort the list of characters\n    char_list.sort()\n    \n    # Join the sorted list back into a string and return it\n    return ''.join(char_list)\n\n# Test cases\nprint(sort_String(\"cba\"))   # Expected output: abc\nprint(sort_String(\"data\"))  # Expected output: aadt\nprint(sort_String(\"zxy\"))   # Expected output: xyz",
    "test_cases": [
      "assert sort_String(\"cba\") == \"abc\"",
      "assert sort_String(\"data\") == \"aadt\"",
      "assert sort_String(\"zxy\") == \"xyz\""
    ]
  },
  {
    "mbpp_id": 878,
    "problem_statement": "Write a function to check if the given tuple contains only k elements.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_tuples(input_tuple, required_elements):\n    # Check if the input_tuple has exactly as many unique elements as required_elements\n    if len(set(input_tuple)) == len(required_elements):\n        return True\n    else:\n        return False",
    "test_cases": [
      "assert check_tuples((3, 5, 6, 5, 3, 6),[3, 6, 5]) == True",
      "assert check_tuples((4, 5, 6, 4, 6, 5),[4, 5, 6]) == True",
      "assert check_tuples((9, 8, 7, 6, 8, 9),[9, 8, 1]) == False"
    ]
  },
  {
    "mbpp_id": 879,
    "problem_statement": "Write a function that matches a string that has an 'a' followed by anything, ending in 'b' by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef text_match(text):\n    # Define the regex pattern to find strings with 'a' followed by anything and ending in 'b'\n    pattern = r'a.*b$'\n    \n    # Use re.search to find if the pattern is found in the given text\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n# Test cases\nprint(text_match(\"aabbbbd\"))  # Expected output: Not matched!\nprint(text_match(\"aabAbbbc\"))  # Expected output: Not matched!\nprint(text_match(\"accddbbjjjb\"))  # Expected output: Found a match!",
    "test_cases": [
      "assert text_match(\"aabbbbd\") == 'Not matched!'",
      "assert text_match(\"aabAbbbc\") == 'Not matched!'",
      "assert text_match(\"accddbbjjjb\") == 'Found a match!'"
    ]
  },
  {
    "mbpp_id": 880,
    "problem_statement": "Write a python function to find number of solutions in quadratic equation.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Check_Solution' is not defined",
      "Test 2: FAIL - name 'Check_Solution' is not defined",
      "Test 3: FAIL - name 'Check_Solution' is not defined"
    ],
    "generated_code": "def check_solution(a, b, c):\n    # Calculate discriminant\n    d = (b**2) - (4*a*c)\n    \n    # If discriminant is negative, no real solutions\n    if d < 0:\n        return \"No solutions\"\n    \n    # If discriminant is zero, one real solution\n    elif d == 0:\n        return \"1 solution\"\n    \n    # If discriminant is positive, two distinct real solutions\n    else:\n        return f\"{d} solutions\"",
    "test_cases": [
      "assert Check_Solution(2,5,2) == \"2 solutions\"",
      "assert Check_Solution(1,1,1) == \"No solutions\"",
      "assert Check_Solution(1,2,1) == \"1 solution\""
    ]
  },
  {
    "mbpp_id": 881,
    "problem_statement": "Write a function to find the sum of first even and odd number of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\n\ndef sum_even_odd(lst: List[int]) -> int:\n    sum_evens = sum(i for i in lst if i % 2 == 0)\n    sum_odds = sum(i for i in lst if i % 2 != 0)\n    return sum_evens + sum_odds",
    "test_cases": [
      "assert sum_even_odd([1,3,5,7,4,1,6,8])==5",
      "assert sum_even_odd([1,2,3,4,5,6,7,8,9,10])==3",
      "assert sum_even_odd([1,5,7,9,10])==11"
    ]
  },
  {
    "mbpp_id": 882,
    "problem_statement": "Write a function to caluclate perimeter of a parallelogram.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def parallelogram_perimeter(base, height):\n    return base * height * 2",
    "test_cases": [
      "assert parallelogram_perimeter(10,20)==400",
      "assert parallelogram_perimeter(15,20)==600",
      "assert parallelogram_perimeter(8,9)==144"
    ]
  },
  {
    "mbpp_id": 883,
    "problem_statement": "Write a function to find numbers divisible by m and n from a list of numbers using lambda function.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "div_of_nums = lambda nums, m, n: [num for num in nums if num % m == 0 and num % n == 0]",
    "test_cases": [
      "assert div_of_nums([19, 65, 57, 39, 152, 639, 121, 44, 90, 190],2,4)==[ 152,44]",
      "assert div_of_nums([1, 2, 3, 5, 7, 8, 10],2,5)==[10]",
      "assert div_of_nums([10,15,14,13,18,12,20],10,5)==[10,20]"
    ]
  },
  {
    "mbpp_id": 884,
    "problem_statement": "Write a python function to check whether all the bits are within a given range or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def all_Bits_Set_In_The_Given_Range(n, low_bit, high_bit):\n    mask = ~(~low_bit | high_bit)\n    return n & mask == n",
    "test_cases": [
      "assert all_Bits_Set_In_The_Given_Range(10,2,1) == True ",
      "assert all_Bits_Set_In_The_Given_Range(5,2,4) == False",
      "assert all_Bits_Set_In_The_Given_Range(22,2,3) == True "
    ]
  },
  {
    "mbpp_id": 885,
    "problem_statement": "Write a python function to check whether the two given strings are isomorphic to each other or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_Isomorphic(str1, str2):\n    # If lengths of both strings are different, they can't be isomorphic\n    if len(str1) != len(str2):\n        return False\n    \n    mapping_str1_to_str2 = {}\n    mapping_str2_to_str1 = {}\n    \n    for char1, char2 in zip(str1, str2):\n        # Check if characters map correctly from one string to another\n        if char1 in mapping_str1_to_str2 and mapping_str1_to_str2[char1] != char2:\n            return False\n        if char2 in mapping_str2_to_str1 and mapping_str2_to_str1[char2] != char1:\n            return False\n        \n        # Update mappings with current character pair\n        mapping_str1_to_str2[char1] = char2\n        mapping_str2_to_str1[char2] = char1\n    \n    return True",
    "test_cases": [
      "assert is_Isomorphic(\"paper\",\"title\") == True",
      "assert is_Isomorphic(\"ab\",\"ba\") == True",
      "assert is_Isomorphic(\"ab\",\"aa\") == False"
    ]
  },
  {
    "mbpp_id": 886,
    "problem_statement": "Write a function to add all the numbers in a list and divide it with the length of the list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_num(nums):\n    \"\"\"\n    Adds all the elements in the list 'nums' together.\n    \n    Args:\n    nums (list): A list containing numerical values.\n    \n    Returns:\n    float: The average of all the elements in the list.\n    \"\"\"\n    return sum(nums) / len(nums)\n\n# Check function with provided data points\nassert abs(sum_num([8, 2, 3, 0, 7]) - 4.0) < 1e-6\nassert abs(sum_num([-10, -20, -30]) - (-20.0)) < 1e-6\nassert abs(sum_num([19, 15, 18]) - 17.333333333333332) < 1e-6\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert sum_num((8, 2, 3, 0, 7))==4.0",
      "assert sum_num((-10,-20,-30))==-20.0",
      "assert sum_num((19,15,18))==17.333333333333332"
    ]
  },
  {
    "mbpp_id": 887,
    "problem_statement": "Write a python function to check whether the given number is odd or not using bitwise operator.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_odd(num):\n    # Use bitwise AND operation with 1 to check if the least significant bit is 1\n    return num & 1 == 1",
    "test_cases": [
      "assert is_odd(5) == True",
      "assert is_odd(6) == False",
      "assert is_odd(7) == True"
    ]
  },
  {
    "mbpp_id": 888,
    "problem_statement": "Write a function to substract the elements of the given nested tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def substract_elements(tup1, tup2):\n    # Use map and zip to iterate over both tuples simultaneously,\n    # subtracting corresponding elements from tuple1 with elements from tuple2.\n    result = list(map(lambda x, y: (x[0] - y[0], x[1] - y[1]), tup1, tup2))\n    return result",
    "test_cases": [
      "assert substract_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((-5, -4), (1, -4), (1, 8), (-6, 7))",
      "assert substract_elements(((13, 4), (14, 6), (13, 10), (12, 11)), ((19, 8), (14, 10), (12, 2), (18, 4))) == ((-6, -4), (0, -4), (1, 8), (-6, 7))",
      "assert substract_elements(((19, 5), (18, 7), (19, 11), (17, 12)), ((12, 9), (17, 11), (13, 3), (19, 5))) == ((7, -4), (1, -4), (6, 8), (-2, 7))"
    ]
  },
  {
    "mbpp_id": 889,
    "problem_statement": "Write a function to reverse each list in a given list of lists.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def reverse_list_lists(lst):\n    return [lst[i][::-1] for i in range(len(lst))]",
    "test_cases": [
      "assert reverse_list_lists([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])==[[4, 3, 2, 1], [8, 7, 6, 5], [12, 11, 10, 9], [16, 15, 14, 13]]",
      "assert reverse_list_lists([[1,2],[2,3],[3,4]])==[[2,1],[3,2],[4,3]]",
      "assert reverse_list_lists([[10,20],[30,40]])==[[20,10],[40,30]]"
    ]
  },
  {
    "mbpp_id": 890,
    "problem_statement": "Write a python function to find the index of an extra element present in one sorted array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: list index out of range"
    ],
    "generated_code": "def find_Extra(arr1, arr2, n): \n    # Find the length of both arrays\n    len1 = len(arr1)\n    len2 = len(arr2)\n\n    # Iterate through the first array until we find the difference\n    for i in range(len1):\n        if arr1[i] != arr2[i]:\n            return i \n\n# Test cases to verify the solution\nassert find_Extra([1,2,3,4],[1,2,3],3) == 3\nassert find_Extra([2,4,6,8,10],[2,4,6,8],4) == 4\nassert find_Extra([1,3,5,7,9,11],[1,3,5,7,9],5) == 5",
    "test_cases": [
      "assert find_Extra([1,2,3,4],[1,2,3],3) == 3",
      "assert find_Extra([2,4,6,8,10],[2,4,6,8],4) == 4",
      "assert find_Extra([1,3,5,7,9,11],[1,3,5,7,9],5) == 5"
    ]
  },
  {
    "mbpp_id": 891,
    "problem_statement": "Write a python function to check whether the given two numbers have same number of digits or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def same_Length(num1, num2):\n    # Convert numbers to strings and compare their lengths\n    return len(str(num1)) == len(str(num2))",
    "test_cases": [
      "assert same_Length(12,1) == False",
      "assert same_Length(2,2) == True",
      "assert same_Length(10,20) == True"
    ]
  },
  {
    "mbpp_id": 892,
    "problem_statement": "Write a function to remove multiple spaces in a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_spaces(s):\n    # Splitting the string into words using whitespace as delimiter and then joining them back together\n    return ' '.join(s.split())\n\n# Test cases\nprint(remove_spaces('python  program'))  # Expected output: \"python program\"\nprint(remove_spaces('python   programming    language'))  # Expected output: \"python programming language\"\nprint(remove_spaces('python                     program'))  # Expected output: \"python program\"",
    "test_cases": [
      "assert remove_spaces('python  program')==('python program')",
      "assert remove_spaces('python   programming    language')==('python programming language')",
      "assert remove_spaces('python                     program')==('python program')"
    ]
  },
  {
    "mbpp_id": 893,
    "problem_statement": "Write a python function to get the last element of each sublist.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Extract' is not defined",
      "Test 2: FAIL - name 'Extract' is not defined",
      "Test 3: FAIL - name 'Extract' is not defined"
    ],
    "generated_code": "def extract(lst):\n    \"\"\"\n    This function takes a list of lists as input and returns a new list containing the last elements of each sublist.\n    \n    :param lst: List of lists where each sublist contains integers.\n    :return: A list containing the last element from each sublist in the original list.\n    \"\"\"\n    # Extracting the last elements of each sublist\n    result = [sublist[-1] for sublist in lst]\n    return result",
    "test_cases": [
      "assert Extract([[1, 2, 3], [4, 5], [6, 7, 8, 9]]) == [3, 5, 9]",
      "assert Extract([['x', 'y', 'z'], ['m'], ['a', 'b'], ['u', 'v']]) == ['z', 'm', 'b', 'v']",
      "assert Extract([[1, 2, 3], [4, 5]]) == [3, 5]"
    ]
  },
  {
    "mbpp_id": 894,
    "problem_statement": "Write a function to convert the given string of float type into tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def float_to_tuple(s):\n    # Splitting the input string by comma and converting each element to float\n    elements = [float(x) for x in s.split(\", \")]\n    # Returning the list as a tuple\n    return tuple(elements)\n\n# Test cases\nprint(float_to_tuple(\"1.2, 1.3, 2.3, 2.4, 6.5\"))  # Should return (1.2, 1.3, 2.3, 2.4, 6.5)\nprint(float_to_tuple(\"2.3, 2.4, 5.6, 5.4, 8.9\"))  # Should return (2.3, 2.4, 5.6, 5.4, 8.9)\nprint(float_to_tuple(\"0.3, 0.5, 7.8, 9.4\"))      # Should return (0.3, 0.5, 7.8, 9.4)",
    "test_cases": [
      "assert float_to_tuple(\"1.2, 1.3, 2.3, 2.4, 6.5\") == (1.2, 1.3, 2.3, 2.4, 6.5)",
      "assert float_to_tuple(\"2.3, 2.4, 5.6, 5.4, 8.9\") == (2.3, 2.4, 5.6, 5.4, 8.9)",
      "assert float_to_tuple(\"0.3, 0.5, 7.8, 9.4\") == (0.3, 0.5, 7.8, 9.4)"
    ]
  },
  {
    "mbpp_id": 895,
    "problem_statement": "Write a function to find the maximum sum of subsequences of given array with no adjacent elements.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_sum_subseq(nums):\n    incl = 0  # Sum including the previous element\n    excl = 0  # Sum excluding the previous element\n    \n    for i in nums:\n        new_excl = min(incl, excl)  # New exclude value is minimum of excluding the last included item and excluding both include and exclude\n        incl = excl + i  # Update include as it now includes the current item\n        excl = new_excl  # Update exclude as it was previously excluded but can now be included\n        \n    return max(excl, incl)  # Return the maximum of inclusion/exclusion values",
    "test_cases": [
      "assert max_sum_subseq([1, 2, 9, 4, 5, 0, 4, 11, 6]) == 26",
      "assert max_sum_subseq([1, 2, 9, 5, 6, 0, 5, 12, 7]) == 28",
      "assert max_sum_subseq([1, 3, 10, 5, 6, 0, 6, 14, 21]) == 44"
    ]
  },
  {
    "mbpp_id": 896,
    "problem_statement": "Write a function to sort a list in increasing order by the last element in each tuple from a given list of non-empty tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sort_list_last(tuples):\n    # Sort the list of tuples based on the second element of each tuple\n    return sorted(tuples, key=lambda x: x[1])",
    "test_cases": [
      "assert sort_list_last([(2, 5), (1, 2), (4, 4), (2, 3), (2, 1)])==[(2, 1), (1, 2), (2, 3), (4, 4), (2, 5)] ",
      "assert sort_list_last([(9,8), (4, 7), (3,5), (7,9), (1,2)])==[(1,2), (3,5), (4,7), (9,8), (7,9)] ",
      "assert sort_list_last([(20,50), (10,20), (40,40)])==[(10,20),(40,40),(20,50)] "
    ]
  },
  {
    "mbpp_id": 897,
    "problem_statement": "Write a python function to check whether the word is present in a given sentence or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'is_Word_Present' is not defined",
      "Test 2: FAIL - name 'is_Word_Present' is not defined",
      "Test 3: FAIL - name 'is_Word_Present' is not defined"
    ],
    "generated_code": "def is_word_present(sentence, word):\n    \"\"\"\n    Checks if the word is present in the sentence.\n    \n    Parameters:\n        sentence (str): The sentence in which to search for the word.\n        word (str): The word to search for within the sentence.\n        \n    Returns:\n        bool: True if the word is found in the sentence, False otherwise.\n    \"\"\"\n    # Splitting the sentence into words and checking if the specified word exists in it.\n    return word in sentence.split()\n\n# Example usage and test cases\nprint(is_word_present(\"machine learning\", \"machine\"))   # Expected output: True\nprint(is_word_present(\"easy\", \"fun\"))                   # Expected output: False\nprint(is_word_present(\"python language\", \"code\"))       # Expected output: False",
    "test_cases": [
      "assert is_Word_Present(\"machine learning\",\"machine\") == True",
      "assert is_Word_Present(\"easy\",\"fun\") == False",
      "assert is_Word_Present(\"python language\",\"code\") == False"
    ]
  },
  {
    "mbpp_id": 898,
    "problem_statement": "Write a function to extract specified number of elements from a given list, which follow each other continuously.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def extract_elements(input_list, n):\n    return input_list[n-1:-n+1]\n\n# Test cases\nprint(extract_elements([1, 1, 3, 4, 4, 5, 6, 7], 2)) # Expected output: [1, 4]\nprint(extract_elements([0, 1, 2, 3, 4, 4, 4, 4, 5, 7], 4)) # Expected output: [4]\nprint(extract_elements([0,0,0,0,0], 5)) # Expected output: [0]",
    "test_cases": [
      "assert extract_elements([1, 1, 3, 4, 4, 5, 6, 7],2)==[1, 4]",
      "assert extract_elements([0, 1, 2, 3, 4, 4, 4, 4, 5, 7],4)==[4]",
      "assert extract_elements([0,0,0,0,0],5)==[0]"
    ]
  },
  {
    "mbpp_id": 899,
    "problem_statement": "Write a python function to check whether an array can be sorted or not by picking only the corner elements.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check(arr, n):\n    count = 0\n    i = 0\n    while i < n - 1 and arr[i] <= arr[i + 1]:\n        i += 1\n    if i == n - 1:\n        return False\n    \n    j = n - 1\n    while j > 0 and arr[j] >= arr[j - 1]:\n        j -= 1\n    if j == 0:\n        return False\n    \n    k = max(i, j)\n    \n    for m in range(k, len(arr)):\n        if arr[m] <= arr[k - 1]:\n            return False\n        elif arr[m] >= arr[k]:\n            break\n    \n    return True",
    "test_cases": [
      "assert check([3,2,1,2,3,4],6) == True",
      "assert check([2,1,4,5,1],5) == True",
      "assert check([1,2,2,1,2,3],6) == True"
    ]
  },
  {
    "mbpp_id": 900,
    "problem_statement": "Write a function where a string will start with a specific number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef match_num(string):\n    \"\"\"\n    This function checks if the given string starts with 'num' followed by a digit.\n    \n    Parameters:\n    - string (str): The input string to check.\n    \n    Returns:\n    - bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match strings starting with 'num' followed by a digit\n    pattern = r'^num\\d+$'\n    return bool(re.match(pattern, string))\n\n# Test cases to verify the correctness of the function\nprint(match_num('5-2345861'))  # Expected output: True\nprint(match_num('6-2345861'))  # Expected output: False\nprint(match_num('78910'))      # Expected output: False",
    "test_cases": [
      "assert match_num('5-2345861')==True",
      "assert match_num('6-2345861')==False",
      "assert match_num('78910')==False"
    ]
  },
  {
    "mbpp_id": 901,
    "problem_statement": "Write a function to find the smallest multiple of the first n numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "import math\n\ndef smallest_multiple(n):\n    # Calculate the product of all integers from 1 to n and divide it by their greatest common divisor (GCD)\n    return int((math.prod(range(1, n+1))) / gcd(math.prod(range(1, n+1)), math.prod(range(1, n))))\n\n# Function to calculate GCD using Euclidean algorithm\nfrom functools import reduce\nfrom operator import mul\n\ndef gcd(*args):\n    return reduce(mul, args) // math.gcd(*args)\n\n# Test cases\nassert smallest_multiple(13) == 360360\nassert smallest_multiple(2) == 2\nassert smallest_multiple(1) == 1",
    "test_cases": [
      "assert smallest_multiple(13)==360360",
      "assert smallest_multiple(2)==2",
      "assert smallest_multiple(1)==1"
    ]
  },
  {
    "mbpp_id": 902,
    "problem_statement": "Write a function to combine two dictionaries by adding values for common keys.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def add_dict(dict1, dict2):\n    combined = {**dict1, **dict2}\n    return combined",
    "test_cases": [
      "assert add_dict({'a': 100, 'b': 200, 'c':300},{'a': 300, 'b': 200, 'd':400})==({'b': 400, 'd': 400, 'a': 400, 'c': 300}) ",
      "assert add_dict({'a': 500, 'b': 700, 'c':900},{'a': 500, 'b': 600, 'd':900})==({'b': 1300, 'd': 900, 'a': 1000, 'c': 900}) ",
      "assert add_dict({'a':900,'b':900,'d':900},{'a':900,'b':900,'d':900})==({'b': 1800, 'd': 1800, 'a': 1800})"
    ]
  },
  {
    "mbpp_id": 903,
    "problem_statement": "Write a python function to count the total unset bits from 1 to n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'count_Unset_Bits' is not defined",
      "Test 2: FAIL - name 'count_Unset_Bits' is not defined",
      "Test 3: FAIL - name 'count_Unset_Bits' is not defined"
    ],
    "generated_code": "def count_unset_bits(n):\n    \"\"\"\n    Counts the total number of unset bits in the binary representation of numbers from 1 to n.\n    \n    Args:\n    - n (int): The upper limit till which the count of unset bits is to be calculated\n    \n    Returns:\n    - int: Total number of unset bits in the range [1, n]\n    \"\"\"\n    total_unsets = sum(bin(i).count('1') for i in range(1, n+1))\n    return total_unsets\n\n# Check function with provided data points\nprint(count_unset_bits(2))  # Expected output: 1\nprint(count_unset_bits(5))  # Expected output: 4\nprint(count_unset_bits(14)) # Expected output: 17",
    "test_cases": [
      "assert count_Unset_Bits(2) == 1",
      "assert count_Unset_Bits(5) == 4",
      "assert count_Unset_Bits(14) == 17"
    ]
  },
  {
    "mbpp_id": 904,
    "problem_statement": "Write a function to return true if the given number is even else return false.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def even_num(n):\n    # Check if n divided by 2 has no remainder\n    return n % 2 == 0",
    "test_cases": [
      "assert even_num(13.5)==False",
      "assert even_num(0)==True",
      "assert even_num(-9)==False"
    ]
  },
  {
    "mbpp_id": 905,
    "problem_statement": "Write a python function to find the sum of squares of binomial co-efficients.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def sum_of_square(n):\n    # Initialize result as 0 for the empty list and set the initial value of n^2.\n    result = [0]\n    \n    # Calculate the square of each number from 1 to n-1.\n    for i in range(1, n):\n        result.append(result[-1] + i**2)\n    \n    # Return the last element which is the sum of squares up to n.\n    return result[-1]\n\n# Test the function with provided data points\nassert sum_of_square(4) == 70\nassert sum_of_square(5) == 252\nassert sum_of_square(2) == 6\n\nprint(\"All tests passed.\")",
    "test_cases": [
      "assert sum_of_square(4) == 70",
      "assert sum_of_square(5) == 252",
      "assert sum_of_square(2) == 6"
    ]
  },
  {
    "mbpp_id": 906,
    "problem_statement": "Write a function to extract year, month and date from a url by using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef extract_date(url):\n    pattern = r'(\\d{4})-(\\d{1,2})-(\\d{1,2})'\n    match = re.search(pattern, url)\n    if match:\n        year = match.group(1)\n        month = match.group(2)\n        day = match.group(3)\n        return [(year, month, day)]\n    else:\n        return []\n\n# Test Cases\nprint(extract_date(\"https://www.washingtonpost.com/news/football-insider/wp/2016/09/02/odell-beckhams-fame-rests-on-one-stupid-little-ball-josh-norman-tells-author/\")) # [('2016', '09', '02')]\nprint(extract_date(\"https://www.indiatoday.in/movies/celebrities/story/wp/2020/11/03/odeof-sushant-singh-rajput-s-death-his-brother-in-law-shares-advice-for-fans-1749646/\")) # [('2020', '11', '03')]\nprint(extract_date(\"https://economictimes.indiatimes.com/news/economy/2020/12/29/finance/pension-assets-under-pfrda-touch-rs-5-32-lakh-crore/articleshow/79736619.cms\")) # [('2020', '12', '29')]",
    "test_cases": [
      "assert extract_date(\"https://www.washingtonpost.com/news/football-insider/wp/2016/09/02/odell-beckhams-fame-rests-on-one-stupid-little-ball-josh-norman-tells-author/\") == [('2016', '09', '02')]",
      "assert extract_date(\"https://www.indiatoday.in/movies/celebrities/story/wp/2020/11/03/odeof-sushant-singh-rajput-s-death-his-brother-in-law-shares-advice-for-fans-1749646/\") == [('2020', '11', '03')]",
      "assert extract_date(\"https://economictimes.indiatimes.com/news/economy/2020/12/29/finance/pension-assets-under-pfrda-touch-rs-5-32-lakh-crore/articleshow/79736619.cms\") == [('2020', '12', '29')]"
    ]
  },
  {
    "mbpp_id": 907,
    "problem_statement": "Write a function to print the first n lucky numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def lucky_num(n):\n    result = []\n    for i in range(1, 4 * n + 1):\n        if i % 6 == 1 or i % 6 == 5:\n            result.append(i)\n    return result[:n]",
    "test_cases": [
      "assert lucky_num(10)==[1, 3, 7, 9, 13, 15, 21, 25, 31, 33] ",
      "assert lucky_num(5)==[1, 3, 7, 9, 13]",
      "assert lucky_num(8)==[1, 3, 7, 9, 13, 15, 21, 25]"
    ]
  },
  {
    "mbpp_id": 908,
    "problem_statement": "Write a function to find the fixed point in the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - find_fixed_point() takes 1 positional argument but 2 were given",
      "Test 2: FAIL - find_fixed_point() takes 1 positional argument but 2 were given",
      "Test 3: FAIL - find_fixed_point() takes 1 positional argument but 2 were given"
    ],
    "generated_code": "def find_fixed_point(arr):\n    # Iterate through the array and check for a fixed point\n    for i in range(len(arr)):\n        if arr[i] == i:\n            return i\n    return -1  # Return -1 if no fixed point is found",
    "test_cases": [
      "assert find_fixed_point([-10, -1, 0, 3, 10, 11, 30, 50, 100],9) == 3",
      "assert find_fixed_point([1, 2, 3, 4, 5, 6, 7, 8],8) == -1",
      "assert find_fixed_point([0, 2, 5, 8, 17],5) == 0"
    ]
  },
  {
    "mbpp_id": 909,
    "problem_statement": "Write a function to find the previous palindrome of a specified number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def previous_palindrome(n):\n    # Convert the number to string for easy manipulation\n    n_str = str(n)\n    \n    # Check if the number is odd and ends with '5'\n    if len(n_str) % 2 != 0 and n_str[-1] == '5':\n        # Subtract 1 from all digits except the last one and convert back to integer\n        return int(''.join(str(int(digit) - 1) if i != len(n_str) - 1 else digit for i, digit in enumerate(n_str)))\n    else:\n        # If not an odd number ending in '5', just subtract 1 from the entire number\n        return n - 1",
    "test_cases": [
      "assert previous_palindrome(99)==88",
      "assert previous_palindrome(1221)==1111",
      "assert previous_palindrome(120)==111"
    ]
  },
  {
    "mbpp_id": 910,
    "problem_statement": "Write a function to validate a gregorian date.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - unsupported operand type(s) for //: 'str' and 'int'"
    ],
    "generated_code": "def check_date(day, month, year):\n    \"\"\"\n    This function checks if the given date is valid according to the Gregorian calendar.\n    \n    Args:\n        day (int): The day of the month.\n        month (int): The month of the year.\n        year (int): The year.\n        \n    Returns:\n        bool: True if the date is valid, False otherwise.\n    \"\"\"\n    # Check if it's a leap year\n    def is_leap_year(year):\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n    \n    # Convert year to century part\n    century = year // 100\n    \n    # Calculate whether the year is a leap year based on its century part\n    leap_year_check = century * 100 + year % 100\n    \n    # Calculate the adjusted number of days for February in non-leap years and leap years\n    days_in_month = [31, 28 + int(is_leap_year(leap_year_check)), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Validate the date\n    if not (day in range(1, days_in_month[month-1] + 1) and month in range(1, 13)):\n        return False\n    else:\n        return True",
    "test_cases": [
      "assert check_date(11,11,2002)==True",
      "assert check_date(13,11,2002)==False",
      "assert check_date('11','11','2002')==True"
    ]
  },
  {
    "mbpp_id": 911,
    "problem_statement": "Write a function to compute maximum product of three numbers of a given array of integers using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: can't multiply sequence by non-int of type 'list'"
    ],
    "generated_code": "from heapq import nlargest\n\ndef maximum_product(nums):\n    # Extract the top 3 largest numbers and calculate their product.\n    # Since the smallest number could potentially be one of these, \n    # we also extract the next two largest numbers which could become the smallest if they were negative.\n    return max(nlargest(3, nums) * nlargest(-2, nums)[:2])\n\n# Test cases\nprint(maximum_product([12, 74, 9, 50, 61, 41]))  # Expected output: 225700\nprint(maximum_product([25, 35, 22, 85, 14, 65, 75, 25, 58]))  # Expected output: 414375\nprint(maximum_product([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1]))  # Expected output: 2520",
    "test_cases": [
      "assert maximum_product( [12, 74, 9, 50, 61, 41])==225700",
      "assert maximum_product([25, 35, 22, 85, 14, 65, 75, 25, 58])==414375",
      "assert maximum_product([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1])==2520"
    ]
  },
  {
    "mbpp_id": 912,
    "problem_statement": "Write a function to find ln, m lobb number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def lobb_num(int_n, int_k):\n    if int_n < int_k:\n        return 0\n    \n    if int_n == int_k:\n        return 1\n    \n    total = 1\n    for i in range(int_n - int_k + 1, int_n + 1):\n        total *= i\n    return total",
    "test_cases": [
      "assert int(lobb_num(5, 3)) == 35",
      "assert int(lobb_num(3, 2)) == 5",
      "assert int(lobb_num(4, 2)) == 20"
    ]
  },
  {
    "mbpp_id": 913,
    "problem_statement": "Write a function to check for a number at the end of a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def end_num(s):\n    return s[-1].isdigit()",
    "test_cases": [
      "assert end_num('abcdef')==False",
      "assert end_num('abcdef7')==True",
      "assert end_num('abc')==False"
    ]
  },
  {
    "mbpp_id": 914,
    "problem_statement": "Write a python function to check whether the given string is made up of two alternating characters or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_Two_Alter(s):\n    if len(set(s)) == 1:\n        return True\n    elif 'a' in s and s[0] != 'b':\n        return True\n    elif 'b' in s and s[0] != 'a':\n        return True\n    else:\n        return False",
    "test_cases": [
      "assert is_Two_Alter(\"abab\") == True",
      "assert is_Two_Alter(\"aaaa\") == False",
      "assert is_Two_Alter(\"xyz\") == False"
    ]
  },
  {
    "mbpp_id": 915,
    "problem_statement": "Write a function to rearrange positive and negative numbers in a given array using lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def rearrange_numbs(nums):\n    return sorted(nums, key=lambda x: x > 0)\n\n# Test cases\nprint(rearrange_numbs([-1, 2, -3, 5, 7, 8, 9, -10])) # [2, 5, 7, 8, 9, -10, -3, -1]\nprint(rearrange_numbs([10,15,14,13,-18,12,-20]))     # [10, 12, 13, 14, 15, -20, -18]\nprint(rearrange_numbs([-20,20,-10,10,-30,30]))      # [10, 20, 30, -30, -20, -10]",
    "test_cases": [
      "assert rearrange_numbs([-1, 2, -3, 5, 7, 8, 9, -10])==[2, 5, 7, 8, 9, -10, -3, -1]",
      "assert rearrange_numbs([10,15,14,13,-18,12,-20])==[10, 12, 13, 14, 15, -20, -18]",
      "assert rearrange_numbs([-20,20,-10,10,-30,30])==[10, 20, 30, -30, -20, -10]"
    ]
  },
  {
    "mbpp_id": 916,
    "problem_statement": "Write a function to find if there is a triplet in the array whose sum is equal to a given value.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_triplet_array(arr, target_sum, length):\n    arr.sort() # Sort the array for faster searching\n    \n    n = len(arr)\n    \n    for i in range(n-2): \n        left = i + 1  \n        right = n - 1\n        \n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            \n            if current_sum == target_sum:\n                return (arr[i], arr[left], arr[right])\n            elif current_sum < target_sum:\n                left += 1\n            else:\n                right -= 1\n                \n    return None",
    "test_cases": [
      "assert find_triplet_array([1, 4, 45, 6, 10, 8], 6, 22) == (4, 10, 8)",
      "assert find_triplet_array([12, 3, 5, 2, 6, 9], 6, 24) == (12, 3, 9)",
      "assert find_triplet_array([1, 2, 3, 4, 5], 5, 9) == (1, 3, 5)"
    ]
  },
  {
    "mbpp_id": 917,
    "problem_statement": "Write a function to find the sequences of one upper case letter followed by lower case letters.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'text_uppercase_lowercase' is not defined",
      "Test 2: FAIL - name 'text_uppercase_lowercase' is not defined",
      "Test 3: FAIL - name 'text_uppercase_lowercase' is not defined"
    ],
    "generated_code": "def find_uppercase(text):\n    for i in range(len(text) - 1):\n        if text[i] == text[i].upper() and text[i + 1].islower():\n            return 'Found a match!'\n    return 'Not matched!'",
    "test_cases": [
      "assert text_uppercase_lowercase(\"AaBbGg\")==('Found a match!')",
      "assert text_uppercase_lowercase(\"aA\")==('Not matched!')",
      "assert text_uppercase_lowercase(\"PYTHON\")==('Not matched!')"
    ]
  },
  {
    "mbpp_id": 918,
    "problem_statement": "Write a function to count coin change.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - list index out of range"
    ],
    "generated_code": "def coin_change(coins, target, current_value=0):\n    if target == 0:\n        return 1\n    elif target < 0 or current_value > target:\n        return 0\n    else:\n        # Try including coins[current_value] in the total and move on with remaining money\n        include = coin_change(coins, target - coins[current_value], current_value)\n        exclude = coin_change(coins, target, current_value + 1)\n        return include + exclude",
    "test_cases": [
      "assert coin_change([1, 2, 3],3,4)==4",
      "assert coin_change([4,5,6,7,8,9],6,9)==2",
      "assert coin_change([4,5,6,7,8,9],6,4)==1"
    ]
  },
  {
    "mbpp_id": 919,
    "problem_statement": "Write a python function to multiply all items in the list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def multiply_list(lst):\n    result = 1\n    for i in lst:\n        result *= i\n    return result",
    "test_cases": [
      "assert multiply_list([1,-2,3]) == -6",
      "assert multiply_list([1,2,3,4]) == 24",
      "assert multiply_list([3,1,2,3]) == 18"
    ]
  },
  {
    "mbpp_id": 920,
    "problem_statement": "Write a function to remove all tuples with all none values in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'remove_tuple' is not defined",
      "Test 2: FAIL - name 'remove_tuple' is not defined",
      "Test 3: FAIL - name 'remove_tuple' is not defined"
    ],
    "generated_code": "def remove_none_values(tuples_list):\n    result = [tup for tup in tuples_list if not all(item is None for item in tup)]\n    return result",
    "test_cases": [
      "assert remove_tuple([(None, 2), (None, None), (3, 4), (12, 3), (None, )] ) == '[(None, 2), (3, 4), (12, 3)]'",
      "assert remove_tuple([(None, None), (None, None), (3, 6), (17, 3), (None,1 )] ) == '[(3, 6), (17, 3), (None, 1)]'",
      "assert remove_tuple([(1, 2), (2, None), (3, None), (24, 3), (None, None )] ) == '[(1, 2), (2, None), (3, None), (24, 3)]'"
    ]
  },
  {
    "mbpp_id": 921,
    "problem_statement": "Write a function to perform chunking of tuples each of size n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def chunk_tuples(input_tuple, tuple_size):\n    # Calculate the number of chunks needed for the input_tuple divided by tuple_size\n    num_chunks = len(input_tuple) // tuple_size\n    \n    # Slice the input_tuple into equal-sized chunks and return them as a list\n    return [input_tuple[i*tuple_size:(i+1)*tuple_size] for i in range(num_chunks)]\n\n# Test cases\nprint(chunk_tuples((10, 4, 5, 6, 7, 6, 8, 3, 4), 3))  # Expected output: [(10, 4, 5), (6, 7, 6), (8, 3, 4)]\nprint(chunk_tuples((1, 2, 3, 4, 5, 6, 7, 8, 9), 2))   # Expected output: [(1, 2), (3, 4), (5, 6), (7, 8), (9,)]\nprint(chunk_tuples((11, 14, 16, 17, 19, 21, 22, 25), 4))  # Expected output: [(11, 14, 16, 17), (19, 21, 22, 25)]",
    "test_cases": [
      "assert chunk_tuples((10, 4, 5, 6, 7, 6, 8, 3, 4), 3) == [(10, 4, 5), (6, 7, 6), (8, 3, 4)]",
      "assert chunk_tuples((1, 2, 3, 4, 5, 6, 7, 8, 9), 2) == [(1, 2), (3, 4), (5, 6), (7, 8), (9,)]",
      "assert chunk_tuples((11, 14, 16, 17, 19, 21, 22, 25), 4) == [(11, 14, 16, 17), (19, 21, 22, 25)]"
    ]
  },
  {
    "mbpp_id": 922,
    "problem_statement": "Write a function to find a pair with the highest product from a given array of integers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_product(arr):\n    # Find all unique pairs and their products\n    unique_pairs = [(arr[i], arr[j]) for i in range(len(arr)) for j in range(i+1, len(arr))]\n    \n    # Sort the list of pairs based on the sum of their elements\n    unique_pairs.sort(key=lambda x: x[0] + x[1])\n    \n    # Return the pair with the largest product\n    return max(unique_pairs, key=lambda x: x[0]*x[1])\n\n# Example usage:\nprint(max_product([1, 2, 3, 4, 7, 0, 8, 4]))  # Output should be (7, 8)",
    "test_cases": [
      "assert max_product([1, 2, 3, 4, 7, 0, 8, 4])==(7, 8)",
      "assert max_product([0, -1, -2, -4, 5, 0, -6])==(-4, -6)",
      "assert max_product([1, 3, 5, 6, 8, 9])==(8,9)"
    ]
  },
  {
    "mbpp_id": 923,
    "problem_statement": "Write a function to find the length of the shortest string that has both str1 and str2 as subsequences.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def super_seq(str1, str2, n, m):\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[n][m]\n\n# Test cases\nprint(super_seq(\"AGGTAB\", \"GXTXAYB\", 6, 7))  # Expected output: 9\nprint(super_seq(\"feek\", \"eke\", 4, 3))       # Expected output: 5\nprint(super_seq(\"PARRT\", \"RTA\", 5, 3))      # Expected output: 6",
    "test_cases": [
      "assert super_seq(\"AGGTAB\", \"GXTXAYB\", 6, 7) == 9",
      "assert super_seq(\"feek\", \"eke\", 4, 3) == 5",
      "assert super_seq(\"PARRT\", \"RTA\", 5, 3) == 6"
    ]
  },
  {
    "mbpp_id": 924,
    "problem_statement": "Write a function to find maximum of two numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def max_of_two(x, y):\n    return x if x >= y else y",
    "test_cases": [
      "assert max_of_two(10,20)==20",
      "assert max_of_two(19,15)==19",
      "assert max_of_two(-10,-20)==-10"
    ]
  },
  {
    "mbpp_id": 925,
    "problem_statement": "Write a python function to calculate the product of all the numbers of a given tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def mutiple_tuple(tup):\n    # Initialize the result variable\n    result = 1\n    \n    # Iterate through each number in the tuple and multiply it with the result\n    for num in tup:\n        result *= num\n        \n    return result",
    "test_cases": [
      "assert mutiple_tuple((4, 3, 2, 2, -1, 18)) == -864",
      "assert mutiple_tuple((1,2,3)) == 6",
      "assert mutiple_tuple((-2,-4,-6)) == -48"
    ]
  },
  {
    "mbpp_id": 926,
    "problem_statement": "Write a function to find n-th rencontres number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - NameError: name 'representative' is not defined"
    ],
    "generated_code": "from math import factorial\n\ndef rencontres_number(n, k):\n    \"\"\"\n    This function calculates the rencontres number which represents the number of permutations of n items where no item appears in its original position.\n    \n    Args:\n    n (int): The total number of items.\n    k (int): The specific position we want to calculate the rencontres number for within these n items.\n    \n    Returns:\n    int: The rencontres number for the given n and k values.\n    \"\"\"\n    if k == 0:\n        return 1\n    else:\n        return ((factorial(n)) // ((n - k) * factorial(n - k)))\n\n# Check function with provided data points\nprint(representative(7, 2)) # Expected output: 924\nprint(representative(3, 0)) # Expected output: 2\nprint(representative(3, 1)) # Expected output: 3",
    "test_cases": [
      "assert rencontres_number(7, 2) == 924",
      "assert rencontres_number(3, 0) == 2",
      "assert rencontres_number(3, 1) == 3"
    ]
  },
  {
    "mbpp_id": 927,
    "problem_statement": "Write a function to calculate the height of the given binary tree.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_height(node):\n    if node is None:\n        return 0\n    else:\n        # Recursively find the maximum height in the left and right subtrees\n        left_height = max_height(node.left)\n        right_height = max_height(node.right)\n        \n        # The height of the current node is one more than the maximum of its two children\n        return max(left_height, right_height) + 1\n\n# Test cases\nroot = TreeNode(1,\n                TreeNode(2,\n                         TreeNode(4),\n                         TreeNode(5)),\n                TreeNode(3))\nprint(max_height(root))  # Expected output: 3\n\nroot1 = TreeNode(1,\n                 TreeNode(2,\n                          TreeNode(4,\n                                   TreeNode(8))),\n                 TreeNode(3,\n                          TreeNode(6)))\nprint(max_height(root1))  # Expected output: 5\n\nroot2 = TreeNode(1,\n                 TreeNode(2,\n                          TreeNode(4,\n                                   TreeNode(8)),\n                          TreeNode(5)),\n                 TreeNode(3,\n                          TreeNode(6)))\nprint(max_height(root2))  # Expected output: 4",
    "test_cases": [
      "assert (max_height(root)) == 3",
      "assert (max_height(root1)) == 5 ",
      "assert (max_height(root2)) == 4"
    ]
  },
  {
    "mbpp_id": 928,
    "problem_statement": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def change_date_format(date_str):\n    return date_str[6:] + '-' + date_str[:4] + '-' + date_str[4:6]",
    "test_cases": [
      "assert change_date_format('2026-01-02')=='02-01-2026'",
      "assert change_date_format('2021-01-04')=='04-01-2021'",
      "assert change_date_format('2030-06-06')=='06-06-2030'"
    ]
  },
  {
    "mbpp_id": 929,
    "problem_statement": "Write a function to count repeated items of a tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_tuplex(input_tuple, target_item):\n    return input_tuple.count(target_item)",
    "test_cases": [
      "assert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7),4)==3",
      "assert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7),2)==2",
      "assert count_tuplex((2, 4, 7, 7, 7, 3, 4, 4, 7),7)==4"
    ]
  },
  {
    "mbpp_id": 930,
    "problem_statement": "Write a function that matches a string that has an a followed by zero or more b's by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef text_match(text):\n    # Define the regex pattern to find strings with an a followed by zero or more b's\n    pattern = 'ab*'\n    \n    # Search for the pattern in the given text\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n# Test cases to verify the correctness of the function\nprint(text_match(\"msb\"))       # Expected output: \"Not matched!\"\nprint(text_match(\"a0c\"))       # Expected output: \"Found a match!\"\nprint(text_match(\"abbc\"))      # Expected output: \"Found a match!\"",
    "test_cases": [
      "assert text_match(\"msb\") == 'Not matched!'",
      "assert text_match(\"a0c\") == 'Found a match!'",
      "assert text_match(\"abbc\") == 'Found a match!'"
    ]
  },
  {
    "mbpp_id": 931,
    "problem_statement": "Write a function to calculate the sum of series 1³+2³+3³+….+n³.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_series(n):\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += pow(i, 3)\n    return total_sum",
    "test_cases": [
      "assert sum_series(7)==784",
      "assert sum_series(5)==225",
      "assert sum_series(15)==14400"
    ]
  },
  {
    "mbpp_id": 932,
    "problem_statement": "Write a function to remove duplicate words from a given list of strings.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_duplic_list(words):\n    return list(set(words))\n\n# Test cases\nprint(remove_duplic_list([\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\"])) # ['Python', 'Exercises', 'Practice', 'Solution']\nprint(remove_duplic_list([\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\",\"Java\"])) # ['Python', 'Exercises', 'Practice', 'Solution', 'Java']\nprint(remove_duplic_list([\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\",\"C++\",\"C\",\"C++\"])) # ['Python', 'Exercises', 'Practice', 'Solution','C++','C']",
    "test_cases": [
      "assert remove_duplic_list([\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\"])==['Python', 'Exercises', 'Practice', 'Solution']",
      "assert remove_duplic_list([\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\",\"Java\"])==['Python', 'Exercises', 'Practice', 'Solution', 'Java']",
      "assert remove_duplic_list([\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\",\"C++\",\"C\",\"C++\"])==['Python', 'Exercises', 'Practice', 'Solution','C++','C']"
    ]
  },
  {
    "mbpp_id": 933,
    "problem_statement": "Write a function to convert camel case string to snake case string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef camel_to_snake(string):\n    # Convert CamelCase to Snake Case\n    snake_case = re.sub(r'(?<!^)(?=[A-Z])', '_', string).lower()\n    return snake_case\n\n# Test cases\nprint(camel_to_snake('GoogleAssistant'))  # Output: google_assistant\nprint(camel_to_snake('ChromeCast'))      # Output: chrome_cast\nprint(camel_to_snake('QuadCore'))        # Output: quad_core",
    "test_cases": [
      "assert camel_to_snake('GoogleAssistant') == 'google_assistant'",
      "assert camel_to_snake('ChromeCast') == 'chrome_cast'",
      "assert camel_to_snake('QuadCore') == 'quad_core'"
    ]
  },
  {
    "mbpp_id": 934,
    "problem_statement": "Write a function to find the nth delannoy number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def dealnnoy_num(n, k):\n    \"\"\"\n    This function calculates the n-th Delannoy number given two integers n and k.\n    \n    Parameters:\n    n (int): The order of the Delannoy number.\n    k (int): The dimension of the Delannoy path.\n    \n    Returns:\n    int: The n-th Delannoy number.\n    \"\"\"\n    # Implementing the logic for calculating the Delannoy number using binomial coefficient formula\n    from math import comb\n    \n    def factorial(num):\n        result = 1\n        for i in range(1, num + 1):\n            result *= i\n        return result\n    \n    return (comb(k + n - 1, n) * comb(k, k - n)) // factorial(k)\n\n# Test cases to verify the correctness of the solution\nassert dealnnoy_num(3, 4) == 129\nassert dealnnoy_num(3, 3) == 63\nassert dealnnoy_num(4, 5) == 681\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert dealnnoy_num(3, 4) == 129",
      "assert dealnnoy_num(3, 3) == 63",
      "assert dealnnoy_num(4, 5) == 681"
    ]
  },
  {
    "mbpp_id": 935,
    "problem_statement": "Write a function to calculate the sum of series 1²+2²+3²+….+n².",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def series_sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 2\n    return total",
    "test_cases": [
      "assert series_sum(6)==91",
      "assert series_sum(7)==140",
      "assert series_sum(12)==650"
    ]
  },
  {
    "mbpp_id": 936,
    "problem_statement": "Write a function to re-arrange the given tuples based on the given ordered list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - KeyError: 5"
    ],
    "generated_code": "def re_arrange_tuples(tuples_list, order_list):\n    # Convert the order list into a dictionary for quick lookup of tuple indices\n    index_map = {item: i for i, item in enumerate(order_list)}\n    \n    # Sort the tuples using their index values from the order list\n    sorted_tuples = sorted(tuples_list, key=lambda x: index_map[x[0]])\n    \n    return sorted_tuples\n\n# Test cases to verify the correctness of the solution\nprint(re_arrange_tuples([(4, 3), (1, 9), (2, 10), (3, 2)], [1, 4, 2, 3]))  # Expected output: [(1, 9), (4, 3), (2, 10), (3, 2)]\nprint(re_arrange_tuples([(5, 4), (2, 10), (3, 11), (4, 3)], [3, 4, 2, 3]))  # Expected output: [(3, 11), (4, 3), (2, 10), (3, 11)]\nprint(re_arrange_tuples([(6, 3), (3, 8), (5, 7), (2, 4)], [2, 5, 3, 6]))  # Expected output: [(2, 4), (5, 7), (3, 8), (6, 3)]",
    "test_cases": [
      "assert re_arrange_tuples([(4, 3), (1, 9), (2, 10), (3, 2)],  [1, 4, 2, 3]) == [(1, 9), (4, 3), (2, 10), (3, 2)]",
      "assert re_arrange_tuples([(5, 4), (2, 10), (3, 11), (4, 3)],  [3, 4, 2, 3]) == [(3, 11), (4, 3), (2, 10), (3, 11)]",
      "assert re_arrange_tuples([(6, 3), (3, 8), (5, 7), (2, 4)],  [2, 5, 3, 6]) == [(2, 4), (5, 7), (3, 8), (6, 3)]"
    ]
  },
  {
    "mbpp_id": 937,
    "problem_statement": "Write a function to count the most common character in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - {'count': 1} is not in list",
      "Test 2: FAIL - {'count': 1} is not in list",
      "Test 3: FAIL - {'count': 1} is not in list"
    ],
    "generated_code": "def max_char(s):\n    # Dictionary to keep track of each character's occurrence and its first index\n    char_dict = {}\n    \n    for i, char in enumerate(s):\n        if char in char_dict:\n            continue\n        else:\n            char_dict[char] = {'count': 0, 'index': -1}\n        \n        if s.index(char) == i:\n            char_dict[char]['count'] += 1\n            char_dict[char]['index'] = i\n    \n    # Find the maximum occurrence value\n    max_count = max(char_dict.values(), key=lambda x: x['count'])['count']\n    \n    # Return the character with the highest occurrence\n    return list(char_dict.keys())[list(char_dict.values()).index({'count': max_count})]",
    "test_cases": [
      "assert max_char(\"hello world\")==('l')",
      "assert max_char(\"hello \")==('l')",
      "assert max_char(\"python pr\")==('p')"
    ]
  },
  {
    "mbpp_id": 938,
    "problem_statement": "Write a function to find three closest elements from three sorted arrays.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\nimport bisect\n\ndef find_closet(a1: List[int], b1: List[int], c1: List[int], target_a: int, target_b: int, target_c: int) -> tuple:\n    def is_close(a_val, b_val, c_val):\n        if abs(a_val - target_a) < abs(b_val - target_b) and abs(a_val - target_a) < abs(c_val - target_c):\n            return True\n        elif abs(b_val - target_b) < abs(c_val - target_c):\n            return True\n        else:\n            return False\n    \n    close = [None] * 3\n    for i in range(len(a1)):\n        pos_b = bisect.bisect_left(b1, target_a - a1[i])\n        pos_c = bisect.bisect_left(c1, target_a - a1[i])\n\n        for j in range(max(pos_b, 0), min(pos_b + len(b1), len(b1))):\n            if not is_close(a1[i], b1[j], c1[pos_c]):\n                continue\n            if close[0] == None or abs(close[0][0] - target_a) > abs(a1[i] - target_a):\n                close[0] = (a1[i], b1[j], c1[pos_c])\n        \n        for j in range(min(pos_b, len(b1)), max(pos_b, 0)-1, -1):\n            if not is_close(a1[i], b1[j-1], c1[pos_c-1]):\n                continue\n            if close[1] == None or abs(close[1][0] - target_a) > abs(a1[i] - target_a):\n                close[1] = (a1[i], b1[j-1], c1[pos_c-1])\n    \n    for i in range(2):\n        if close[i] == None:\n            close[i] = close[(i+1)%2]\n\n    return tuple(close)",
    "test_cases": [
      "assert find_closet([1, 4, 10],[2, 15, 20],[10, 12],3,3,2) == (10, 15, 10)",
      "assert find_closet([20, 24, 100],[2, 19, 22, 79, 800],[10, 12, 23, 24, 119],3,5,5) == (24, 22, 23)",
      "assert find_closet([2, 5, 11],[3, 16, 21],[11, 13],3,3,2) == (11, 16, 11)"
    ]
  },
  {
    "mbpp_id": 939,
    "problem_statement": "Write a function to sort a list of dictionaries using lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def sorted_models(model_list):\n    return sorted(model_list, key=lambda x: x['model'])",
    "test_cases": [
      "assert sorted_models([{'make':'Nokia', 'model':216, 'color':'Black'}, {'make':'Mi Max', 'model':2, 'color':'Gold'}, {'make':'Samsung', 'model': 7, 'color':'Blue'}])==[{'make': 'Nokia', 'model': 216, 'color': 'Black'}, {'make': 'Samsung', 'model': 7, 'color': 'Blue'}, {'make': 'Mi Max', 'model': 2, 'color': 'Gold'}]",
      "assert sorted_models([{'make':'Vivo', 'model':20,'color':'Blue'},{'make': 'oppo','model':17,'color':'Gold'},{'make':'Apple','model':11,'color':'red'}])==([{'make':'Vivo', 'model':20,'color':'Blue'},{'make': 'oppo','model':17,'color':'Gold'},{'make':'Apple','model':11,'color':'red'}])",
      "assert sorted_models([{'make':'micromax','model':40,'color':'grey'},{'make':'poco','model':60,'color':'blue'}])==([{'make':'poco','model':60,'color':'blue'},{'make':'micromax','model':40,'color':'grey'}])"
    ]
  },
  {
    "mbpp_id": 940,
    "problem_statement": "Write a function to sort the given array by using heap sort.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    \n    if left < n and arr[i] < arr[left]:\n        largest = left\n        \n    if right < n and arr[largest] < arr[right]:\n        largest = right\n        \n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n    \n    for i in range(n//2 - 1, -1, -1):\n        heapify(arr, n, i)\n        \n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n    \n    return arr\n\n# Test Cases\nprint(heap_sort([12, 2, 4, 5, 2, 3])) # Expected output: [2, 2, 3, 4, 5, 12]\nprint(heap_sort([32, 14, 5, 6, 7, 19])) # Expected output: [5, 6, 7, 14, 19, 32]\nprint(heap_sort([21, 15, 29, 78, 65])) # Expected output: [15, 21, 29, 65, 78]",
    "test_cases": [
      "assert heap_sort([12, 2, 4, 5, 2, 3]) == [2, 2, 3, 4, 5, 12]",
      "assert heap_sort([32, 14, 5, 6, 7, 19]) == [5, 6, 7, 14, 19, 32]",
      "assert heap_sort([21, 15, 29, 78, 65]) == [15, 21, 29, 65, 78]"
    ]
  },
  {
    "mbpp_id": 941,
    "problem_statement": "Write a function to count the elements in a list until an element is a tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_elim(lst):\n    i = 0\n    while i < len(lst):\n        if isinstance(lst[i], tuple):\n            return i\n        i += 1\n    return len(lst)",
    "test_cases": [
      "assert count_elim([10,20,30,(10,20),40])==3",
      "assert count_elim([10,(20,30),(10,20),40])==1",
      "assert count_elim([(10,(20,30,(10,20),40))])==0"
    ]
  },
  {
    "mbpp_id": 942,
    "problem_statement": "Write a function to check if any list element is present in the given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_element(main_list, search_list):\n    for item in main_list:\n        if item in search_list:\n            return True\n    return False",
    "test_cases": [
      "assert check_element((4, 5, 7, 9, 3),  [6, 7, 10, 11]) == True",
      "assert check_element((1, 2, 3, 4),  [4, 6, 7, 8, 9]) == True",
      "assert check_element((3, 2, 1, 4, 5),  [9, 8, 7, 6]) == False"
    ]
  },
  {
    "mbpp_id": 943,
    "problem_statement": "Write a function to combine two given sorted lists using heapq module.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from heapq import merge\n\ndef combine_lists(list1, list2):\n    return list(merge(list1, list2))",
    "test_cases": [
      "assert combine_lists([1, 3, 5, 7, 9, 11],[0, 2, 4, 6, 8, 10])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]",
      "assert combine_lists([1, 3, 5, 6, 8, 9], [2, 5, 7, 11])==[1,2,3,5,5,6,7,8,9,11]",
      "assert combine_lists([1,3,7],[2,4,6])==[1,2,3,4,6,7]"
    ]
  },
  {
    "mbpp_id": 944,
    "problem_statement": "Write a function to separate and print the numbers and their position of a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "TIMEOUT"
    ],
    "generated_code": "def num_position(input_string):\n    positions = []\n    i = 0\n    while True:\n        try:\n            # Find next number starting from current index 'i'\n            pos, num_str = input_string[:i].rfind(' '), input_string[i:i+5]\n            if num_str.isdigit():\n                positions.append((int(num_str), pos + len(str(i))))\n            i += len(num_str) + 1\n        except ValueError:\n            break\n    return positions[-1][1] - min(positions)[1]\n\n# Test cases\nprint(num_position(\"there are 70 flats in this apartment\"))  # Expected output: 10\nprint(num_position(\"every adult have 32 teeth\"))              # Expected output: 17\nprint(num_position(\"isha has 79 chocolates in her bag\"))       # Expected output: 9",
    "test_cases": [
      "assert num_position(\"there are 70 flats in this apartment\")==10",
      "assert num_position(\"every adult have 32 teeth\")==17",
      "assert num_position(\"isha has 79 chocolates in her bag\")==9"
    ]
  },
  {
    "mbpp_id": 945,
    "problem_statement": "Write a function to convert the given tuples into set.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def tuple_to_set(tup):\n    return set(tup)",
    "test_cases": [
      "assert tuple_to_set(('x', 'y', 'z') ) == {'y', 'x', 'z'}",
      "assert tuple_to_set(('a', 'b', 'c') ) == {'c', 'a', 'b'}",
      "assert tuple_to_set(('z', 'd', 'e') ) == {'d', 'e', 'z'}"
    ]
  },
  {
    "mbpp_id": 946,
    "problem_statement": "Write a function to find the most common elements and their counts of a specified text.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from collections import Counter\n\ndef most_common_elem(text, n=5):\n    return Counter(text).most_common(n)\n\n# Test cases\nprint(most_common_elem('lkseropewdssafsdfafkpwe',3)) # Expected output: [('s', 4), ('e', 3), ('f', 3)]\nprint(most_common_elem('lkseropewdssafsdfafkpwe',2)) # Expected output: [('s', 4), ('e', 3)]\nprint(most_common_elem('lkseropewdssafsdfafkpwe',7)) # Expected output: [('s', 4), ('e', 3), ('f', 3), ('k', 2), ('p', 2), ('w', 2), ('d', 2)]",
    "test_cases": [
      "assert most_common_elem('lkseropewdssafsdfafkpwe',3)==[('s', 4), ('e', 3), ('f', 3)] ",
      "assert most_common_elem('lkseropewdssafsdfafkpwe',2)==[('s', 4), ('e', 3)]",
      "assert most_common_elem('lkseropewdssafsdfafkpwe',7)==[('s', 4), ('e', 3), ('f', 3), ('k', 2), ('p', 2), ('w', 2), ('d', 2)]"
    ]
  },
  {
    "mbpp_id": 947,
    "problem_statement": "Write a python function to find the length of the shortest word.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def len_log(words):\n    # Calculate the length of each word and return the minimum length found.\n    return min([len(word) for word in words])",
    "test_cases": [
      "assert len_log([\"win\",\"lose\",\"great\"]) == 3",
      "assert len_log([\"a\",\"ab\",\"abc\"]) == 1",
      "assert len_log([\"12\",\"12\",\"1234\"]) == 2"
    ]
  },
  {
    "mbpp_id": 948,
    "problem_statement": "Write a function to get an item of a tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def get_item(tup, index):\n    if not isinstance(index, int) or abs(index) > len(tup):\n        raise IndexError(\"Index out of range\")\n    \n    return tup[index]",
    "test_cases": [
      "assert get_item((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),3)==('e')",
      "assert get_item((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),-4)==('u')",
      "assert get_item((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),-3)==('r')"
    ]
  },
  {
    "mbpp_id": 949,
    "problem_statement": "Write a function to sort the given tuple list basis the total digits in tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: invalid literal for int() with base 10: '('"
    ],
    "generated_code": "def sort_list(tuples_list):\n    return sorted(tuples_list, key=lambda x: sum(int(digit) for digit in str(x)))\n\n# Test cases\nprint(sort_list([(3, 4, 6, 723), (1, 2), (12345,), (134, 234, 34)]))  # [(1, 2), (12345,), (3, 4, 6, 723), (134, 234, 34)]\nprint(sort_list([(3, 4, 8), (1, 2), (1234335,), (1345, 234, 334)]))  # [(1, 2), (3, 4, 8), (1234335,), (1345, 234, 334)]\nprint(sort_list([(34, 4, 61, 723), (1, 2), (145,), (134, 23)]))  # [(1, 2), (145,), (134, 23), (34, 4, 61, 723)]",
    "test_cases": [
      "assert sort_list([(3, 4, 6, 723), (1, 2), (12345,), (134, 234, 34)] ) == '[(1, 2), (12345,), (3, 4, 6, 723), (134, 234, 34)]'",
      "assert sort_list([(3, 4, 8), (1, 2), (1234335,), (1345, 234, 334)] ) == '[(1, 2), (3, 4, 8), (1234335,), (1345, 234, 334)]'",
      "assert sort_list([(34, 4, 61, 723), (1, 2), (145,), (134, 23)] ) == '[(1, 2), (145,), (134, 23), (34, 4, 61, 723)]'"
    ]
  },
  {
    "mbpp_id": 950,
    "problem_statement": "Write a function to display sign of the chinese zodiac for given year.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - list index out of range"
    ],
    "generated_code": "def chinese_zodiac(year):\n    months = [\"Monkey\", \"Rooster\", \"Dog\"]\n    return months[(year - 1900) % 12]",
    "test_cases": [
      "assert chinese_zodiac(1997)==('Ox')",
      "assert chinese_zodiac(1998)==('Tiger')",
      "assert chinese_zodiac(1994)==('Dog')"
    ]
  },
  {
    "mbpp_id": 951,
    "problem_statement": "Write a function to find the maximum of similar indices in two lists of tuples.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def max_similar_indices(list1, list2):\n    result = []\n    for i, j in zip(list1, list2):\n        if i[0] == j[0]:\n            result.append((i, j))\n    return result\n\n# Test cases\nprint(max_similar_indices([(2, 4), (6, 7), (5, 1)], [(5, 4), (8, 10), (8, 14)])) # Output: [(5, 4), (8, 10), (8, 14)]\nprint(max_similar_indices([(3, 5), (7, 8), (6, 2)], [(6, 5), (9, 11), (9, 15)])) # Output: [(6, 5), (9, 11), (9, 15)]\nprint(max_similar_indices([(4, 6), (8, 9), (7, 3)], [(7, 6), (10, 12), (10, 16)])) # Output: [(7, 6), (10, 12), (10, 16)]",
    "test_cases": [
      "assert max_similar_indices([(2, 4), (6, 7), (5, 1)],[(5, 4), (8, 10), (8, 14)]) == [(5, 4), (8, 10), (8, 14)]",
      "assert max_similar_indices([(3, 5), (7, 8), (6, 2)],[(6, 5), (9, 11), (9, 15)]) == [(6, 5), (9, 11), (9, 15)]",
      "assert max_similar_indices([(4, 6), (8, 9), (7, 3)],[(7, 6), (10, 12), (10, 16)]) == [(7, 6), (10, 12), (10, 16)]"
    ]
  },
  {
    "mbpp_id": 952,
    "problem_statement": "Write a function to compute the value of ncr mod p.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - ValueError: base is not invertible for the given modulus"
    ],
    "generated_code": "def factorial(n, mod): \n    fact = [1] * (n+1)\n    for i in range(2, n + 1): \n        fact[i] = (fact[i-1]*i)%mod \n\n    return fact[n]\n\ndef nCr_mod_p(n, k, m): \n    result = pow(factorial(n, m), -1, m)*pow(factorial(k, m), -1, m)*(factorial(n-k, m))%m\n    if result < 0:\n        result += m\n    return result % m\n\n# Test cases\nprint(nCr_mod_p(10, 2, 13))  # Expected output: 6\nprint(nCr_mod_p(11, 3, 14))  # Expected output: 11\nprint(nCr_mod_p(18, 14, 19))  # Expected output: 1",
    "test_cases": [
      "assert nCr_mod_p(10, 2, 13) == 6",
      "assert nCr_mod_p(11, 3, 14) == 11",
      "assert nCr_mod_p(18, 14, 19) == 1"
    ]
  },
  {
    "mbpp_id": 953,
    "problem_statement": "Write a python function to find the minimun number of subsets with distinct elements.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from collections import Counter\n\ndef subset(nums, k):\n    # Count the frequency of each element in nums\n    freq = Counter(nums)\n    \n    count = sum(v > 1 for v in freq.values())\n    \n    if count == len(freq) - 1:\n        return len(freq)\n    else:\n        return min(len(freq), k)\n\n# Test cases\nprint(subset([1, 2, 3, 4], 4))  # Output: 1\nprint(subset([5, 6, 9, 3, 4, 3, 4], 7))  # Output: 2\nprint(subset([1, 2, 3], 3))  # Output: 1",
    "test_cases": [
      "assert subset([1, 2, 3, 4],4) == 1",
      "assert subset([5, 6, 9, 3, 4, 3, 4],7) == 2",
      "assert subset([1, 2, 3 ],3) == 1"
    ]
  },
  {
    "mbpp_id": 954,
    "problem_statement": "Write a function that gives profit amount if the given amount has profit else return none.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def profit_amount(sale_price, cost_price):\n    # Calculate profit amount\n    profit = sale_price - cost_price\n    \n    # Return profit if it's positive, otherwise return None\n    return profit if profit > 0 else None",
    "test_cases": [
      "assert profit_amount(1500,1200)==300",
      "assert profit_amount(100,200)==None",
      "assert profit_amount(2000,5000)==None"
    ]
  },
  {
    "mbpp_id": 955,
    "problem_statement": "Write a function to find out, if the given number is abundant.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_abundant(num):\n    divisors_sum = sum([i for i in range(1, num) if num % i == 0])\n    return divisors_sum > num",
    "test_cases": [
      "assert is_abundant(12)==True",
      "assert is_abundant(13)==False",
      "assert is_abundant(9)==False"
    ]
  },
  {
    "mbpp_id": 956,
    "problem_statement": "Write a function to split the given string at uppercase letters by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef split_list(s):\n    # Splitting the input string by capturing sequences of characters that start with an uppercase letter followed by zero or more lowercase letters.\n    return re.split('(?<!^)(?=[A-Z][a-z]+)', s)\n\n# Test cases to verify the correctness of the function\nassert split_list(\"LearnToBuildAnythingWithGoogle\") == ['Learn', 'To', 'Build', 'Anything', 'With', 'Google']\nassert split_list(\"ApmlifyingTheBlack+DeveloperCommunity\") == ['Apmlifying', 'The', 'Black+', 'Developer', 'Community']\nassert split_list(\"UpdateInTheGoEcoSystem\") == ['Update', 'In', 'The', 'Go', 'Eco', 'System']",
    "test_cases": [
      "assert split_list(\"LearnToBuildAnythingWithGoogle\") == ['Learn', 'To', 'Build', 'Anything', 'With', 'Google']",
      "assert split_list(\"ApmlifyingTheBlack+DeveloperCommunity\") == ['Apmlifying', 'The', 'Black+', 'Developer', 'Community']",
      "assert split_list(\"UpdateInTheGoEcoSystem\") == ['Update', 'In', 'The', 'Go', 'Eco', 'System']"
    ]
  },
  {
    "mbpp_id": 957,
    "problem_statement": "Write a python function to get the position of rightmost set bit.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_First_Set_Bit_Pos(num):\n    # Loop through bits from the least significant bit until finding the first one\n    for i in range(num.bit_length(), -1, -1):\n        if num & (1 << i):  # Check if ith bit is set (i.e., equal to 1)\n            return i\n    return None  # Return None if there are no set bits in the number",
    "test_cases": [
      "assert get_First_Set_Bit_Pos(12) == 3",
      "assert get_First_Set_Bit_Pos(18) == 2",
      "assert get_First_Set_Bit_Pos(16) == 5"
    ]
  },
  {
    "mbpp_id": 958,
    "problem_statement": "Write a function to convert an integer into a roman numeral.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def int_to_roman(num):\n    # Define the Roman numerals and their corresponding values\n    rom_val = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), \n               (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n               (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    \n    # Initialize variables\n    result = ''\n    i = 0\n    \n    # Convert number to Roman numeral\n    while num > 0:\n        for rnum, roman in rom_val[i:]:\n            if num >= rnum:\n                result += roman\n                num -= rnum\n                break\n        else:\n            i += 1\n            \n    return result",
    "test_cases": [
      "assert int_to_roman(1)==(\"I\")",
      "assert int_to_roman(50)==(\"L\")",
      "assert int_to_roman(4)==(\"IV\")"
    ]
  },
  {
    "mbpp_id": 959,
    "problem_statement": "Write a python function to find the average of a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Average' is not defined",
      "Test 2: FAIL - name 'Average' is not defined",
      "Test 3: FAIL - name 'Average' is not defined"
    ],
    "generated_code": "def average(numbers):\n    # Calculate the sum of all numbers in the list\n    total = sum(numbers)\n    \n    # Calculate the number of elements in the list\n    count = len(numbers)\n    \n    # Compute the average and round it to two decimal places\n    result = round(total / count, 2)\n    \n    return result",
    "test_cases": [
      "assert Average([15, 9, 55, 41, 35, 20, 62, 49]) == 35.75",
      "assert Average([4, 5, 1, 2, 9, 7, 10, 8]) == 5.75",
      "assert Average([1,2,3]) == 2"
    ]
  },
  {
    "mbpp_id": 960,
    "problem_statement": "Write a function to solve tiling problem.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_noOfways(n):\n    # Initialize an array with size n+1 and set first two values to 1\n    ways = [1, 1] + [0] * n\n    \n    # Calculate number of ways for each value from 2 to n\n    for i in range(2, n + 1):\n        ways[i] = ways[i - 1] + ways[i - 2]\n    \n    return ways[n]\n\n# Test cases\nprint(get_noOfways(4))   # Expected output: 3\nprint(get_noOfways(3))   # Expected output: 2\nprint(get_noOfways(5))   # Expected output: 5",
    "test_cases": [
      "assert get_noOfways(4)==3",
      "assert get_noOfways(3)==2",
      "assert get_noOfways(5)==5"
    ]
  },
  {
    "mbpp_id": 961,
    "problem_statement": "Write a function to convert a roman numeral to an integer.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def roman_to_int(s):\n    # Define Roman numerals and their corresponding values\n    rom_val = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    \n    # Initialize total value and previous value\n    num = 0\n    prev = 0\n    \n    # Iterate through each character in the string from right to left\n    for char in reversed(s):\n        if char not in rom_val:\n            return None  # Invalid character found\n        \n        # Get the current value of the character\n        cur_val = rom_val[char]\n        \n        # If current value is greater than or equal to previous value,\n        # add it to the total value; otherwise, subtract it.\n        if cur_val >= prev:\n            num += cur_val\n        else:\n            num -= cur_val\n        \n        # Update previous value\n        prev = cur_val\n    \n    return num",
    "test_cases": [
      "assert roman_to_int('MMMCMLXXXVI')==3986",
      "assert roman_to_int('MMMM')==4000",
      "assert roman_to_int('C')==100"
    ]
  },
  {
    "mbpp_id": 962,
    "problem_statement": "Write a python function to find the sum of all even natural numbers within the range l and r.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_Even(l, r):\n    # Initialize the total sum\n    total_sum = 0\n    \n    # Iterate from 'l' to 'r', checking if each number is even\n    for num in range(l, r+1):\n        if num % 2 == 0:\n            total_sum += num\n            \n    return total_sum",
    "test_cases": [
      "assert sum_Even(2,5) == 6",
      "assert sum_Even(3,8) == 18",
      "assert sum_Even(4,6) == 10"
    ]
  },
  {
    "mbpp_id": 963,
    "problem_statement": "Write a function to calculate the discriminant value.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - math domain error",
      "Test 3: FAIL - float division by zero"
    ],
    "generated_code": "def discriminant_value(a, b, c):\n    # Calculate the discriminant using the formula: -b + sqrt(b^2-4ac) / 2a and -b - sqrt(b^2-4ac) / 2a \n    from math import sqrt\n    d = (-b + sqrt(b**2-4*a*c)) / (2*a), (-b - sqrt(b**2-4*a*c)) / (2*a)\n    \n    if isinstance(d[0], complex):\n        return (\"no real solution\", abs(d[0].real))\n    elif isinstance(d[0], float):\n        return (\"one solution\", abs(d[0]))\n    else:\n        return \"Two solutions\", abs(d[0])",
    "test_cases": [
      "assert discriminant_value(4,8,2)==(\"Two solutions\",32)",
      "assert discriminant_value(5,7,9)==(\"no real solution\",-131)",
      "assert discriminant_value(0,0,9)==(\"one solution\",0)"
    ]
  },
  {
    "mbpp_id": 964,
    "problem_statement": "Write a python function to check whether the length of the word is even or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def word_len(word):\n    # Check if the length of the word is even\n    return len(word) % 2 == 0",
    "test_cases": [
      "assert word_len(\"program\") == False",
      "assert word_len(\"solution\") == True",
      "assert word_len(\"data\") == True"
    ]
  },
  {
    "mbpp_id": 965,
    "problem_statement": "Write a function to convert camel case string to snake case string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def camel_to_snake(s):\n    import re\n    return re.sub(r'(?<!^)(?=[A-Z])', '_', s).lower()",
    "test_cases": [
      "assert camel_to_snake('PythonProgram')==('python_program')",
      "assert camel_to_snake('pythonLanguage')==('python_language')",
      "assert camel_to_snake('ProgrammingLanguage')==('programming_language')"
    ]
  },
  {
    "mbpp_id": 966,
    "problem_statement": "Write a function to remove an empty tuple from a list of tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def remove_empty(lst):\n    # Remove empty tuples from the list and return the modified list\n    return [t for t in lst if t]",
    "test_cases": [
      "assert remove_empty([(), (), ('',), ('a', 'b'), ('a', 'b', 'c'), ('d')])==[('',), ('a', 'b'), ('a', 'b', 'c'), 'd']  ",
      "assert remove_empty([(), (), ('',), (\"python\"), (\"program\")])==[('',), (\"python\"), (\"program\")]  ",
      "assert remove_empty([(), (), ('',), (\"java\")])==[('',),(\"java\") ]  "
    ]
  },
  {
    "mbpp_id": 967,
    "problem_statement": "Write a python function to accept the strings which contains all vowels.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check(s):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count_vowels = sum(1 for char in s.lower() if char in vowels)\n    \n    return 'accepted' if count_vowels == len(vowels) else 'not accepted'",
    "test_cases": [
      "assert check(\"SEEquoiaL\") == 'accepted'",
      "assert check('program') == \"not accepted\"",
      "assert check('fine') == \"not accepted\""
    ]
  },
  {
    "mbpp_id": 968,
    "problem_statement": "Write a python function to find maximum possible value for the given periodic function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def floor_Max(n, m, p):\n    # Calculate the minimum of n and max(m, p)\n    return min(n, max(m, p))",
    "test_cases": [
      "assert floor_Max(11,10,9) == 9",
      "assert floor_Max(5,7,4) == 2",
      "assert floor_Max(2,2,1) == 1"
    ]
  },
  {
    "mbpp_id": 969,
    "problem_statement": "Write a function to join the tuples if they have similar initial elements.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def join_tuples(tuples_list):\n    # Sort the list of tuples based on their first element\n    sorted_tuples = sorted(tuples_list)\n    \n    result = []\n    current_element = None\n    \n    for tuple in sorted_tuples:\n        if current_element is None or tuple[0] == current_element:\n            current_element = tuple[0]\n            result.append(tuple)\n        else:\n            break\n    \n    joined_tuples = [result[i:i+len(result)-i+1] for i in range(len(result)) if len(result) > i]\n    return [(element) for sublist in joined_tuples for element in sublist]\n\n# Test cases\nprint(join_tuples([(5, 6), (5, 7), (6, 8), (6, 10), (7, 13)]))  # Should return [(5, 6, 7), (6, 8, 10), (7, 13)]\nprint(join_tuples([(6, 7), (6, 8), (7, 9), (7, 11), (8, 14)]))   # Should return [(6, 7, 8), (7, 9, 11), (8, 14)]\nprint(join_tuples([(7, 8), (7, 9), (8, 10), (8, 12), (9, 15)]))  # Should return [(7, 8, 9), (8, 10, 12), (9, 15)]",
    "test_cases": [
      "assert join_tuples([(5, 6), (5, 7), (6, 8), (6, 10), (7, 13)] ) == [(5, 6, 7), (6, 8, 10), (7, 13)]",
      "assert join_tuples([(6, 7), (6, 8), (7, 9), (7, 11), (8, 14)] ) == [(6, 7, 8), (7, 9, 11), (8, 14)]",
      "assert join_tuples([(7, 8), (7, 9), (8, 10), (8, 12), (9, 15)] ) == [(7, 8, 9), (8, 10, 12), (9, 15)]"
    ]
  },
  {
    "mbpp_id": 970,
    "problem_statement": "Write a function to find minimum of two numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def min_of_two(a, b):\n    return a if a <= b else b",
    "test_cases": [
      "assert min_of_two(10,20)==10",
      "assert min_of_two(19,15)==15",
      "assert min_of_two(-10,-20)==-20"
    ]
  },
  {
    "mbpp_id": 971,
    "problem_statement": "Write a function to find the maximum number of segments of lengths a, b and c that can be formed from n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def maximum_segments(n, x, y, z):\n    # Calculate the sum of all possible segments\n    total_segments = x + y + z\n    \n    # If the total segments is less than or equal to the available units,\n    # we can form as many full segments as needed.\n    if total_segments <= n:\n        return n // max(x, min(y, z)) * max(x, min(y, z))\n    \n    # Otherwise, we cannot form any more segments because there's not enough remaining units after forming the largest segment possible with current values.\n    else:\n        return -1",
    "test_cases": [
      "assert maximum_segments(7, 5, 2, 5) == 2",
      "assert maximum_segments(17, 2, 1, 3) == 17",
      "assert maximum_segments(18, 16, 3, 6) == 6"
    ]
  },
  {
    "mbpp_id": 972,
    "problem_statement": "Write a function to concatenate the given two tuples to a nested tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def concatenate_nested(tuple1, tuple2):\n    # Concatenate the two tuples and convert them into a nested tuple\n    return ((i,) for i in (tuple1 + tuple2))\n\n# Test cases\nprint(list(concatenate_nested((3, 4), (5, 6))))  # Expected output: [(3,), (4,), (5,), (6,)]\nprint(list(concatenate_nested((1, 2), (3, 4))))  # Expected output: [(1,), (2,), (3,), (4,)]\nprint(list(concatenate_nested((4, 5), (6, 8))))  # Expected output: [(4,), (5,), (6,), (8,)]",
    "test_cases": [
      "assert concatenate_nested((3, 4), (5, 6)) == (3, 4, 5, 6)",
      "assert concatenate_nested((1, 2), (3, 4)) == (1, 2, 3, 4)",
      "assert concatenate_nested((4, 5), (6, 8)) == (4, 5, 6, 8)"
    ]
  },
  {
    "mbpp_id": 973,
    "problem_statement": "Write a python function to left rotate the string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def left_rotate(s,n):\n    # Ensure n is within the length of s for proper rotation\n    n = n % len(s)\n    return s[n:] + s[:n]",
    "test_cases": [
      "assert left_rotate(\"python\",2) == \"thonpy\"   ",
      "assert left_rotate(\"bigdata\",3 ) == \"databig\" ",
      "assert left_rotate(\"hadoop\",1 ) == \"adooph\" "
    ]
  },
  {
    "mbpp_id": 974,
    "problem_statement": "Write a function to find the minimum total path sum in the given triangle.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List\n\ndef min_sum_path(triangle: List[List[int]]) -> int:\n    # Add 0 at the beginning and end of each row for base conditions\n    for i in range(len(triangle)):\n        triangle[i].insert(0, 0)\n        triangle[i].append(0)\n    \n    # Start from the second last row and move upwards\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            # Update the current cell with the minimum value among its three possible paths\n            triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])\n    \n    # The first element now contains the minimum total path sum\n    return triangle[0][1]",
    "test_cases": [
      "assert min_sum_path([[ 2 ], [3, 9 ], [1, 6, 7 ]]) == 6",
      "assert min_sum_path([[ 2 ], [3, 7 ], [8, 5, 6 ]]) == 10 ",
      "assert min_sum_path([[ 3 ], [6, 4 ], [5, 2, 7 ]]) == 9"
    ]
  },
  {
    "mbpp_id": 511,
    "problem_statement": "Write a python function to find minimum sum of factors of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_Min_Sum(num):\n    # Initialize the minimum sum to a large number\n    min_sum = float('inf')\n    \n    # Iterate through all possible factors of num starting from 2\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            # Calculate the sum of factor pair (i, num // i)\n            current_sum = i + (num // i)\n            # Update the minimum sum if the current sum is smaller\n            if current_sum < min_sum:\n                min_sum = current_sum\n    \n    return min_sum",
    "test_cases": [
      "assert find_Min_Sum(12) == 7",
      "assert find_Min_Sum(105) == 15",
      "assert find_Min_Sum(2) == 2"
    ]
  },
  {
    "mbpp_id": 512,
    "problem_statement": "Write a function to count the element frequency in the mixed nested tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_element_freq(mixed_tuple):\n    freq_dict = {}\n    for item in mixed_tuple:\n        if isinstance(item, tuple):\n            for sub_item in item:\n                if sub_item not in freq_dict:\n                    freq_dict[sub_item] = 1\n                else:\n                    freq_dict[sub_item] += 1\n        elif item not in freq_dict:\n            freq_dict[item] = 1\n        else:\n            freq_dict[item] += 1\n    return freq_dict",
    "test_cases": [
      "assert count_element_freq((5, 6, (5, 6), 7, (8, 9), 9) ) == {5: 2, 6: 2, 7: 1, 8: 1, 9: 2}",
      "assert count_element_freq((6, 7, (6, 7), 8, (9, 10), 10) ) == {6: 2, 7: 2, 8: 1, 9: 1, 10: 2}",
      "assert count_element_freq((7, 8, (7, 8), 9, (10, 11), 11) ) == {7: 2, 8: 2, 9: 1, 10: 1, 11: 2}"
    ]
  },
  {
    "mbpp_id": 513,
    "problem_statement": "Write a function to convert tuple into list by adding the given string after every element.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - unsupported operand type(s) for +=: 'int' and 'str'",
      "Test 2: FAIL - unsupported operand type(s) for +=: 'int' and 'str'",
      "Test 3: FAIL - unsupported operand type(s) for +=: 'int' and 'str'"
    ],
    "generated_code": "def add_str(lst, str_to_add):\n    # Convert the input tuple to a list\n    lst = list(lst)\n    \n    # Add the specified string to each element of the list\n    for i in range(len(lst)):\n        lst[i] += str_to_add\n    \n    return lst",
    "test_cases": [
      "assert add_str((5, 6, 7, 4, 9) , \"FDF\") == [5, 'FDF', 6, 'FDF', 7, 'FDF', 4, 'FDF', 9, 'FDF']",
      "assert add_str((7, 8, 9, 10) , \"PF\") == [7, 'PF', 8, 'PF', 9, 'PF', 10, 'PF']",
      "assert add_str((11, 14, 12, 1, 4) , \"JH\") == [11, 'JH', 14, 'JH', 12, 'JH', 1, 'JH', 4, 'JH']"
    ]
  },
  {
    "mbpp_id": 514,
    "problem_statement": "Write a function to find the summation of tuple elements in the given tuple list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - 'int' object is not iterable",
      "Test 2: FAIL - 'int' object is not iterable",
      "Test 3: FAIL - 'int' object is not iterable"
    ],
    "generated_code": "def sum_elements(tuples_list):\n    total_sum = sum(element for tup in tuples_list for element in tup)\n    return total_sum\n\n# Test cases\nprint(sum_elements([(7, 8, 9, 1, 10, 7), (1, 2, 3, 4, 5, 6), (11, 12, 13, 45, 14)]))",
    "test_cases": [
      "assert sum_elements((7, 8, 9, 1, 10, 7)) == 42",
      "assert sum_elements((1, 2, 3, 4, 5, 6)) == 21",
      "assert sum_elements((11, 12 ,13 ,45, 14)) == 95"
    ]
  },
  {
    "mbpp_id": 515,
    "problem_statement": "Write a function to check if there is a subset with sum divisible by m.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def modular_sum(numbers, divisor, target_sum):\n    \"\"\"\n    Check if there exists a subset of 'numbers' whose sum is divisible by 'divisor'.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    divisor (int): The number by which we want to divide the sum of the subset.\n    target_sum (int): The desired remainder when divided by 'divisor'.\n    \n    Returns:\n    bool: True if such a subset exists, False otherwise.\n    \"\"\"\n    n = len(numbers)\n    # Initialize DP table with False values and rows with -1 for overflow handling\n    dp = [[False] * (target_sum + 1)] * (n + 1)\n    dp[0][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            # Case where we don't take the current element\n            dp[i][j] = dp[i-1][j]\n            # Case where we take the current element\n            if numbers[i-1] <= j:\n                dp[i][j] |= dp[i-1][j-numbers[i-1]]\n    \n    return dp[n][target_sum]\n\n# Example usage:\nprint(modular_sum([3, 1, 7, 5], 4, 6))  # Output: True\nprint(modular_sum([1, 7], 2, 5))        # Output: False\nprint(modular_sum([1, 6], 2, 5))        # Output: False",
    "test_cases": [
      "assert modular_sum([3, 1, 7, 5], 4, 6) == True",
      "assert modular_sum([1, 7], 2, 5) == False",
      "assert modular_sum([1, 6], 2, 5) == False"
    ]
  },
  {
    "mbpp_id": 516,
    "problem_statement": "Write a function to sort a list of elements using radix sort.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def radix_sort(arr):\n    # Find the maximum number to know the number of digits\n    max_num = max(arr)\n    \n    # Perform counting sort for every digit\n    exp = 1\n    while max_num // exp > 0:\n        counting_sort_by_digit(arr, exp)\n        exp *= 10\n    \n    return arr\n\ndef counting_sort_by_digit(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n    \n    for i in range(n):\n        index = arr[i] // exp\n        count[index % 10] += 1\n    \n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    \n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n    \n    for i in range(n):\n        arr[i] = output[i]\n\n# Test cases\nprint(radix_sort([15, 79, 25, 68, 37]))  # Output: [15, 25, 37, 68, 79]\nprint(radix_sort([9, 11, 8, 7, 3, 2]))   # Output: [2, 3, 7, 8, 9, 11]\nprint(radix_sort([36, 12, 24, 26, 29]))  # Output: [12, 24, 26, 29, 36]",
    "test_cases": [
      "assert radix_sort([15, 79, 25, 68, 37]) == [15, 25, 37, 68, 79]",
      "assert radix_sort([9, 11, 8, 7, 3, 2]) == [2, 3, 7, 8, 9, 11]",
      "assert radix_sort([36, 12, 24, 26, 29]) == [12, 24, 26, 29, 36]"
    ]
  },
  {
    "mbpp_id": 517,
    "problem_statement": "Write a python function to find the largest postive number from the given list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def largest_pos(lst):\n    max_num = lst[0] if lst else None\n    for num in lst:\n        if num > max_num:\n            max_num = num\n    return max_num\n\n# Test cases\nprint(largest_pos([1,2,3,4,-1]))  # Expected output: 4\nprint(largest_pos([0,1,2,-5,-1,6]))  # Expected output: 6\nprint(largest_pos([0,0,1,0]))  # Expected output: 1",
    "test_cases": [
      "assert largest_pos([1,2,3,4,-1]) == 4",
      "assert largest_pos([0,1,2,-5,-1,6]) == 6",
      "assert largest_pos([0,0,1,0]) == 1"
    ]
  },
  {
    "mbpp_id": 518,
    "problem_statement": "Write a function to find the square root of a perfect number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import math\n\ndef sqrt_root(num):\n    \"\"\"\n    This function takes an integer as input and returns its square root if it is a perfect square.\n    If the input number is not a perfect square, it returns None.\n    \n    :param num: Integer - The number whose square root needs to be found.\n    :return: float or None - The square root of num if it's a perfect square, otherwise None.\n    \"\"\"\n    if int(math.sqrt(num)) ** 2 == num:\n        return int(math.sqrt(num))\n    else:\n        return None",
    "test_cases": [
      "assert sqrt_root(4)==2",
      "assert sqrt_root(16)==4",
      "assert sqrt_root(400)==20"
    ]
  },
  {
    "mbpp_id": 519,
    "problem_statement": "Write a function to calculate volume of a tetrahedron.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - IndexError: list index out of range"
    ],
    "generated_code": "import math\n\ndef volume_tetrahedron(sides_a):\n    # Calculate the square root of 6 divided by the product of sides_a and their sum\n    return abs((math.sqrt(6) / ((sides_a[0] + sides_a[1] + sides_a[2]) * sides_a[3])))\n\n# Test cases\nprint(volume_tetrahedron([10]))  # Expected output: 117.85\nprint(volume_tetrahedron([15]))  # Expected output: 397.75\nprint(volume_tetrahedron([20]))  # Expected output: 942.81",
    "test_cases": [
      "assert volume_tetrahedron(10)==117.85",
      "assert volume_tetrahedron(15)==397.75",
      "assert volume_tetrahedron(20)==942.81"
    ]
  },
  {
    "mbpp_id": 520,
    "problem_statement": "Write a function to find the lcm of the given array elements.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def get_lcm(arr):\n    # Find the maximum value in the array\n    max_val = max(arr)\n    \n    # Calculate the product of all values in the array\n    prod = 1\n    for num in arr:\n        prod *= num\n    \n    # Return the product divided by the maximum value\n    return int(prod / max_val)\n\n# Test cases\nprint(get_lcm([2, 7, 3, 9, 4]))  # Expected output: 252\nprint(get_lcm([1, 2, 8, 3]))     # Expected output: 24\nprint(get_lcm([3, 8, 4, 10, 5])) # Expected output: 120",
    "test_cases": [
      "assert get_lcm([2, 7, 3, 9, 4]) == 252",
      "assert get_lcm([1, 2, 8, 3]) == 24",
      "assert get_lcm([3, 8, 4, 10, 5]) == 120"
    ]
  },
  {
    "mbpp_id": 521,
    "problem_statement": "Write a function to print check if the triangle is scalene or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_isosceles(a, b, c):\n    # Compare sides of the triangle\n    return len({a, b, c}) == 3",
    "test_cases": [
      "assert check_isosceles(6,8,12)==True",
      "assert check_isosceles(6,6,12)==False",
      "assert check_isosceles(6,15,20)==True"
    ]
  },
  {
    "mbpp_id": 522,
    "problem_statement": "Write a function to find the longest bitonic subsequence for the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\nimport bisect\n\ndef lbs(arr: List[int]) -> int:\n    n = len(arr)\n    \n    # Left-Bridge Array\n    left_bridge = [0] * n\n    left_bridge[n - 1] = 1\n    max_height_left = arr[n - 1]\n    \n    for i in range(n - 2, -1, -1):\n        if arr[i] > max_height_left:\n            max_height_left = arr[i]\n            left_bridge[i] = max_height_left + 1\n    \n    # Right-Bridge Array\n    right_bridge = [0] * n\n    right_bridge[0] = 1\n    min_height_right = arr[0]\n    \n    for i in range(1, n):\n        if arr[i] < min_height_right:\n            min_height_right = arr[i]\n            right_bridge[i] = min_height_right + 1\n    \n    # Longest Bitonic Subsequence Length\n    lbd_length = 0\n    for i in range(n):\n        bridge_value = min(left_bridge[i], right_bridge[i])\n        \n        # Find the smallest value such that arr[j-1] <= bridge_value\n        j = bisect.bisect_left(right_bridge, bridge_value) - 1\n        \n        while j >= 0 and arr[j] <= bridge_value:\n            bridge_value = min(bridge_value, arr[j])\n            j -= 1\n        \n        lbd_length = max(lbd_length, bridge_value)\n    \n    return lbd_length",
    "test_cases": [
      "assert lbs([0 , 8 , 4, 12, 2, 10 , 6 , 14 , 1 , 9 , 5 , 13, 3, 11 , 7 , 15]) == 7",
      "assert lbs([1, 11, 2, 10, 4, 5, 2, 1]) == 6",
      "assert lbs([80, 60, 30, 40, 20, 10]) == 5"
    ]
  },
  {
    "mbpp_id": 523,
    "problem_statement": "Write a function to check whether a given string has a capital letter, a lower case letter, a number and specified length using lambda function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def check_string(s):\n    def is_upper(c):\n        return c.isupper()\n\n    def is_lower(c):\n        return c.islower()\n\n    def is_digit(c):\n        return c.isdigit()\n\n    result = [\n        \"String must have 1 upper case character.\" if not is_upper(s[0]) else \"\",\n        \"String must have 1 number.\" if not any(is_digit(c) for c in s) else \"\",\n        f\"String length should be atleast {len(s)}.\" if len(s) < 8 else \"\"\n    ]\n\n    valid_strings = [s for r in result if r != \"\"]\n    \n    return list(filter(lambda x: x == s, valid_strings))",
    "test_cases": [
      "assert check_string('python')==['String must have 1 upper case character.', 'String must have 1 number.', 'String length should be atleast 8.']",
      "assert check_string('123python')==['String must have 1 upper case character.']",
      "assert check_string('123Python')==['Valid string.']"
    ]
  },
  {
    "mbpp_id": 524,
    "problem_statement": "Write a function to find the sum of maximum increasing subsequence of the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: max_sum_increasing_subsequence() takes 1 positional argument but 2 were given"
    ],
    "generated_code": "from typing import List\n\ndef max_sum_increasing_subsequence(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [arr[0]] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + arr[i])\n    \n    return max(dp)\n\n# Test cases\nprint(max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5], 7))  # Expected output: 106\nprint(max_sum_increasing_subsequence([3, 4, 5, 10], 4))              # Expected output: 22\nprint(max_sum_increasing_subsequence([10, 5, 4, 3], 4))               # Expected output: 10",
    "test_cases": [
      "assert max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5], 7) == 106",
      "assert max_sum_increasing_subsequence([3, 4, 5, 10], 4) == 22",
      "assert max_sum_increasing_subsequence([10, 5, 4, 3], 4) == 10"
    ]
  },
  {
    "mbpp_id": 525,
    "problem_statement": "Write a python function to check whether two given lines are parallel or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'parallel_lines' is not defined",
      "Test 2: FAIL - name 'parallel_lines' is not defined",
      "Test 3: FAIL - name 'parallel_lines' is not defined"
    ],
    "generated_code": "def is_parallel(line1, line2):\n    # Calculate the slope of each line using their first point coordinates.\n    # Lines are considered parallel if their slopes are equal.\n    if line1[0] * line2[1] == line2[0] * line1[1]:\n        return True\n    else:\n        return False",
    "test_cases": [
      "assert parallel_lines([2,3,4], [2,3,8]) == True",
      "assert parallel_lines([2,3,4], [4,-3,8]) == False",
      "assert parallel_lines([3,3],[5,5]) == True"
    ]
  },
  {
    "mbpp_id": 526,
    "problem_statement": "Write a python function to capitalize first and last letters of each word of a given string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def capitalize_first_last_letters(text):\n    words = text.split()\n    capitalized_words = [word[0].upper() + word[1:-1] + word[-1].upper() for word in words]\n    return ' '.join(capitalized_words)\n\n# Test cases\nprint(capitalize_first_last_letters(\"python\")) # Expected output: \"PythoN\"\nprint(capitalize_first_last_letters(\"bigdata\")) # Expected output: \"BigdatA\"\nprint(capitalize_first_last_letters(\"Hadoop\")) # Expected output: \"HadooP\"",
    "test_cases": [
      "assert capitalize_first_last_letters(\"python\") == \"PythoN\"",
      "assert capitalize_first_last_letters(\"bigdata\") == \"BigdatA\"",
      "assert capitalize_first_last_letters(\"Hadoop\") == \"HadooP\""
    ]
  },
  {
    "mbpp_id": 527,
    "problem_statement": "Write a function to find all pairs in an integer array whose sum is equal to a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed"
    ],
    "generated_code": "def get_pairs_count(nums, target_sum, pair_count):\n    \"\"\"\n    Find and count unique pairs of numbers from the given list 'nums' which add up to 'target_sum'.\n    \n    Parameters:\n    nums (List[int]): The list of integers.\n    target_sum (int): The target sum for pairs.\n    pair_count (int): A counter initialized with the desired count of pairs found.\n    \n    Returns:\n    int: The total count of pairs found.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        complement = target_sum - num\n        if complement in seen:\n            # Add both numbers to pair_count as they form a valid pair.\n            pair_count += 1\n        else:\n            # Mark the current number as seen.\n            seen.add(num)\n    return pair_count\n\n# Test cases\nassert get_pairs_count([1, 5, 7, -1, 5], 5, 0) == 6\nassert get_pairs_count([1, 5, 7, -1], 4, 0) == 2\nassert get_pairs_count([1, 1, 1, 1], 4, 0) == 6\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert get_pairs_count([1, 5, 7, -1, 5], 5, 6) == 3",
      "assert get_pairs_count([1, 5, 7, -1], 4, 6) == 2",
      "assert get_pairs_count([1, 1, 1, 1], 4, 2) == 6"
    ]
  },
  {
    "mbpp_id": 528,
    "problem_statement": "Write a function to find the list of lists with minimum length.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def min_length(lsts):\n    if not lsts:\n        return None, []\n    else:\n        return len(min(lsts, key=len)), [x for x in lsts if len(x) == len(min(lsts, key=len))]\n\n# Example usage and test cases\nprint(min_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]))\nprint(min_length([[1], [5, 7], [10, 12, 14, 15]]))\nprint(min_length([[5], [15, 20, 25]]))",
    "test_cases": [
      "assert min_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
      "assert min_length([[1], [5, 7], [10, 12, 14,15]])==(1, [1])",
      "assert min_length([[5], [15,20,25]])==(1, [5])"
    ]
  },
  {
    "mbpp_id": 529,
    "problem_statement": "Write a function to find the nth jacobsthal-lucas number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def jacobsthal_lucas(n):\n    def g(k):\n        if k == 0:\n            return 0\n        elif k == 1:\n            return 2\n        else:\n            return 2 * g(k - 1) + g(k - 2)\n    \n    return g(n)\n\n# Test cases\nprint(jacobsthal_lucas(5))  # Output: 31\nprint(jacobsthal_lucas(2))  # Output: 5\nprint(jacobsthal_lucas(4))  # Output: 17",
    "test_cases": [
      "assert jacobsthal_lucas(5) == 31",
      "assert jacobsthal_lucas(2) == 5",
      "assert jacobsthal_lucas(4) == 17"
    ]
  },
  {
    "mbpp_id": 530,
    "problem_statement": "Write a function to find the ration of negative numbers in an array of integers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: '<' not supported between instances of 'list' and 'int'"
    ],
    "generated_code": "import numpy as np\n\ndef negative_count(nums):\n    # Count the number of negative numbers in the list using NumPy\n    count = np.count_nonzero(nums < 0)\n    \n    # Calculate and return the ratio of negative numbers\n    return count / len(nums)\n\n# Example check function to verify the correctness of the solution\ndef check_solution():\n    assert np.isclose(negative_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.31) == True\n    assert np.isclose(negative_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.31) == True\n    assert np.isclose(negative_count([2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.44) == True\n    \ncheck_solution()",
    "test_cases": [
      "assert negative_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.31",
      "assert negative_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.31",
      "assert negative_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.44"
    ]
  },
  {
    "mbpp_id": 531,
    "problem_statement": "Write a function to find minimum number of coins that make a given value.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "from typing import List\nimport bisect\n\ndef min_coins(coins: List[int], amount: int, total_amount: int) -> int:\n    dp = [float('inf')] * (total_amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for x in range(coin, total_amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1",
    "test_cases": [
      "assert min_coins([9, 6, 5, 1] ,4,11)==2",
      "assert min_coins([4,5,6,7,8,9],6,9)==1",
      "assert min_coins([1, 2, 3],3,4)==2"
    ]
  },
  {
    "mbpp_id": 532,
    "problem_statement": "Write a function to check if the two given strings are permutations of each other.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_permutation(str1, str2):\n    \"\"\"\n    Checks if two input strings are permutations of each other.\n    \n    Parameters:\n        str1 (str): The first string.\n        str2 (str): The second string.\n        \n    Returns:\n        bool: True if str1 and str2 are permutations of each other, False otherwise.\n    \"\"\"\n    # If lengths differ, they cannot be permutations of each other\n    if len(str1) != len(str2):\n        return False\n    \n    # Convert both strings to sets and compare their size\n    return set(str1) == set(str2)",
    "test_cases": [
      "assert check_permutation(\"abc\", \"cba\") == True",
      "assert check_permutation(\"test\", \"ttew\") == False",
      "assert check_permutation(\"xxyz\", \"yxzx\") == True"
    ]
  },
  {
    "mbpp_id": 533,
    "problem_statement": "Write a function to remove particular data type elements from the given tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_datatype(tup, datatype):\n    filtered_tuple = tuple(element for element in tup if not isinstance(element, datatype))\n    return filtered_tuple\n\n# Test cases\nprint(remove_datatype((4, 5, 4, 7.7, 1.2), int))  # Output: [7.7, 1.2]\nprint(remove_datatype((7, 8, 9, \"SR\"), str))  # Output: [7, 8, 9]\nprint(remove_datatype((7, 1.1, 2, 2.2), float))  # Output: [7, 2]",
    "test_cases": [
      "assert remove_datatype((4, 5, 4, 7.7, 1.2), int) == [7.7, 1.2]",
      "assert remove_datatype((7, 8, 9, \"SR\"), str) == [7, 8, 9]",
      "assert remove_datatype((7, 1.1, 2, 2.2), float) == [7, 2]"
    ]
  },
  {
    "mbpp_id": 534,
    "problem_statement": "Write a function to search a literals string in a string and also find the location within the original string where the pattern occurs.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def search_literal(string, literal):\n    start = -1\n    while True:\n        start = string.find(literal, start + 1)\n        if start == -1:\n            break\n    return (start, start + len(literal))\n\n# Test Cases\nprint(search_literal('python programming language', 'python'))  # Expected output: (0, 6)\nprint(search_literal('programming python', 'python'))  # Expected output: (7, 18)\nprint(search_literal('language python programming', 'python'))  # Expected output: (19, 27)",
    "test_cases": [
      "assert search_literal('python','python programming language')==(0,6)",
      "assert search_literal('programming','python programming language')==(7,18)",
      "assert search_literal('language','python programming language')==(19,27)"
    ]
  },
  {
    "mbpp_id": 535,
    "problem_statement": "Write a function to find the top or bottom surface area of a cylinder.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\n\ndef topbottom_surfacearea(radius):\n    \"\"\"\n    Calculate the surface area of a cylinder with given radius.\n    \n    Args:\n    radius (float): The radius of the cylinder.\n    \n    Returns:\n    float: The surface area of the cylinder.\n    \"\"\"\n    height = 10  # Example height, can be adjusted for different tests\n    top_area = math.pi * radius ** 2\n    side_area = 2 * math.pi * radius * height\n    return top_area + side_area",
    "test_cases": [
      "assert topbottom_surfacearea(10)==314.15000000000003",
      "assert topbottom_surfacearea(5)==78.53750000000001",
      "assert topbottom_surfacearea(4)==50.264"
    ]
  },
  {
    "mbpp_id": 536,
    "problem_statement": "Write a function to select the nth items of a list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def nth_items(lst, n):\n    return lst[n::n]",
    "test_cases": [
      "assert nth_items([1, 2, 3, 4, 5, 6, 7, 8, 9],2)==[1, 3, 5, 7, 9] ",
      "assert nth_items([10,15,19,17,16,18],3)==[10,17] ",
      "assert nth_items([14,16,19,15,17],4)==[14,17]"
    ]
  },
  {
    "mbpp_id": 537,
    "problem_statement": "Write a python function to find the first repeated word in a given string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def first_repeated_word(s):\n    words = s.split()\n    seen_words = set()\n\n    for word in words:\n        if word in seen_words:\n            return word\n        else:\n            seen_words.add(word)\n    \n    return None\n\n# Test cases\nprint(first_repeated_word(\"ab ca bc ab\"))   # Expected output: \"ab\"\nprint(first_repeated_word(\"ab ca bc\"))      # Expected output: \"None\"\nprint(first_repeated_word(\"ab ca bc ca ab bc\"))  # Expected output: \"ca\"",
    "test_cases": [
      "assert first_repeated_word(\"ab ca bc ab\") == \"ab\"",
      "assert first_repeated_word(\"ab ca bc\") == 'None'",
      "assert first_repeated_word(\"ab ca bc ca ab bc\") == \"ca\""
    ]
  },
  {
    "mbpp_id": 538,
    "problem_statement": "Write a python function to convert a given string list to a tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def string_list_to_tuple(string_list):\n    # Convert each element in the string_list to a character and then join them into a tuple.\n    result = tuple([char for char in string_list])\n    return result",
    "test_cases": [
      "assert string_list_to_tuple((\"python 3.0\")) == ('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')",
      "assert string_list_to_tuple((\"bigdata\")) == ('b', 'i', 'g', 'd', 'a', 't', 'a')",
      "assert string_list_to_tuple((\"language\")) == ('l', 'a', 'n', 'g', 'u', 'a', 'g','e')"
    ]
  },
  {
    "mbpp_id": 539,
    "problem_statement": "Write a function to create a list containing the power of said number in bases raised to the corresponding number in the index using map function.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'basesnum_coresspondingnum' is not defined",
      "Test 2: FAIL - name 'basesnum_coresspondingnum' is not defined",
      "Test 3: FAIL - name 'basesnum_coresspondingnum' is not defined"
    ],
    "generated_code": "from typing import List\nimport math\n\ndef basesnum_correspondingnum(bases: List[int], nums: List[int]) -> List[int]:\n    return [math.pow(base, num) for base, num in zip(bases, nums)]",
    "test_cases": [
      "assert basesnum_coresspondingnum([10, 20, 30, 40, 50, 60, 70, 80, 90, 100],[1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[10, 400, 27000, 2560000, 312500000, 46656000000, 8235430000000, 1677721600000000, 387420489000000000, 100000000000000000000]",
      "assert basesnum_coresspondingnum([1, 2, 3, 4, 5, 6, 7],[10, 20, 30, 40, 50, 60, 70])==[1, 1048576, 205891132094649, 1208925819614629174706176, 88817841970012523233890533447265625, 48873677980689257489322752273774603865660850176, 143503601609868434285603076356671071740077383739246066639249]",
      "assert basesnum_coresspondingnum([4, 8, 12, 16, 20, 24, 28],[3, 6, 9, 12, 15, 18, 21])==[64, 262144, 5159780352, 281474976710656, 32768000000000000000, 6979147079584381377970176, 2456510688823056210273111113728]"
    ]
  },
  {
    "mbpp_id": 540,
    "problem_statement": "Write a python function to find the difference between highest and least frequencies in a given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List\n\ndef find_Diff(arr: List[int], n: int) -> int:\n    max_count = 0\n    min_count = n + 1\n    \n    for i in range(n):\n        count = arr.count(arr[i])\n        if count > max_count:\n            max_count = count\n        elif count < min_count:\n            min_count = count\n            \n    return max_count - min_count",
    "test_cases": [
      "assert find_Diff([1,1,2,2,7,8,4,5,1,4],10) == 2",
      "assert find_Diff([1,7,9,2,3,3,1,3,3],9) == 3",
      "assert find_Diff([1,2,1,2],4) == 0"
    ]
  },
  {
    "mbpp_id": 541,
    "problem_statement": "Write a function to find if the given number is abundant or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def check_abundant(n):\n    sum_divisors = 0\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            sum_divisors += i\n    return sum_divisors > n",
    "test_cases": [
      "assert check_abundant(12) == True",
      "assert check_abundant(15) == False",
      "assert check_abundant(18) == True"
    ]
  },
  {
    "mbpp_id": 542,
    "problem_statement": "Write a function to replace all occurrences of spaces, commas, or dots with a colon in the given string by using regex.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef fill_spaces(input_string):\n    # Define the pattern to match spaces, commas, and dots\n    pattern = '[ ,.]'\n    # Replace all matches with a colon\n    result = re.sub(pattern, ':', input_string)\n    return result",
    "test_cases": [
      "assert fill_spaces('Boult Curve Wireless Neckband') == 'Boult:Curve:Wireless:Neckband'",
      "assert fill_spaces('Stereo Sound Sweatproof') == 'Stereo:Sound:Sweatproof'",
      "assert fill_spaces('Probass Curve Audio') == 'Probass:Curve:Audio'"
    ]
  },
  {
    "mbpp_id": 543,
    "problem_statement": "Write a function to add two numbers and print number of digits of sum.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def count_digits(num1, num2):\n    # Add two numbers\n    total = num1 + num2\n    \n    # Convert the sum to string and get its length\n    digit_count = len(str(total))\n    \n    return digit_count",
    "test_cases": [
      "assert count_digits(9875,10)==(4)",
      "assert count_digits(98759853034,100)==(11)",
      "assert count_digits(1234567,500)==(7)"
    ]
  },
  {
    "mbpp_id": 544,
    "problem_statement": "Write a function to flatten the tuple list to a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def flatten_tuple(tup_list):\n    \"\"\"\n    Flatten a list of tuples into a single string with each element separated by space.\n    \n    Args:\n    tup_list (list): A list of tuples containing strings.\n    \n    Returns:\n    str: A single string made by concatenating all elements from the tuples in the input list, separated by spaces.\n    \"\"\"\n    # Flatten and join the tuple elements into a single string\n    return ' '.join([''.join(subt) for sublist in tup_list for subt in sublist])\n\n# Example check function to verify the correctness of the solution\ndef check_solution():\n    assert flatten_tuple([('1', '4', '6'), ('5', '8'), ('2', '9'), ('1', '10')]) == '1 4 6 5 8 2 9 1 10'\n    assert flatten_tuple([('2', '3', '4'), ('6', '9'), ('3', '2'), ('2', '11')]) == '2 3 4 6 9 3 2 2 11'\n    assert flatten_tuple([('14', '21', '9'), ('24', '19'), ('12', '29'), ('23', '17')]) == '14 21 9 24 19 12 29 23 17'\n    print(\"All tests passed!\")\n\ncheck_solution()",
    "test_cases": [
      "assert flatten_tuple([('1', '4', '6'), ('5', '8'), ('2', '9'), ('1', '10')]) == '1 4 6 5 8 2 9 1 10'",
      "assert flatten_tuple([('2', '3', '4'), ('6', '9'), ('3', '2'), ('2', '11')]) == '2 3 4 6 9 3 2 2 11'",
      "assert flatten_tuple([('14', '21', '9'), ('24', '19'), ('12', '29'), ('23', '17')]) == '14 21 9 24 19 12 29 23 17'"
    ]
  },
  {
    "mbpp_id": 545,
    "problem_statement": "Write a python function to toggle only first and last bits of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def toggle_F_and_L_bits(n):\n    # Shift left by 1 bit to move the rightmost bit to the least significant position\n    n = n << 1\n    \n    # Toggle the least significant bit using XOR operation with itself shifted one place to the left\n    n ^= n >> 1\n    \n    return n\n\n# Test cases\nprint(toggle_F_and_L_bits(10))  # Expected output: 3\nprint(toggle_F_and_L_bits(15))  # Expected output: 6\nprint(toggle_F_and_L_bits(20))  # Expected output: 5",
    "test_cases": [
      "assert toggle_F_and_L_bits(10) == 3",
      "assert toggle_F_and_L_bits(15) == 6",
      "assert toggle_F_and_L_bits(20) == 5"
    ]
  },
  {
    "mbpp_id": 546,
    "problem_statement": "Write a function to find the last occurrence of a character in a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def last_occurence_char(s, char):\n    try:\n        return s.rindex(char)\n    except ValueError:\n        return None",
    "test_cases": [
      "assert last_occurence_char(\"hello world\",'l')==10",
      "assert last_occurence_char(\"language\",'g')==7",
      "assert last_occurence_char(\"little\",'y')==None"
    ]
  },
  {
    "mbpp_id": 547,
    "problem_statement": "Write a python function to find the sum of hamming distances of all consecutive numbers from o to n.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Assertion failed: Test case 1 failed"
    ],
    "generated_code": "def Total_Hamming_Distance(n):\n    # Initialize total Hamming distance to zero\n    total_distance = 0\n    \n    # Iterate through each bit position\n    for i in range(1, n + 1):\n        current_bit_position = bin(i)[2:].zfill(32)\n        \n        # Count occurrences of '0' and '1' at each bit position\n        count_ones = current_bit_position.count('1')\n        count_zeros = len(current_bit_position) - count_ones\n        \n        # Add the difference between counts to total distance\n        total_distance += abs(count_ones - count_zeros)\n    \n    return total_distance\n\n# Test the function with provided data points\nassert Total_Hamming_Distance(4) == 7, \"Test case 1 failed\"\nassert Total_Hamming_Distance(2) == 3, \"Test case 2 failed\"\nassert Total_Hamming_Distance(5) == 8, \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert Total_Hamming_Distance(4) == 7",
      "assert Total_Hamming_Distance(2) == 3",
      "assert Total_Hamming_Distance(5) == 8"
    ]
  },
  {
    "mbpp_id": 548,
    "problem_statement": "Write a function to find the length of the longest increasing subsequence of the given sequence.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List\n\ndef longest_increasing_subsequence(sequence: List[int]) -> int:\n    dp = [1] * len(sequence)\n    \n    for i in range(1, len(sequence)):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                \n    return max(dp)",
    "test_cases": [
      "assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) == 5",
      "assert longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3",
      "assert longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) == 4 "
    ]
  },
  {
    "mbpp_id": 549,
    "problem_statement": "Write a python function to find the sum of fifth power of first n odd natural numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def odd_Num_Sum(n):\n    \"\"\"\n    Calculate the sum of the fifth power of the first n odd natural numbers.\n    \n    Parameters:\n    n (int): The number of initial odd natural numbers to consider.\n    \n    Returns:\n    int: The sum of the fifth powers of the first n odd natural numbers.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        # Calculate the ith odd number and raise it to the fifth power\n        current_odd = 2 * i + 1\n        total_sum += pow(current_odd, 5)\n    return total_sum",
    "test_cases": [
      "assert odd_Num_Sum(1) == 1",
      "assert odd_Num_Sum(2) == 244",
      "assert odd_Num_Sum(3) == 3369"
    ]
  },
  {
    "mbpp_id": 550,
    "problem_statement": "Write a python function to find the maximum element in a sorted and rotated array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_Max(nums, start, end):\n    # Base case: if there is only one element\n    if start == end:\n        return nums[start]\n    \n    # Find the pivot point where the array was rotated\n    mid = (start + end) // 2\n    \n    # Check if mid itself is the maximum element\n    if mid < end and nums[mid] > nums[mid + 1]:\n        return nums[mid]\n    elif mid > start and nums[mid - 1] > nums[mid]:\n        return nums[mid - 1]\n    else:\n        # If we can't determine which half contains the maximum,\n        # check recursively on both halves\n        max_left = find_Max(nums, start, mid)\n        max_right = find_Max(nums, mid + 1, end)\n        \n        # Return the larger of the two maximums found\n        return max(max_left, max_right)\n\n# Example usage\nprint(find_Max([2,3,5,6,9], 0, 4))  # Output: 9\nprint(find_Max([3,4,5,2,1], 0, 4))  # Output: 5\nprint(find_Max([1,2,3], 0, 2))      # Output: 3",
    "test_cases": [
      "assert find_Max([2,3,5,6,9],0,4) == 9",
      "assert find_Max([3,4,5,2,1],0,4) == 5",
      "assert find_Max([1,2,3],0,2) == 3"
    ]
  },
  {
    "mbpp_id": 551,
    "problem_statement": "Write a function to extract a specified column from a given nested list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def extract_column(matrix, col_index):\n    return [row[col_index] for row in matrix]",
    "test_cases": [
      "assert extract_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]],0)==[1, 2, 1]",
      "assert extract_column([[1, 2, 3], [-2, 4, -5], [1, -1, 1]],2)==[3, -5, 1]",
      "assert extract_column([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]],0)==[1, 5, 1, 13, 5, 9]"
    ]
  },
  {
    "mbpp_id": 552,
    "problem_statement": "Write a python function to check whether a given sequence is linear or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def Seq_Linear(seq):\n    # Check if all elements in the sequence are consecutive integers starting from 0\n    for i in range(len(seq) - 1):\n        if seq[i] + 1 != seq[i+1]:\n            return \"Non Linear Sequence\"\n    return \"Linear Sequence\"\n\n# Test cases\nprint(Seq_Linear([0,2,4,6,8,10]))  # Expected output: \"Linear Sequence\"\nprint(Seq_Linear([1,2,3]))         # Expected output: \"Linear Sequence\"\nprint(Seq_Linear([1,5,2]))         # Expected output: \"Non Linear Sequence\"",
    "test_cases": [
      "assert Seq_Linear([0,2,4,6,8,10]) == \"Linear Sequence\"",
      "assert Seq_Linear([1,2,3]) == \"Linear Sequence\"",
      "assert Seq_Linear([1,5,2]) == \"Non Linear Sequence\""
    ]
  },
  {
    "mbpp_id": 553,
    "problem_statement": "Write a function to convert the given tuple to a floating-point number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def tuple_to_float(tup):\n    # Convert each element in the tuple to float and then sum them up.\n    result = sum(float(i) for i in tup)\n    return result",
    "test_cases": [
      "assert tuple_to_float((4, 56)) == 4.56",
      "assert tuple_to_float((7, 256)) == 7.256",
      "assert tuple_to_float((8, 123)) == 8.123"
    ]
  },
  {
    "mbpp_id": 554,
    "problem_statement": "Write a python function to find odd numbers from a mixed list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'Split' is not defined",
      "Test 2: FAIL - name 'Split' is not defined",
      "Test 3: FAIL - name 'Split' is not defined"
    ],
    "generated_code": "def split(numbers_list):\n    # Initialize an empty list to store odd numbers\n    odd_numbers = []\n    \n    # Iterate through each number in the input list\n    for num in numbers_list:\n        # Check if the number is odd using modulo operator\n        if num % 2 != 0:\n            # Append odd number to the result list\n            odd_numbers.append(num)\n    \n    # Return the list of odd numbers\n    return odd_numbers\n\n# Test the function with provided data points\nassert split([1,2,3,4,5,6]) == [1,3,5], \"Test case 1 failed\"\nassert split([10,11,12,13]) == [11,13], \"Test case 2 failed\"\nassert split([7,8,9,1]) == [7,9,1], \"Test case 3 failed\"\n\nprint(\"All test cases passed!\")",
    "test_cases": [
      "assert Split([1,2,3,4,5,6]) == [1,3,5]",
      "assert Split([10,11,12,13]) == [11,13]",
      "assert Split([7,8,9,1]) == [7,9,1]"
    ]
  },
  {
    "mbpp_id": 555,
    "problem_statement": "Write a python function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def difference(n):\n    # Calculate the sum of cubes using the formula for the sum of cubes:\n    # Sum_of_Cubes = n * (n + 1) * (2*n + 1) / 6\n    \n    sum_cubes = n * (n + 1) * (2*n + 1) // 6\n    \n    # Calculate the sum of first n natural numbers using the formula:\n    # Sum = n * (n + 1) / 2\n    \n    total_sum = n * (n + 1) // 2\n    \n    # Return the difference between sum of cubes and sum of first n natural numbers\n    \n    return sum_cubes - total_sum",
    "test_cases": [
      "assert difference(3) == 30",
      "assert difference(5) == 210",
      "assert difference(2) == 6"
    ]
  },
  {
    "mbpp_id": 556,
    "problem_statement": "Write a python function to count the pairs with xor as an odd number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def find_Odd_Pair(arr, target):\n    result = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == target:\n                result += 1\n    return result\n\n# Test cases\nprint(find_Odd_Pair([5,4,7,2,1], 5))  # Output: 6\nprint(find_Odd_Pair([7,2,8,1,0,5,11], 7))  # Output: 12\nprint(find_Odd_Pair([1,2,3], 3))  # Output: 2",
    "test_cases": [
      "assert find_Odd_Pair([5,4,7,2,1],5) == 6",
      "assert find_Odd_Pair([7,2,8,1,0,5,11],7) == 12",
      "assert find_Odd_Pair([1,2,3],3) == 2"
    ]
  },
  {
    "mbpp_id": 557,
    "problem_statement": "Write a function to toggle characters case in a string.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def toggle_string(input_str):\n    return input_str.swapcase()\n\n# Test cases\nprint(toggle_string(\"Python\"))  # Expected output: \"pYTHON\"\nprint(toggle_string(\"Pangram\"))  # Expected output: \"pANGRAM\"\nprint(toggle_string(\"LIttLE\"))   # Expected output: \"liTTle\"",
    "test_cases": [
      "assert toggle_string(\"Python\")==(\"pYTHON\")",
      "assert toggle_string(\"Pangram\")==(\"pANGRAM\")",
      "assert toggle_string(\"LIttLE\")==(\"liTTle\")"
    ]
  },
  {
    "mbpp_id": 558,
    "problem_statement": "Write a python function to find the digit distance between two integers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def digit_distance_nums(num1, num2):\n    # Calculate the absolute difference of their digits and add them together\n    total = sum(abs(int(x) - int(y)) for x, y in zip(str(num1), str(num2)))\n    return total",
    "test_cases": [
      "assert digit_distance_nums(1,2) == 1",
      "assert digit_distance_nums(23,56) == 6",
      "assert digit_distance_nums(123,256) == 7"
    ]
  },
  {
    "mbpp_id": 559,
    "problem_statement": "Write a function to find the largest sum of contiguous subarray in the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - max_sub_array_sum() takes 1 positional argument but 2 were given",
      "Test 2: FAIL - max_sub_array_sum() takes 1 positional argument but 2 were given",
      "Test 3: FAIL - max_sub_array_sum() takes 1 positional argument but 2 were given"
    ],
    "generated_code": "def max_sub_array_sum(nums):\n    current_sum = max_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\n# Test cases\nprint(max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3])) # Output: 7\nprint(max_sub_array_sum([-3, -4, 5, -2, -3, 2, 6, -4])) # Output: 8\nprint(max_sub_array_sum([-4, -5, 6, -3, -4, 3, 7, -5])) # Output: 10",
    "test_cases": [
      "assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7",
      "assert max_sub_array_sum([-3, -4, 5, -2, -3, 2, 6, -4], 8) == 8",
      "assert max_sub_array_sum([-4, -5, 6, -3, -4, 3, 7, -5], 8) == 10"
    ]
  },
  {
    "mbpp_id": 560,
    "problem_statement": "Write a function to find the union of elements of the given tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def union_elements(tup1, tup2):\n    # Convert tuples to sets for element comparison and then back to list\n    set1 = set(tup1)\n    set2 = set(tup2)\n    \n    # Find the union of both sets\n    union_set = set1.union(set2)\n    \n    # Convert the union set back to tuple and return it\n    return tuple(union_set)\n\n# Test cases\nprint(union_elements((3, 4, 5, 6), (5, 7, 4, 10)))  # Expected output: (3, 4, 5, 6, 7, 10)\nprint(union_elements((1, 2, 3, 4), (3, 4, 5, 6)))   # Expected output: (1, 2, 3, 4, 5, 6)\nprint(union_elements((11, 12, 13, 14), (13, 15, 16, 17)))  # Expected output: (11, 12, 13, 14, 15, 16, 17)",
    "test_cases": [
      "assert union_elements((3, 4, 5, 6),(5, 7, 4, 10) ) == (3, 4, 5, 6, 7, 10)",
      "assert union_elements((1, 2, 3, 4),(3, 4, 5, 6) ) == (1, 2, 3, 4, 5, 6)",
      "assert union_elements((11, 12, 13, 14),(13, 15, 16, 17) ) == (11, 12, 13, 14, 15, 16, 17)"
    ]
  },
  {
    "mbpp_id": 561,
    "problem_statement": "Write a function to assign with each element, its pair elements from other similar pairs in the given tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - KeyError: 4"
    ],
    "generated_code": "def assign_elements(pairs):\n    # Dictionary comprehension to create a dictionary where key is an element and value is a set of its assigned elements.\n    result = {pair[0]: set() for pair in pairs}  \n    for first, second in pairs:\n        if second not in result[first]:\n            result[first].add(second)\n            if second != first:\n                result[second].add(first)\n\n    return result\n\n# Test cases\nprint(assign_elements([(5, 3), (7, 5), (2, 7), (3, 8), (8, 4)])) \nprint(assign_elements([(6, 4), (9, 4), (3, 8), (4, 9), (9, 5)]))\nprint(assign_elements([(6, 2), (6, 8), (4, 9), (4, 9), (3, 7)]))",
    "test_cases": [
      "assert assign_elements([(5, 3), (7, 5), (2, 7), (3, 8), (8, 4)] ) == {3: [8], 5: [3], 7: [5], 2: [7], 8: [4], 4: []}",
      "assert assign_elements([(6, 4), (9, 4), (3, 8), (4, 9), (9, 5)] ) == {4: [9], 6: [4], 9: [4, 5], 8: [], 3: [8], 5: []}",
      "assert assign_elements([(6, 2), (6, 8), (4, 9), (4, 9), (3, 7)] ) == {2: [], 6: [2, 8], 8: [], 9: [], 4: [9, 9], 7: [], 3: [7]}"
    ]
  },
  {
    "mbpp_id": 562,
    "problem_statement": "Write a python function to find the maximum length of sublist.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def Find_Max_Length(lst):\n    \"\"\"\n    Finds and returns the maximum length of sublists in lst.\n    \n    :param lst: List of lists containing integers.\n    :return: Maximum length among all sublists.\n    \"\"\"\n    max_length = max(len(sublist) for sublist in lst)\n    return max_length\n\n# Test case 1\nprint(Find_Max_Length([[1],[1,4],[5,6,7,8]])) # Expected output: 4\n\n# Test case 2\nprint(Find_Max_Length([[0,1],[2,2,],[3,2,1]])) # Expected output: 3\n\n# Test case 3\nprint(Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]])) # Expected output: 5",
    "test_cases": [
      "assert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4",
      "assert Find_Max_Length([[0,1],[2,2,],[3,2,1]]) == 3",
      "assert Find_Max_Length([[7],[22,23],[13,14,15],[10,20,30,40,50]]) == 5"
    ]
  },
  {
    "mbpp_id": 563,
    "problem_statement": "Write a function to extract values between quotation marks of a string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import re\n\ndef extract_values(string):\n    # Split the input string by commas and strip quotes from each part\n    return [x.strip('\"') for x in string.split(',') if '\"' in x]\n\n# Test cases\nprint(extract_values('\"Python\", \"PHP\", \"Java\"'))  # Expected output: ['Python', 'PHP', 'Java']\nprint(extract_values('\"python\",\"program\",\"language\"'))  # Expected output: ['python', 'program', 'language']\nprint(extract_values('\"red\",\"blue\",\"green\",\"yellow\"'))  # Expected output: ['red', 'blue', 'green', 'yellow']",
    "test_cases": [
      "assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']",
      "assert extract_values('\"python\",\"program\",\"language\"')==['python','program','language']",
      "assert extract_values('\"red\",\"blue\",\"green\",\"yellow\"')==['red','blue','green','yellow']"
    ]
  },
  {
    "mbpp_id": 564,
    "problem_statement": "Write a python function to count unequal element pairs from the given array.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: PASS - All Clear",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def count_Pairs(arr, n):\n    # Initialize a counter for unequal elements\n    unequal_count = 0\n    \n    # Iterate through each unique element in the array\n    seen_elements = set()\n    for i in range(n):\n        current_element = arr[i]\n        \n        # Check if the current element has already been encountered and is not equal to the next element\n        if current_element in seen_elements and arr[(i + 1) % n] != current_element:\n            unequal_count += 1\n        \n        # Mark the current element as seen\n        seen_elements.add(current_element)\n    \n    return unequal_count",
    "test_cases": [
      "assert count_Pairs([1,2,1],3) == 2",
      "assert count_Pairs([1,1,1,1],4) == 0",
      "assert count_Pairs([1,2,3,4,5],5) == 10"
    ]
  },
  {
    "mbpp_id": 565,
    "problem_statement": "Write a python function to split a string into characters.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def split(s):\n    # Initialize an empty list to store the characters of the string\n    result = []\n    i = 0\n    \n    # Loop through each character in the input string 's'\n    while i < len(s):\n        # If the current character is not whitespace, add it to the result list\n        if s[i] != \" \":\n            result.append(s[i])\n        i += 1\n    \n    # Return the final list containing all the characters from the input string\n    return ''.join(result)",
    "test_cases": [
      "assert split('python') == ['p','y','t','h','o','n']",
      "assert split('Name') == ['N','a','m','e']",
      "assert split('program') == ['p','r','o','g','r','a','m']"
    ]
  },
  {
    "mbpp_id": 566,
    "problem_statement": "Write a function to get the sum of a non-negative integer.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_digits(n):\n    return sum(int(digit) for digit in str(n))",
    "test_cases": [
      "assert sum_digits(345)==12",
      "assert sum_digits(12)==3",
      "assert sum_digits(97)==16"
    ]
  },
  {
    "mbpp_id": 567,
    "problem_statement": "Write a function to check whether a specified list is sorted or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def issort_list(lst):\n    return all(x <= y for x, y in zip(lst, lst[1:]))\n\n# Test cases\nprint(issort_list([1,2,4,6,8,10,12,14,16,17])) # True\nprint(issort_list([1, 2, 4, 6, 8, 10, 12, 14, 20, 17])) # False\nprint(issort_list([1, 2, 4, 6, 8, 10,15,14,20])) # False",
    "test_cases": [
      "assert issort_list([1,2,4,6,8,10,12,14,16,17])==True",
      "assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 20, 17])==False",
      "assert issort_list([1, 2, 4, 6, 8, 10,15,14,20])==False"
    ]
  },
  {
    "mbpp_id": 568,
    "problem_statement": "Write a function to create a list of empty dictionaries.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def empty_list(n):\n    return [{} for _ in range(n)]",
    "test_cases": [
      "assert empty_list(5)==[{},{},{},{},{}]",
      "assert empty_list(6)==[{},{},{},{},{},{}]",
      "assert empty_list(7)==[{},{},{},{},{},{},{}]"
    ]
  },
  {
    "mbpp_id": 569,
    "problem_statement": "Write a function to sort each sublist of strings in a given list of lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - unhashable type: 'list'",
      "Test 2: FAIL - unhashable type: 'list'",
      "Test 3: FAIL - unhashable type: 'list'"
    ],
    "generated_code": "def sort_sublists(lst_of_lsts):\n    # Convert the outer list to a set to remove duplicates and then back to a list,\n    # which will automatically group elements into sublists.\n    lst = list(set(lst_of_lsts))\n    # Sort each sublist individually.\n    for i in range(len(lst)):\n        lst[i].sort()\n    return lst",
    "test_cases": [
      "assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']])==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]",
      "assert sort_sublists([['green', 'orange'], ['black'], ['green', 'orange'], ['white']])==[['green', 'orange'], ['black'], ['green', 'orange'], ['white']]",
      "assert sort_sublists([['a','b'],['d','c'],['g','h'] , ['f','e']])==[['a', 'b'], ['c', 'd'], ['g', 'h'], ['e', 'f']]"
    ]
  },
  {
    "mbpp_id": 570,
    "problem_statement": "Write a function to remove words from a given list of strings containing a character or string.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def remove_words(words_list, unwanted_chars):\n    result = []\n    for word in words_list:\n        if all(char not in word for char in unwanted_chars):\n            result.append(word)\n    return result\n\n# Test cases\nprint(remove_words(['Red color', 'Orange#', 'Green', 'Orange @', \"White\"], ['#', 'color', '@'])) # Output: ['Red', '', 'Green', 'Orange', 'White']\nprint(remove_words(['Red &', 'Orange+', 'Green', 'Orange @', 'White'], ['&', '+', '@'])) # Output: ['Red', '', 'Green', 'Orange', 'White']\nprint(remove_words(['Red &', 'Orange+', 'Green', 'Orange @', 'White'], ['@'])) # Output: ['Red &', 'Orange+', 'Green', 'Orange', 'White']",
    "test_cases": [
      "assert remove_words(['Red color', 'Orange#', 'Green', 'Orange @', \"White\"],['#', 'color', '@'])==['Red', '', 'Green', 'Orange', 'White']",
      "assert remove_words(['Red &', 'Orange+', 'Green', 'Orange @', 'White'],['&', '+', '@'])==['Red', '', 'Green', 'Orange', 'White']",
      "assert remove_words(['Red &', 'Orange+', 'Green', 'Orange @', 'White'],['@'])==['Red &', 'Orange+', 'Green', 'Orange', 'White']"
    ]
  },
  {
    "mbpp_id": 571,
    "problem_statement": "Write a function to find maximum possible sum of disjoint pairs for the given array of integers and a number k.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - list index out of range",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "from typing import List\n\ndef max_sum_pair_diff_lessthan_K(arr: List[int], k: int, n: int) -> int:\n    arr.sort()\n    res = cur_max = 0\n    \n    for i in range(n - 1, -1, -1):\n        if arr[i] <= k:\n            res += arr[i]\n            cur_max = max(cur_max, arr[i])\n        else:\n            break\n            \n    for j in range(1, n + 1):\n        if j < n and abs(j - (n + 1)) > k and arr[j] + arr[n] >= k * 2:\n            temp = arr[j]\n            arr[j] = arr[n]\n            arr[n] = temp\n            res += arr[j] + arr[n]\n    \n    return res\n\n# Example usage\nprint(max_sum_pair_diff_lessthan_K([3, 5, 10, 15, 17, 12, 9], 7, 4))",
    "test_cases": [
      "assert max_sum_pair_diff_lessthan_K([3, 5, 10, 15, 17, 12, 9], 7, 4) == 62",
      "assert max_sum_pair_diff_lessthan_K([5, 15, 10, 300], 4, 12) == 25",
      "assert max_sum_pair_diff_lessthan_K([1, 2, 3, 4, 5, 6], 6, 6) == 21"
    ]
  },
  {
    "mbpp_id": 572,
    "problem_statement": "Write a python function to remove two duplicate numbers from a given number of lists.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def two_unique_nums(lst):\n    # Convert the list to a set to automatically remove duplicates and then back to a list\n    unique_lst = sorted(set(lst))\n    # Remove the first element (the smallest) since we're expecting at least two unique elements\n    return unique_lst[1:]\n\n# Test cases\nprint(two_unique_nums([1,2,3,2,3,4,5]))  # Expected output: [1, 4, 5]\nprint(two_unique_nums([1,2,3,2,4,5]))   # Expected output: [1, 3, 4, 5]\nprint(two_unique_nums([1,2,3,4,5]))     # Expected output: [1, 2, 3, 4, 5]",
    "test_cases": [
      "assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]",
      "assert two_unique_nums([1,2,3,2,4,5]) == [1, 3, 4, 5]",
      "assert two_unique_nums([1,2,3,4,5]) == [1, 2, 3, 4, 5]"
    ]
  },
  {
    "mbpp_id": 573,
    "problem_statement": "Write a python function to calculate the product of the unique numbers of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: unsupported operand type(s) for *: 'NoneType' and 'int'"
    ],
    "generated_code": "def unique_product(numbers):\n    # Convert all numbers in the list to strings for comparison\n    str_numbers = [str(num) for num in numbers]\n    \n    # Sort the string representations\n    sorted_str_numbers = sorted(str_numbers)\n    \n    # Create a new list where each element is a tuple containing two consecutive elements from the sorted string\n    tuples_list = []\n    prev_char = None\n    \n    for char in sorted_str_numbers:\n        if prev_char is not None and char == prev_char:\n            continue\n        else:\n            tuples_list.append((prev_char, char))\n        \n        prev_char = char\n    \n    # Calculate the factorial of the last number in the sorted string\n    last_num = int(sorted_str_numbers[-1])\n    factorial_last_num = 1\n    for i in range(2, last_num + 1):\n        factorial_last_num *= i\n    \n    result = 1\n    for tup in tuples_list:\n        result *= int(tup[0] * int(tup[1]))\n    \n    return factorial_last_num * result\n\n# Test cases\nprint(unique_product([10, 20, 30, 40, 20, 50, 60, 40]))  # Should return 720000000\nprint(unique_product([1, 2, 3, 1,]))  # Should return 6\nprint(unique_product([7, 8, 9, 0, 1, 1]))  # Should return 0",
    "test_cases": [
      "assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000",
      "assert unique_product([1, 2, 3, 1,]) == 6",
      "assert unique_product([7, 8, 9, 0, 1, 1]) == 0"
    ]
  },
  {
    "mbpp_id": 574,
    "problem_statement": "Write a function to find the surface area of a cylinder.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import math\ndef surfacearea_cylinder(r, h):\n    return 2 * math.pi * r * (r + h)",
    "test_cases": [
      "assert surfacearea_cylinder(10,5)==942.45",
      "assert surfacearea_cylinder(4,5)==226.18800000000002",
      "assert surfacearea_cylinder(4,10)==351.848"
    ]
  },
  {
    "mbpp_id": 575,
    "problem_statement": "Write a python function to find nth number in a sequence which is not a multiple of a given number.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - count_no() takes 3 positional arguments but 4 were given",
      "Test 2: FAIL - count_no() takes 3 positional arguments but 4 were given",
      "Test 3: FAIL - count_no() takes 3 positional arguments but 4 were given"
    ],
    "generated_code": "def count_no(x, y, n):\n    i = 0\n    while i < n:\n        if i % x != 0 and i % y != 0:\n            i += 1\n        else:\n            i += 1\n    return i - 1",
    "test_cases": [
      "assert count_no(2,3,1,10) == 5",
      "assert count_no(3,6,4,20) == 11",
      "assert count_no(5,10,4,20) == 16"
    ]
  },
  {
    "mbpp_id": 576,
    "problem_statement": "Write a python function to check whether an array is subarray of another or not.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: is_sub_array() takes 2 positional arguments but 4 were given"
    ],
    "generated_code": "def is_sub_array(arr1, arr2):\n    m = len(arr1)\n    n = len(arr2)\n    \n    if m < n:\n        return False\n    \n    for i in range(m - n + 1):\n        j = 0\n        while j < n and arr1[i + j] == arr2[j]:\n            j += 1\n        if j == n:\n            return True\n            \n    return False\n\n# Test cases\nprint(is_sub_array([1,4,3,5], [1,2], 4, 2)) # Expected output: False\nprint(is_sub_array([1,2,1], [1,2,1], 3, 3)) # Expected output: True\nprint(is_sub_array([1,0,2,2], [2,2,0], 4, 3)) # Expected output: False",
    "test_cases": [
      "assert is_Sub_Array([1,4,3,5],[1,2],4,2) == False",
      "assert is_Sub_Array([1,2,1],[1,2,1],3,3) == True",
      "assert is_Sub_Array([1,0,2,2],[2,2,0],4,3) ==False"
    ]
  },
  {
    "mbpp_id": 577,
    "problem_statement": "Write a python function to find the last digit in factorial of a given number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def last_Digit_Factorial(n):\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    # Return the last digit of the factorial result\n    return factorial % 10",
    "test_cases": [
      "assert last_Digit_Factorial(4) == 4",
      "assert last_Digit_Factorial(21) == 0",
      "assert last_Digit_Factorial(30) == 0"
    ]
  },
  {
    "mbpp_id": 578,
    "problem_statement": "Write a function to interleave lists of the same length.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def interleave_lists(list1, list2, list3):\n    return [x + y + z for x, y, z in zip(list1, list2, list3)]",
    "test_cases": [
      "assert interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700])==[1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]",
      "assert interleave_lists([10,20],[15,2],[5,10])==[10,15,5,20,2,10]",
      "assert interleave_lists([11,44], [10,15], [20,5])==[11,10,20,44,15,5]"
    ]
  },
  {
    "mbpp_id": 579,
    "problem_statement": "Write a function to find the dissimilar elements in the given two tuples.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def find_dissimilar(tup1, tup2):\n    # Find and remove common elements from both tuples\n    common_elements = set(tup1) & set(tup2)\n    dissimilar_elements = tuple(set(tup1).symmetric_difference(set(tup2)))\n    \n    return dissimilar_elements",
    "test_cases": [
      "assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)",
      "assert find_dissimilar((1, 2, 3, 4), (7, 2, 3, 9)) == (1, 4, 7, 9)",
      "assert find_dissimilar((21, 11, 25, 26), (26, 34, 21, 36)) == (34, 36, 11, 25)"
    ]
  },
  {
    "mbpp_id": 580,
    "problem_statement": "Write a function to extract the even elements in the nested mixed tuple.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: 'int' object is not iterable"
    ],
    "generated_code": "def extract_even(tup):\n    \"\"\"\n    Extracts and returns an iterable containing all even numbers from the given mixed nested tuple.\n    \n    Parameters:\n    tup (tuple): The input mixed nested tuple containing integers and other tuples.\n    \n    Returns:\n    list: A list of even numbers extracted from the nested tuple structure.\n    \"\"\"\n    return [item for sublist in tup for item in (sublist if isinstance(sublist, int) else extract_even(sublist)) if item % 2 == 0]\n\n# Test cases\nprint(extract_even((4, 5, (7, 6, (2, 4)), 6, 8)))  # Expected output: (4, (6, (2, 4)), 6, 8)\nprint(extract_even((5, 6, (8, 7, (4, 8)), 7, 9)))  # Expected output: (6, (8, (4, 8)))\nprint(extract_even((5, 6, (9, 8, (4, 6)), 8, 10)))  # Expected output: (6, (8, (4, 6)), 8, 10)",
    "test_cases": [
      "assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)",
      "assert extract_even((5, 6, (8, 7, (4, 8)), 7, 9)) == (6, (8, (4, 8)))",
      "assert extract_even((5, 6, (9, 8, (4, 6)), 8, 10)) == (6, (8, (4, 6)), 8, 10)"
    ]
  },
  {
    "mbpp_id": 581,
    "problem_statement": "Write a python function to find the surface area of the square pyramid.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'surface_Area' is not defined",
      "Test 2: FAIL - name 'surface_Area' is not defined",
      "Test 3: FAIL - name 'surface_Area' is not defined"
    ],
    "generated_code": "def surface_area_square_pyramid(side_length, base_height):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n    \n    Parameters:\n    side_length (float): The length of one side of the square base.\n    base_height (float): The height from the center of the base to the apex of the pyramid.\n    \n    Returns:\n    float: The total surface area of the square pyramid.\n    \"\"\"\n    # Base area calculation\n    base_area = side_length ** 2\n    \n    # Slant height calculation using Pythagorean theorem\n    slant_height = ((base_height**2 + (side_length/2)**2)**0.5)\n    \n    # Lateral area calculation\n    lateral_area = 4 * (slant_height / 2) * side_length\n    \n    # Total surface area\n    surface_area = base_area + lateral_area\n    \n    return surface_area",
    "test_cases": [
      "assert surface_Area(3,4) == 33",
      "assert surface_Area(4,5) == 56",
      "assert surface_Area(1,2) == 5"
    ]
  },
  {
    "mbpp_id": 582,
    "problem_statement": "Write a function to check if a dictionary is empty or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def my_dict(d):\n    return len(d) == 0",
    "test_cases": [
      "assert my_dict({10})==False",
      "assert my_dict({11})==False",
      "assert my_dict({})==True"
    ]
  },
  {
    "mbpp_id": 583,
    "problem_statement": "Write a function for nth catalan number.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def catalan_number(n):\n    # Initialize a list to store Catalan numbers up to n\n    catalans = [0] * (n + 1)\n    \n    # Base case: the 0th and 1st Catalan numbers are both 1\n    catalans[0], catalans[1] = 1, 1\n    \n    # Calculate each Catalan number iteratively using the formula\n    for i in range(2, n + 1):\n        for j in range(i):\n            catalans[i] += catalans[j] * catalans[i - j - 1]\n            \n    return catalans[n]\n\n# Test cases\nprint(catalan_number(10))   # Expected output: 16796\nprint(catalan_number(9))    # Expected output: 4862\nprint(catalan_number(7))    # Expected output: 429",
    "test_cases": [
      "assert catalan_number(10)==16796",
      "assert catalan_number(9)==4862",
      "assert catalan_number(7)==429"
    ]
  },
  {
    "mbpp_id": 584,
    "problem_statement": "Write a function to find all adverbs and their positions in a given sentence by using regex.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "import re\n\ndef find_adverbs(sentence):\n    # Define regular expression pattern to match words ending with 'ly' as adverbs\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Find all matches of the pattern in the sentence\n    adverbs = [match.group() for match in re.finditer(pattern, sentence)]\n    \n    # Return list of found adverbs with position information\n    return [(f\"{start}-{end}: {word}\") for start, end, word in zip(*[iter(sentence)]*3) if word.endswith('ly')]\n\n# Test cases to verify the correctness of the function\nprint(find_adverbs(\"Clearly, he has no excuse for such behavior.\"))\nprint(find_adverbs(\"Please handle the situation carefully.\"))\nprint(find_adverbs(\"Complete the task quickly.\"))",
    "test_cases": [
      "assert find_adverbs(\"Clearly, he has no excuse for such behavior.\") == '0-7: Clearly'",
      "assert find_adverbs(\"Please handle the situation carefuly\") == '28-36: carefuly'",
      "assert find_adverbs(\"Complete the task quickly\") == '18-25: quickly'"
    ]
  },
  {
    "mbpp_id": 585,
    "problem_statement": "Write a function to find the n - expensive price items from a given dataset using heap queue algorithm.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: bad operand type for unary -: 'str'"
    ],
    "generated_code": "import heapq\n\ndef expensive_items(data,n):\n    # Use a min heap to store tuples of (-price, name) where negative is used to represent positive values for max-heap operation in Python\n    min_heap = []\n    \n    # Push all elements into the heap with negative prices as key to simulate a max-heap\n    for item in data:\n        heapq.heappush(min_heap, (-(item['price']), item['name']))\n        \n    # Extract the top n items\n    result = [heapq.heappop(min_heap)[1] for _ in range(n)]\n    \n    return [{'name': item, 'price': -(result[-1])}] if len(result) > 0 else []\n\n# Test cases\nprint(expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)) \nprint(expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09}],2))\nprint(expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09},{'name': 'Item-4', 'price': 22.75}],1))",
    "test_cases": [
      "assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)==[{'name': 'Item-2', 'price': 555.22}]",
      "assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09}],2)==[{'name': 'Item-2', 'price': 555.22},{'name': 'Item-1', 'price': 101.1}]",
      "assert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-3', 'price': 45.09},{'name': 'Item-4', 'price': 22.75}],1)==[{'name': 'Item-2', 'price': 555.22}]"
    ]
  },
  {
    "mbpp_id": 586,
    "problem_statement": "Write a python function to split the array and add the first part to the end.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'split_Arr' is not defined",
      "Test 2: FAIL - name 'split_Arr' is not defined",
      "Test 3: FAIL - name 'split_Arr' is not defined"
    ],
    "generated_code": "def split_arr(arr, n, k):\n    arr[:k] = reversed(arr[:n-k])\n    return arr\n\n# Test Cases\nprint(split_arr([12,10,5,6,52,36],6,2))  # Output: [5,6,52,36,12,10]\nprint(split_arr([1,2,3,4],4,1))          # Output: [2,3,4,1]\nprint(split_arr([0,1,2,3,4,5,6,7],8,3))   # Output: [3,4,5,6,7,0,1,2]",
    "test_cases": [
      "assert split_Arr([12,10,5,6,52,36],6,2) == [5,6,52,36,12,10]",
      "assert split_Arr([1,2,3,4],4,1) == [2,3,4,1]",
      "assert split_Arr([0,1,2,3,4,5,6,7],8,3) == [3,4,5,6,7,0,1,2]"
    ]
  },
  {
    "mbpp_id": 587,
    "problem_statement": "Write a function to convert a list to a tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def list_tuple(lst):\n    return tuple(lst)\n\n# Test Cases\nprint(list_tuple([5, 10, 7, 4, 15, 3])) # Expected output: (5, 10, 7, 4, 15, 3)\nprint(list_tuple([2, 4, 5, 6, 2, 3, 4, 4, 7])) # Expected output: (2, 4, 5, 6, 2, 3, 4, 4, 7)\nprint(list_tuple([58, 44, 56])) # Expected output: (58, 44, 56)",
    "test_cases": [
      "assert list_tuple([5, 10, 7, 4, 15, 3])==(5, 10, 7, 4, 15, 3)",
      "assert list_tuple([2, 4, 5, 6, 2, 3, 4, 4, 7])==(2, 4, 5, 6, 2, 3, 4, 4, 7)",
      "assert list_tuple([58,44,56])==(58,44,56)"
    ]
  },
  {
    "mbpp_id": 588,
    "problem_statement": "Write a python function to find the difference between largest and smallest value in a given array.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def big_diff(arr):\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # Return the difference between the maximum and minimum values\n    return max_val - min_val",
    "test_cases": [
      "assert big_diff([1,2,3,4]) == 3",
      "assert big_diff([4,5,12]) == 8",
      "assert big_diff([9,2,3]) == 7"
    ]
  },
  {
    "mbpp_id": 589,
    "problem_statement": "Write a function to find perfect squares between two given numbers.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def perfect_squares(start_num, end_num):\n    return [i**2 for i in range(start_num, int(end_num**0.5) + 1)]\n\n# Test cases\nprint(perfect_squares(1, 30))  # Expected output: [1, 4, 9, 16, 25]\nprint(perfect_squares(50, 100))  # Expected output: [64, 81, 100]\nprint(perfect_squares(100, 200))  # Expected output: [100, 121, 144, 169, 196]",
    "test_cases": [
      "assert perfect_squares(1,30)==[1, 4, 9, 16, 25]",
      "assert perfect_squares(50,100)==[64, 81, 100]",
      "assert perfect_squares(100,200)==[100, 121, 144, 169, 196]"
    ]
  },
  {
    "mbpp_id": 590,
    "problem_statement": "Write a function to convert polar coordinates to rectangular coordinates.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - TypeError: unsupported operand type(s) for -: 'tuple' and 'tuple'"
    ],
    "generated_code": "import cmath\n\ndef polar_rect(rho, theta):\n    \"\"\"\n    Convert polar coordinates (rho, theta) into rectangular coordinates (x, y).\n    \n    Parameters:\n        rho (float): The radial distance.\n        theta (float): The angle in radians.\n        \n    Returns:\n        tuple: A tuple containing the x and y components of the rectangular coordinates.\n    \"\"\"\n    x = rho * cmath.cos(theta)\n    y = rho * cmath.sin(theta)\n    return (x.real, y.real)\n\n# Check function with provided data points\nassert abs(polar_rect(3, 4) - ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))) < 1e-9\nassert abs(polar_rect(4, 7) - ((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))) < 1e-9\nassert abs(polar_rect(15, 17) - ((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))) < 1e-9\nprint(\"All test cases passed.\")",
    "test_cases": [
      "assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))",
      "assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j))",
      "assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j))"
    ]
  },
  {
    "mbpp_id": 591,
    "problem_statement": "Write a python function to interchange the first and last elements in a list.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def swap_List(lst):\n    \"\"\"\n    This function takes a list as input and returns a new list with the first element moved to the end and the last element moved to the beginning.\n    \n    Parameters:\n    lst (list): The original list of integers.\n    \n    Returns:\n    list: A new list with the first and last elements swapped.\n    \"\"\"\n    # Ensure the list is not empty before proceeding\n    if len(lst) > 0:\n        # Swap the first and last elements\n        lst[0], lst[-1] = lst[-1], lst[0]\n    return lst",
    "test_cases": [
      "assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]",
      "assert swap_List([1, 2, 3]) == [3, 2, 1]",
      "assert swap_List([4, 5, 6]) == [6, 5, 4]"
    ]
  },
  {
    "mbpp_id": 592,
    "problem_statement": "Write a python function to find sum of product of binomial co-efficients.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - name 'sum_Of_product' is not defined",
      "Test 2: FAIL - name 'sum_Of_product' is not defined",
      "Test 3: FAIL - name 'sum_Of_product' is not defined"
    ],
    "generated_code": "import math\n\ndef sum_of_product(n):\n    total_sum = 0\n    for i in range(n + 1):\n        total_sum += int(math.factorial(n) / (math.factorial(i) * math.factorial(n - i)))\n    return total_sum",
    "test_cases": [
      "assert sum_Of_product(3) == 15",
      "assert sum_Of_product(4) == 56",
      "assert sum_Of_product(1) == 1"
    ]
  },
  {
    "mbpp_id": 593,
    "problem_statement": "Write a function to remove leading zeroes from an ip address.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def removezero_ip(ip):\n    # Remove '0' characters at the beginning and end of each octet in the IP address\n    return '.'.join([i for i in ip.split('.') if i != '0'])\n\n# Test cases\nprint(removezero_ip(\"216.08.094.196\"))  # Expected output: \"216.8.94.196\"\nprint(removezero_ip(\"12.01.024\"))       # Expected output: \"12.1.24\"\nprint(removezero_ip(\"216.08.094.0196\")) # Expected output: \"216.8.94.196\"",
    "test_cases": [
      "assert removezero_ip(\"216.08.094.196\")==('216.8.94.196') ",
      "assert removezero_ip(\"12.01.024\")==('12.1.24') ",
      "assert removezero_ip(\"216.08.094.0196\")==('216.8.94.196') "
    ]
  },
  {
    "mbpp_id": 594,
    "problem_statement": "Write a function to find the difference of first even and odd number of a given list.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - Result does not match expected output",
      "Test 2: FAIL - Result does not match expected output",
      "Test 3: FAIL - Result does not match expected output"
    ],
    "generated_code": "def diff_even_odd(lst):\n    # Find the first even and odd numbers in the list\n    evens = [x for x in lst if x % 2 == 0]\n    odds = [x for x in lst if x % 2 != 0]\n\n    # Return the difference between the sum of even numbers and the sum of odd numbers\n    return sum(evens) - sum(odds)",
    "test_cases": [
      "assert diff_even_odd([1,3,5,7,4,1,6,8])==3",
      "assert diff_even_odd([1,2,3,4,5,6,7,8,9,10])==1",
      "assert diff_even_odd([1,5,7,9,10])==9"
    ]
  },
  {
    "mbpp_id": 595,
    "problem_statement": "Write a python function to count minimum number of swaps required to convert one binary string to another.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - 'int' object is not iterable",
      "Test 2: FAIL - 'int' object is not iterable",
      "Test 3: FAIL - 'int' object is not iterable"
    ],
    "generated_code": "def min_Swaps(bin_str1, bin_str2):\n    if len(bin_str1) != len(bin_str2):\n        return \"Not Possible\"\n    \n    swaps = 0\n    for i in range(len(bin_str1)):\n        if bin_str1[i] == '1' and bin_str2[i] == '0':\n            swaps += 1\n        elif bin_str1[i] == '0' and bin_str2[i] == '1':\n            swaps += 1\n    \n    # Check for conflicts after swapping all '1's with '0's and vice versa\n    if sum(bin_str1.count('1')) > len(bin_str1)/2:\n        return str(swaps // 2)\n    else:\n        return \"Not Possible\"",
    "test_cases": [
      "assert min_Swaps(\"1101\",\"1110\") == 1",
      "assert min_Swaps(\"111\",\"000\") == \"Not Possible\"",
      "assert min_Swaps(\"111\",\"110\") == \"Not Possible\""
    ]
  },
  {
    "mbpp_id": 596,
    "problem_statement": "Write a function to find the size of the given tuple.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "import sys\n\ndef tuple_size(tup):\n    \"\"\"\n    Returns the size in bytes of a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple whose size is to be found.\n    \n    Returns:\n    int: Size of the tuple in bytes.\n    \"\"\"\n    return sys.getsizeof(tup)",
    "test_cases": [
      "assert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3) ) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))",
      "assert tuple_size((1, \"Raju\", 2, \"Nikhil\", 3, \"Deepanshu\") ) == sys.getsizeof((1, \"Raju\", 2, \"Nikhil\", 3, \"Deepanshu\"))",
      "assert tuple_size(((1, \"Lion\"), ( 2, \"Tiger\"), (3, \"Fox\"), (4, \"Wolf\"))  ) == sys.getsizeof(((1, \"Lion\"), ( 2, \"Tiger\"), (3, \"Fox\"), (4, \"Wolf\")))"
    ]
  },
  {
    "mbpp_id": 597,
    "problem_statement": "Write a function to find kth element from the given two sorted arrays.",
    "passed": false,
    "error": null,
    "test_outputs": [
      "Test 1: FAIL - SyntaxError: invalid syntax"
    ],
    "generated_code": "```python\ndef find_kth(arr1, arr2, n1, n2, k):\n    if n1 == 0:\n        return arr2[k-1]\n    if n2 == 0:\n        return arr1[k-1]\n\n    if k > n1 + n2:\n        raise ValueError(\"k is greater than total elements in both arrays\")\n\n    mid1 = n1 // 2\n    mid2 = n2 // 2\n\n    if mid1 + mid2 < k:\n        if arr1[mid1] >= arr2[mid2]:\n            return find_kth(arr1, arr2[mid2:], n1 - min(mid1, n2), k - mid2 - max(0, n1 - mid1), k)\n        else:\n            return find_kth(arr1[:mid1], arr2, n1 - min(mid1, n2), n2 - min(mid2, n1), k - mid1 - max(0, n1 - mid1))\n    else:\n        if arr1[n1 - 1] >= arr2[n2 - 1]:\n            return find_kth(arr1[:n1], arr2, n1 - min(n1, n2), n2 - min(n1, n2), k - n1 - max(0, n1 - n2))\n        else:\n            return find_kth(arr1, arr2[:n2], n1 - min(n1, n2), n2 - min(n1, n2), k - n2 - max(0, n2 - n1))\n\n# Test cases\nprint(find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5, 4, 5))  # Output: 6\nprint(find_kth([100, 112, 256, 349, 770], [72, 86, 113, 119, 265, 445, 892], 5, 7, 7))  # Output: 256\nprint(find_kth([3, 4, 7, 8, 10], [2, 5, 9, 11], 5, 4, 6))  # Output",
    "test_cases": [
      "assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5, 4, 5) == 6",
      "assert find_kth([100, 112, 256, 349, 770], [72, 86, 113, 119, 265, 445, 892], 5, 7, 7) == 256",
      "assert find_kth([3, 4, 7, 8, 10], [2, 5, 9, 11], 5, 4, 6) == 8"
    ]
  },
  {
    "mbpp_id": 598,
    "problem_statement": "Write a function to check whether the given number is armstrong or not.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def armstrong_number(n):\n    # Calculate the number of digits in n\n    num_digits = len(str(n))\n    \n    # Initialize sum of each digit raised to the power of the number of digits\n    sum_of_digits = 0\n    \n    # Extract each digit and raise it to the power of the number of digits\n    temp_n = n\n    while temp_n > 0:\n        digit = temp_n % 10\n        sum_of_digits += digit ** num_digits\n        temp_n //= 10\n    \n    # If the calculated sum equals the original number, return True; otherwise, return False\n    return n == sum_of_digits",
    "test_cases": [
      "assert armstrong_number(153)==True",
      "assert armstrong_number(259)==False",
      "assert armstrong_number(4458)==False"
    ]
  },
  {
    "mbpp_id": 599,
    "problem_statement": "Write a function to find sum and average of first n natural numbers.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def sum_average(n):\n    # Calculate sum using the formula for the sum of an arithmetic series\n    total_sum = n * (n + 1) / 2\n    \n    # Calculate average\n    avg = total_sum / n\n    \n    return (total_sum, avg)\n\n# Test cases\nprint(sum_average(10))   # Expected output: (55.0, 5.5)\nprint(sum_average(15))   # Expected output: (120.0, 8.0)\nprint(sum_average(20))   # Expected output: (210.0, 10.5)",
    "test_cases": [
      "assert sum_average(10)==(55, 5.5)",
      "assert sum_average(15)==(120, 8.0)",
      "assert sum_average(20)==(210, 10.5)"
    ]
  },
  {
    "mbpp_id": 600,
    "problem_statement": "Write a python function to check whether the given number is even or not using bitwise operator.",
    "passed": true,
    "error": null,
    "test_outputs": [
      "Test 1: PASS - All Clear",
      "Test 2: PASS - All Clear",
      "Test 3: PASS - All Clear"
    ],
    "generated_code": "def is_Even(num):\n    # Check if num & 1 equals 0\n    return num & 1 == 0",
    "test_cases": [
      "assert is_Even(1) == False",
      "assert is_Even(2) == True",
      "assert is_Even(3) == False"
    ]
  }
]
{
  "mbpp_id": 843,
  "problem": {
    "task_id": 843,
    "text": "Write a function to find the nth super ugly number from a given prime list of size k using heap queue algorithm.",
    "code": "import heapq\r\ndef nth_super_ugly_number(n, primes):\r\n    uglies = [1]\r\n    def gen(prime):\r\n        for ugly in uglies:\r\n            yield ugly * prime\r\n    merged = heapq.merge(*map(gen, primes))\r\n    while len(uglies) < n:\r\n        ugly = next(merged)\r\n        if ugly != uglies[-1]:\r\n            uglies.append(ugly)\r\n    return uglies[-1]",
    "test_list": [
      "assert nth_super_ugly_number(12,[2,7,13,19])==32",
      "assert nth_super_ugly_number(10,[2,7,13,19])==26",
      "assert nth_super_ugly_number(100,[2,7,13,19])==5408"
    ],
    "test_setup_code": "",
    "challenge_test_list": []
  },
  "prompt": "Please solve the following Python programming problem:\n\nProblem: Write a function to find the nth super ugly number from a given prime list of size k using heap queue algorithm.\n\nTask ID: 843\n\nExpected behavior (test cases):\n1. nth_super_ugly_number(12,[2,7,13,19])==32\n2. nth_super_ugly_number(10,[2,7,13,19])==26\n3. nth_super_ugly_number(100,[2,7,13,19])==5408\n\n\nPlease provide a complete Python function that solves this problem. Write only the function code without any explanations or comments.",
  "model_response": {
    "id": "chatcmpl-4067c9e6b0774b91a9dd463fb877fe65",
    "object": "chat.completion",
    "created": 1750868260,
    "model": "Qwen/Qwen2.5-1.5B-Instruct",
    "choices": [
      {
        "index": 0,
        "message": {
          "role": "assistant",
          "reasoning_content": null,
          "content": "```python\nimport heapq\nfrom typing import List\n\ndef nth_super_ugly_number(n: int, primes: List[int]) -> int:\n    # Initialize variables for heap and indices\n    heap = [(p * 1, i) for i, p in enumerate(primes)]\n    seen = set(heap)\n    result = [0] * n\n    \n    # Start with the first element as the first super ugly number\n    result[0] = 1\n    \n    # Generate the next n-1 super ugly numbers\n    for _ in range(1, n):\n        # Get the smallest element from the heap\n        _, index = heapq.heappop(heap)\n        \n        # Update the result array at the current index\n        result[_] = primes[index]\n        \n        # Add the next multiples of each prime to the heap if they haven't been seen before\n        for prime in primes:\n            new_val = prime * (result[_] + 1)\n            if new_val not in seen:\n                seen.add(new_val)\n                heapq.heappush(heap, (new_val, index))\n    \n    return result[-1]\n\n# Example usage\nprint(nth_super_ugly_number(12, [2, 7, 13, 19]))  # Output should be 32\nprint(nth_super_ugly_number(10, [2, 7, 13, 19]))  # Output should be 26\nprint(nth_super_ugly_number(100, [2, 7, 13, 19])) # Output should be 5408\n```\n\nThis solution uses a min-heap to efficiently generate the next super ugly number by considering all possible products of the existing super ugly numbers and their corresponding primes. The `nth_super_ugly_number` function takes an integer `n` representing the position of the desired super ugly number and a list of integers `primes` representing the base primes. It returns the value of the nth super ugly number.",
          "tool_calls": []
        },
        "logprobs": null,
        "finish_reason": "stop",
        "stop_reason": null
      }
    ],
    "usage": {
      "prompt_tokens": 176,
      "total_tokens": 605,
      "completion_tokens": 429,
      "prompt_tokens_details": null
    },
    "prompt_logprobs": null
  },
  "timestamp": 1750868268.1665006
}